\section{Introduction}
\label{sec:impl-intro}
Having developed the theory of lenses and instantiating the framework with a
syntax, we now give an exposition on preliminary efforts to instantiate the
syntax as a concrete program. Our work on a prototype has two main purposes.
% TODO: the wording of this first purpose needs some serious polish
The edit lens framework is predicated on a relatively abstract, algebraic
data model, whereas long-term data storage on computers typically employs a
fairly low-level model based on strings. When only the data is important,
these two realms are typically connected by defining a parser that processes
strings and produces a more structured representation, as well as a
formatter that produces a string representation of a given structure. For
edit lenses, however, not only the data is important; one also wants access
to the edits made to the data. So the primary goal is to investigate what
extensions are needed to describe the connection between edits to strings
and edits to structured data. A secondary goal is to validate that the
fundamental edit lens design is complete; producing a few example
transformations gives an opportunity for any unforeseen infelicities to rear
their head. In the pursuit of these goals, we discuss two artifacts: first,
a core library which closely models the edit lens theory given in
Chapter~\ref{chap:edits}; and second, a demonstration program that
synchronizes two simple, text-based databases according to a predetermined
lens. The latter task involves building a text-editing GUI, connecting the
lens to the GUI, and validating and extracting edits from user actions,
tasks that fall outside the realm of the existing edit lens theory.

We have chosen to implement our demo in Haskell, a language which encourages
high abstraction levels, supports rapid prototyping, and has good library
support. Because one of our primary goals was experimentation, we wanted to
retain a lightweight approach throughout; in particular we chose not to
begin with a mechanization of the theory in a dependently-typed language.
(In retrospect, while it still seems worthwhile to have avoided reproving
all of our results in Coq from an experimentation point of view, it is not
clear that avoiding dependent types entirely was beneficial. For example,
the way we used Haskell's typeclass mechanism to model modules would really
have benefited from dependent types, as we often found ourselves wishing for
the ability to define new types for different choices of $\init$ value.) We
also investigated extending Boomerang~\cite{Boomerang07}, an existing
asymmetric, state-based string lens implementation. Boomerang is very
complete, and consequently would have required many tangential coding
efforts; to avoid distractions, we chose to take a less feature-complete
route. However, we retained Boomerang's choice of string-based data model
since, as discussed above, this closely matches real-world scenarios.

Our primary challenge, which we will discuss in detail below, can be broadly
described as parsing. With edit lenses, there are always two domains of
discourse: the collection of repositories and the collection of edits.
Repositories store ordinary data, and the problem of connecting strings with
structured data is well-studied under the umbrella of parsing. (Turning
structured data into a string---often called serialization---is typically a
significantly simpler task.) However, standard parsing techniques---even
incremental techniques purportedly designed for making it easy to maintain a
correct parse tree in the presence of ongoing updates---do not adequately
describe the connection between string modifications and edits in the sense
described in Chapter~\ref{chap:delta}. One could avoid the situation
entirely by designing a structured editor. Historically, though, structured
editors have failed to take---perhaps because their strictures are too
confining for day-to-day editing tasks---so we chose to avoid this route. We
have proposed a few heuristics that seem to behave acceptably in a number of
standard cases; however, they are relatively special-purpose (tailored to
the file format under consideration here) and do not adequately reflect all
user actions as analogous edits. This seems like a promising area for future
efforts.

\section{Usage Example and Functionality}
\label{sec:impl-usage}
In order to ground the discussion, we give here a quick overview of the
capabilities of the program we have built. When started, the program
presents a GUI containing two text-editing panes in which the user can
freely type. The two texts in the panes are connected by a lens, so that
when the text in one pane has been suitably modified, the text in the other
pane spontaneously changes to maintain synchrony. The particular lens we
will demonstrate below is a variant of the lens in
Figure~\ref{fig:span-lenses}, but instead of connecting teachers, salaries,
and room assignments, we will connect composers, birth years, and birth
countries. In one repository, we will have a list of newline-terminated
records, where each record has a composer's name and birth year separated by
a comma. In the other, each record has a composer's name and birth country
separated by a semicolon. Figure~\ref{subfig:prototype-1} gives a pair of
example synchronized repositories entered into our program's text panes. In
the abstract notation of Chapter~\ref{chap:edits}, the lens connecting the
two panes might be written as $(\id\otimes\disconnect)\LIST$. The concrete
lens used here must include a bit more information---for example,
instructions to change the comma separating parts of the record into a
semicolon, or a check that dates consist of exactly four digits---but we
will skip discussing these surface syntax issues for now. In any case, the
typical chain of events begins with the user making an edit to one of the
repositories. This user action is processed to produce alignment information
between the old and new repositories, which is handed to the underlying edit
lens' $\dputr$ or $\dputl$ function; the computed edit is then used to
produce a ``user'' action which is automatically applied to the other
repository.

The remainder of Figure~\ref{fig:prototype-screenshots} demonstrates how the
text panes would evolve under a few plausible edits to the repositories.
Part~\subref{subfig:prototype-2} shows what happens when the user adds an
extra line to the text pane on the right. As the right-hand repository now
has an extra record for Mozart, the lens produces an insertion that adds a
record for Mozart to the repository on the left, using a default birth year.
Since the insertion is inferred by watching the typing commands performed by
the user, the alignment for insertions of this kind can be exact: even if
the user were to duplicate a record from elsewhere in the database, no
confusion would arise, and a new record would appear with default data in
the correct location in the other repository. Similarly, when the user
deletes a line---in this case, the record for Haydn---on the right, the
program maintains synchrony by deleting the record for Haydn from the left
pane, as shown in part~\subref{subfig:prototype-3}. The left pane may also
be edited by the user, as demonstrated in part~\subref{subfig:prototype-4},
where Haydn has been re-inserted into the repository on the left, resulting
in a computed insertion containing a default country on the right. In
addition to the wholesale insertion and deletion of records, the user may
modify parts of a single record, and the program will correctly maintain
alignment of the edited records. Part~\subref{subfig:prototype-5} shows that
modifications to data that appears in only one repository has no effect on
the other, while in part~\subref{subfig:prototype-6} the user has corrected
the name ``Hayn'' to ``Haydn'' in the right repository, and this is
correctly reflected as an update to the left repository without losing
Haydn's birth year. Because we have access to the actions performed by the
user, we need not guess about whether the old ``Hayn'' record should be
aligned with the new ``Haydn'' record in this case. On the other hand, there
are certainly edits where the user intention is still not entirely clear;
parts~\subref{subfig:prototype-7} and~\subref{subfig:prototype-8} show the
user constructing a new record on the right that contains bits and pieces of
several old records (by performing a deletion that crosses record
boundaries). As pictured, our heuristics choose to treat this as a deletion
of all the old records that contributed and the insertion of a completely
fresh record, so a default birth year is used for the new record in the left
repository.

This final example begins to hint at some of the oddities that can arise
when attempting to translate between edits to a serialized structure and
edits to the abstract structure, which we will discuss in
\S\ref{sec:parsing}.

% TODO: this reverse highlighting experiment turned out a little strange
% because of the document's white background; let's try more orthodox
% highlighting or a circle around the change or something like that instead
\begin{figure}
    \centering
    \protofig1{An initial pair of databases in two text editing panes.}
    \hfil
    \protofig2{Insertion on the right introduces some default data on the
    left.}
    \vspace{4ex}

    \protofig3{Deleting a row from either side is reflected to the other
    automatically.}
    \hfil
    \protofig4{A default country is used for the new row on the right.}
    \vspace{4ex}

    \protofig5{Correcting the country has no effect\ldots}
    \hfil
    \protofig6{\ldots but correcting the spelling of either name corrects
    both.}
    \vspace{4ex}

    \protofig7{More bizarre edits, like this deletion that spans
    records\ldots}
    \hfil
    \protofig8{\ldots reset the alignment, but only for the affected region.}
    \vspace{4ex}

    \caption{A demonstration use of the prototype, using the composers lens}
    \label{fig:prototype-screenshots}
\end{figure}

\section{Implementation Details}
\label{sec:impl-details}
\label{sec:impl-parsing}
\label{sec:parsing}
In this section, we will begin with a brief overview of the architecture of
the program, with an eye toward guiding the interested reader towards the
appropriate part of the full source in \S\ref{app:code}. (The explanatory
material in this part will therefore be quite brief.) We will then discuss
the heuristics used to convert user actions into edits in some detail. After
describing the current transformation, we will consider some advantages and
disadvantages of this approach as well as possible ways forward with this
challenging area of the implementation.

The program code broadly recapitulates the development of edit lenses in
Chapter~\ref{chap:edits} (though behavioral equivalence does not make an
appearance, since its primary use is in proofs). A typeclass for monoids
already exists in the base libraries of Haskell; an extension of this
typeclass to a class for modules, along with facilities for building modules
in terms of free monoids, is given in \module{Data.Module.Class}. We chose
to implement lenses as a typeclass as well; thus, to create a new lens, one
typically declares a new type with a single constructor. One can view this
as giving a way to overload the names \texttt{dputr} and
\texttt{dputl}---the way we write $\dputr$ and $\dputl$ in the
implementation---for many lenses. (Another approach would be to write lenses
as a record; using a typeclass makes associating a complement type with the
lens slightly less intrusive. Yet another way would be to give an explicit
type representing the abstract syntax tree of edit lenses given in this
paper; one advantage of typeclasses over algebraic types is that they are
open, meaning programmers can add to the collection of lenses without
modifying the core library.) This typeclass, along with facilities for
defining $\dputr$ and $\dputl$ by monoid presentation, is available from
\module{Data.Lens.Edit.Stateful}. The \texttt{Stateful} part of the name
alludes to the existence of a complement; \module{Data.Lens.Edit.Stateless}
contains an experimental typeclass for edit lenses which do not need a
complement, and many of the lens types we define below will implement both
the \texttt{Stateful} and \texttt{Stateless} versions of the \texttt{Lens}
typeclass. These modules together cover the theoretical framework of edit
lenses, but give no syntax.

The basic lenses ($\id$, composition, $-\op$, and $\disconnect$) are
implemented in the \module{Data.Lens.Edit.Primitive} module. The $\Unit$
edit module is implemented in \module{Data.Module.Primitive}. The modules
for tensor products and sums are given in \module{Data.Module.Product} and
\module{Data.Module.Sum} (and are built on the product and sum types from
Haskell's base library), and the lenses are given in
\module{Data.Lens.Edit.Product} and \module{Data.Lens.Edit.Sum}. Similarly,
the module for list editing is given in \module{Data.Module.List} (and is
built on the list type from Haskell's base library), while the $\map$ and
$\partition$ lenses are implemented in \module{Data.Lens.Edit.List}. There
is no generic container type in Haskell's base library, so this is given in
\module{Data.Container}, together with the module for editing list shapes
from Example~\ref{ex:list-shapes} in \module{Data.Module.Shape}, a module
for editing containers in \module{Data.Module.Container}, and the mapping
lens in \module{Data.Lens.Edit.Container}.

This completes the recapitulation of edit lenses; the program itself then
includes a handful of modules that go beyond the theory.
\module{Data.Module.String} contains the most interesting extended
functionality. It includes the \texttt{StringModule} typeclass which adds
methods for parsing, serializing, and checking validity of repository
strings---all fairly routine operations---as well as a method for
translating string edits to \texttt{Module} edits. This typeclass is then
instantiated for a handful of types, and some utilities are given for
defining base modules with a particular $\init$ value. These utilities are
wrapped up in \module{Data.Lens.Edit.String}, which offers some combinators
for creating triples containing a value with a \texttt{StringModule}
instance for each repository and a value with a \texttt{Lens} instance
connecting the \texttt{Module}s associated with those
\texttt{StringModule}s. Finally, the top-level program lies in
\texttt{lens-editor.hs} (\S\ref{mod:lens-editor}), which defines a
particular string lens, constructs a GUI with two text panes, allocates a
reference cell for the complement, and connects the text panes' editing
events to invocations of the appropriate \texttt{StringModule} functions.
This discussion is summarized in Figure~\ref{fig:module-hierarchy}.

\begin{figure}
    \centering
    \begin{description}
        \item[Data.Container] a generic container type, with a typeclass for
            container shapes
        \item[Data.Iso] a data type for isomorphisms (primarily used internally)
        \item[Data.Lens.Bidirectional] a typeclass for bidirectional
            transformations, used to unify the source- and target-type
            structure of isomorphisms and the two kinds of lenses
        \item[Data.Lens.Edit] convenience module: re-exports some submodules

            \begin{description}
                \item[.Stateful] \texttt{Lens} typeclass for standard edit
                    lenses
                \item[.Stateless] \texttt{Lens} typeclass for edit lenses
                    with no complement
                \item[.Primitive] base lenses
                \item[.Product] $\otimes$ lens combinator
                \item[.Sum] $\oplus$ lens combinator
                \item[.List] $\map$ and $\partition$ lenses
                \item[.Container] container-mapping lens
                \item[.String] lens combinators that also construct
                    \texttt{StringModule}s
            \end{description}
        \item[Data.Module] convenience module: re-exports some submodules

            \begin{description}
                \item[.Class] \texttt{Module} typeclass, with instance for
                    free monoid-based modules
                \item[.Primitive] $\Unit$ module
                \item[.Product] $\otimes$ module
                \item[.Sum] $\oplus$ module
                \item[.List] $-\LIST$ module
                \item[.Shape] a module for editing the shape of lists
                    construed as containers
                \item[.Container] container-based module
                \item[.String] \texttt{StringModule} typeclass and instances
                    for the several modules
            \end{description}
        \item[Main] set up and execute a \texttt{StringModule}-powered GUI
    \end{description}
    \caption{Summary of the module hierarchy in the prototype
    implementation}
    \label{fig:module-hierarchy}
\end{figure}

Given this overview, let us discuss in more detail the process of turning
the user's edit actions into \texttt{Module}-based edits.

% TODO: at section beginning, I suggested this outline, which I think
% would be a pretty good way to proceed; perhaps turn this into a real
% outline before trying to write:
% * what exactly the problem to solve is (i.e. carefully describe the
%   inputs and outputs of the function we need to write, why it's
%   important to get accurate results, etc.) [not in the introductory
%   section]
% * how we currently perform this transformation
% * advantages and disadvantages of this approach
% * possible ways forward
parsing: our theory doesn't cover the translation between user's editing actions and structured alignment information
\begin{enumerate}
    \item There can be unallowable edit data when the edit is partially finished
    \item Even small edits can have a large smallest containing subtree
    \item incremental parsers are good at producing an updated tree, but doesn't produce alignment information between the old and updated tree
    \item incremental parsers are typically imperative, and our framework is primarily functional
    \item tree edit type-checking is complicated, and doesn't offer as much insight as we hoped on how to produce edit-lens edits
    \item Small edits can radically change the parsed structure (what does that mean?)
\end{enumerate}

\section{Conclusion}
\label{sec:impl-conclusion}
\begin{enumerate}
    \item Message: this is an existing library and an associated GUI that extracts alignment information from user actions
    \item Message: the existence of a working library is an indication that the theoretical foundation can be realized
    \item Message: practical use may require the foundation to be extended to cover parsing user edits into alignment information
    \item Message: this library could be used for further studies of edit lenses beyond the scope of the current work
        \begin{enumerate}
            \item original purpose: convert a string edit into a tree edit (resulted in a hard problem)
            \item demonstrate usability of the syntax by generating some practical examples
            \item show a performance advantage
            \item demonstrate a practical application of lenses (we have a long list of ideas about this)
        \end{enumerate}
    \item Outcome: we need new techniques for some parts, but core library can be elegant
\end{enumerate}
