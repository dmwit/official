\section{Introduction}
\label{sec:impl-intro}
Having developed the theory of lenses and instantiating the framework with a
syntax, we now give an exposition on preliminary efforts to instantiate the
syntax as a concrete program. Our work on a prototype has two main purposes.
% TODO: the wording of this first purpose needs some serious polish
The edit lens framework is predicated on a relatively abstract, algebraic
data model, whereas long-term data storage on computers typically employs a
fairly low-level model based on strings. When only the data is important,
these two realms are typically connected by defining a parser that processes
strings and produces a more structured representation, as well as a
formatter that produces a string representation of a given structure. For
edit lenses, however, not only the data is important; one also wants access
to the edits made to the data. So the primary goal is to investigate what
extensions are needed to describe the connection between edits to strings
and edits to structured data. A secondary goal is to validate that the
fundamental edit lens design is complete; producing a few example
transformations gives an opportunity for any unforeseen infelicities to rear
their head. In the pursuit of these goals, we discuss two artifacts: first,
a core library which closely models the edit lens theory given in
Chapter~\ref{chap:edits}; and second, a demonstration program that
synchronizes two simple, text-based databases according to a predetermined
lens. The latter task involves building a text-editing GUI, connecting the
lens to the GUI, and validating and extracting edits from user actions,
tasks that fall outside the realm of the existing edit lens theory.

We have chosen to implement our demo in Haskell, a language which encourages
high abstraction levels, supports rapid prototyping, and has good library
support. Because one of our primary goals was experimentation, we wanted to
retain a lightweight approach throughout; in particular we chose not to
begin with a mechanization of the theory in a dependently-typed language.
(In retrospect, while it still seems worthwhile to have avoided reproving
all of our results in Coq from an experimentation point of view, it is not
clear that avoiding dependent types entirely was beneficial. For example,
the way we used Haskell's typeclass mechanism to model modules would really
have benefited from dependent types, as we often found ourselves wishing for
the ability to define new types for different choices of $\init$
value.) We also investigated extending Boomerang~\cite{Boomerang07}, an
existing asymmetric, state-based string lens implementation. Boomerang is
very complete, and consequently would have required many tangential coding
efforts; to avoid distractions, we chose to take a less feature-complete
route. However, we retained Boomerang's choice of string-based data model
since, as discussed above, this closely matches real-world scenarios.

Our primary challenge, which we will discuss in detail below, can be broadly
described as parsing. With edit lenses, there are always two domains of
discourse: the collection of repositories and the collection of edits.
Repositories store ordinary data, and the problem of connecting strings with
structured data is well-studied under the umbrella of parsing. (Turning
structured data into a string---often called serialization---is typically a
significantly simpler task.) However, standard parsing techniques---even
incremental techniques purportedly designed for making it easy to maintain a
correct parse tree in the presence of ongoing updates---do not adequately
describe the connection between string modifications and edits in the sense
described in Chapter~\ref{chap:delta}. We have proposed a few heuristics
that seem to behave acceptably in a number of standard cases; however, they
are relatively special-purpose (tailored to the file format under
consideration here) and do not adequately reflect all user actions as
analogous edits. This seems like a promising area for future efforts.

\section{Usage Example and Functionality}
\label{sec:impl-usage}
In order to ground the discussion, we give here a quick overview of the
capabilities of the program we have built. When started, the program
presents a GUI containing two text-editing panes in which the user can
freely type. The two texts in the panes are connected by a lens, so that
when the text in one pane has been suitably modified, the text in the other
pane spontaneously changes to maintain synchrony. The particular lens we
will demonstrate below is a variant of the lens in
Figure~\ref{fig:span-lenses}, but instead of connecting teachers, salaries,
and room assignments, we will connect composers, birth years, and birth
countries. In one repository, we will have a list of newline-terminated
records, where each record has a composer's name and birth year separated by
a comma. In the other, each record has a composer's name and birth country
separated by a semicolon. Figure~\ref{subfig:prototype-1} gives a pair of
example synchronized repositories entered into our program's text panes. In
the abstract notation of Chapter~\ref{chap:edits}, the lens connecting the
two panes might be written as $(\id\otimes\disconnect)\LIST$. The concrete
lens used here must include a bit more information---for example,
instructions to change the comma separating parts of the record into a
semicolon, or a check that dates consist of exactly four digits---but we
will skip discussing these surface syntax issues for now.

The remainder of Figure~\ref{fig:prototype-screenshots} demonstrates how the
text panes would evolve under a few plausible edits to the repositories.
Part~\subref{subfig:prototype-2} shows what happens when the user adds an
extra line to the text pane on the right. As the right-hand repository now
has an extra record for Mozart, the lens produces an insertion that adds a
record for Mozart to the repository on the left, using a default birth year.
Since the insertion is inferred by watching the typing commands performed by
the user, the alignment for insertions of this kind can be exact: even if
the user were to duplicate a record from elsewhere in the database, no
confusion would arise, and a new record would appear with default data in
the correct location in the other repository. Similarly, when the user
deletes a line---in this case, the record for Haydn---on the right, the
program maintains synchrony by deleting the record for Haydn from the left
pane, as shown in part~\subref{subfig:prototype-3}. The left pane may also
be edited by the user, as demonstrated in part~\subref{subfig:prototype-4},
where Haydn has been re-inserted into the repository on the left, resulting
in a computed insertion containing a default country on the right. In
addition to the wholesale insertion and deletion of records, the user may
modify parts of a single record, and the program will correctly maintain
alignment of the edited records. Part~\subref{subfig:prototype-5} shows that
modifications to data that appears in only one repository has no effect on
the other, while in part~\subref{subfig:prototype-6} the user has corrected
the name ``Hayn'' to ``Haydn'' in the right repository, and this is
correctly reflected as an update to the left repository without losing
Haydn's birth year. Because we have access to the actions performed by the
user, we need not guess about whether the old ``Hayn'' record should be
aligned with the new ``Haydn'' record in this case. On the other hand, there
are certainly edits where the user intention is still not entirely clear;
parts~\subref{subfig:prototype-7} and~\subref{subfig:prototype-8} show the
user constructing a new record on the right that contains bits and pieces of
several old records (by performing a deletion that crosses record
boundaries). As pictured, our heuristics choose to treat this as a deletion
of all the old records that contributed and the insertion of a completely
fresh record, so a default birth year is used for the new record in the left
repository.

This final example begins to hint at some of the oddities that can arise
when attempting to translate between edits to a serialized structure and
edits to the abstract structure, which we will discuss in
\S\ref{sec:parsing}.

% TODO: this reverse highlighting experiment turned out a little strange
% because of the document's white background; let's try more orthodox
% highlighting or a circle around the change or something like that instead
\begin{figure}
    \centering
    \protofig1{An initial pair of databases in two text editing panes.}
    \hfil
    \protofig2{Insertion on the right introduces some default data on the
    left.}
    \vspace{4ex}

    \protofig3{Deleting a row from either side is reflected to the other
    automatically.}
    \hfil
    \protofig4{A default country is used for the new row on the right.}
    \vspace{4ex}

    \protofig5{Correcting the country has no effect\ldots}
    \hfil
    \protofig6{\ldots but correcting the spelling of either name corrects
    both.}
    \vspace{4ex}

    \protofig7{More bizarre edits, like this deletion that spans
    records\ldots}
    \hfil
    \protofig8{\ldots reset the alignment only for the affected region.}
    \vspace{4ex}

    \caption{A demonstration use of the prototype, using the composers lens}
    \label{fig:prototype-screenshots}
\end{figure}

\section{Parsing and edits}
\label{sec:parsing}
% TODO: redo the outline from here out based on committee feedback
annotated code, may describe selected functions or maybe all functions (?)
\begin{enumerate}
    \item edits + edit application: the Module type class
    \item lenses, simple lenses, lens+module triples
    \item basic lenses + maybe a few combinators
    \item unparsing (needs more motivation and explanation, or less if you consider this as not being reusable code)
    \item parsing (needs more motivation and explanation, or less if you consider this as not being reusable code)
    \item connecting to a GUI + storing complements in ref cells
    \item a `bad' choice - modules are based on type classes instead of being records
\end{enumerate}

\section{Conclusion}
\label{sec:impl-conclusion}
\begin{enumerate}
    \item Message: this is an existing library and an associated GUI that extracts alignment information from user actions
    \item Message: the existence of a working library is an indication that nothing important was overlooked in the theoretical foundation
    \item Message: this library could be used for further studies of edit lenses beyond the scope of the current work
        \begin{enumerate}
            \item original purpose: convert a string edit into a tree edit (resulted in a hard problem)
            \item demonstrate usability of the syntax by generating some practical examples
            \item show a performance advantage
            \item demonstrate a practical application of lenses (we have a long list of ideas about this)
        \end{enumerate}
    \item Outcome: we need new techniques for some parts, but core library can be elegant
\end{enumerate}

\section{Full code}
\label{sec:impl-code}
perhaps appendix, or pointers to hosting, or an attachment to the dissertation, or some such thing
