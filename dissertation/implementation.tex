\section{Introduction}
\label{sec:impl-intro}
Having developed the theory of lenses and instantiating the framework with a
syntax, we now give an exposition on preliminary efforts to instantiate the
syntax as a concrete program. Our work on a prototype has two main purposes.
% TODO: the wording of this first purpose needs some serious polish
The edit lens framework is predicated on a relatively abstract, algebraic
data model, whereas long-term data storage on computers typically employs a
fairly low-level model of byte streams. When only the data is important,
these two realms are typically connected by defining a parser that processes
bytes and produces a more structured representation, as well as a formatter
that produces a byte stream representation of a given structure. For edit
lenses, however, not only the data is important; one also wants access to
the edits made to the data. So the primary goal is to investigate what
extensions are needed to describe the connection between edits to byte
streams and edits to structured data. A secondary goal is to validate that
the fundamental edit lens design is complete; producing a few example
transformations gives an opportunity for any unforeseen infelicities to rear
their head. In the pursuit of these goals, we discuss two artifacts: first,
a core library which closely models the edit lens theory given in
Chapter~\ref{chap:edits}; and second, a demonstration program that
synchronizes two simple, text-based databases according to a predetermined
lens. The latter task involves building a text-editing GUI, connecting the
lens to the GUI, and validating and extracting edits from user actions,
tasks that fall outside the realm of the edit lens theory.

\begin{enumerate}
    \item Initial choices and assumptions
        \begin{enumerate}
            \item Haskell as the programming language -- and in particular not a mechanization of the theory
            \item Chose strings as a data model (because it is often used in practice)
            \item Edits are to be extracted from user operations (applies to the example and executable)
            \item Chose not to expand the existing asymmetric string editors, in favor of a simpler approach
        \end{enumerate}
    \item Challenges
        \begin{enumerate}
            \item representing the interrelations between `things'
            \item Haskell does not have dependent types, but they would have been very useful
            \item `parsing' user actions (string edits) into structured edits
        \end{enumerate}
    \item Outcome
        \begin{enumerate}
            \item can't apply standard techniques (like incremental parsing) to parsing user actions
            \item proposed some heuristics for the parsing, but they're special-purpose and don't adequately reflect all user actions (e.g. cut/paste is not translated to a reordering)
            \item demonstrated a small, clean core library design
        \end{enumerate}
\end{enumerate}

\section{Usage Example/Description of Functionality}
\label{sec:impl-usage}
\begin{enumerate}
    \item describe database format + lens connecting them
    \item screenshots showing synchronized databases
    \item a few simple edits that get reflected; and why we can't reflect before the edit is completed
\end{enumerate}

\section{Implementation Details}
\label{sec:impl-details}
annotated code, may describe selected functions or maybe all functions (?)
\begin{enumerate}
    \item edits + edit application: the Module type class
    \item lenses, simple lenses, lens+module triples
    \item basic lenses + maybe a few combinators
    \item unparsing (needs more motivation and explanation, or less if you consider this as not being reusable code)
    \item parsing (needs more motivation and explanation, or less if you consider this as not being reusable code)
    \item connecting to a GUI + storing complements in ref cells
    \item a `bad' choice - modules are based on type classes instead of being records
\end{enumerate}

\section{Conclusion}
\label{sec:impl-conclusion}
\begin{enumerate}
    \item Message: this is an existing library and an associated GUI that extracts alignment information from user actions
    \item Message: the existence of a working library is an indication that nothing important was overlooked in the theoretical foundation
    \item Message: this library could be used for further studies of edit lenses beyond the scope of the current work
        \begin{enumerate}
            \item original purpose: convert a string edit into a tree edit (resulted in a hard problem)
            \item demonstrate usability of the syntax by generating some practical examples
            \item show a performance advantage
            \item demonstrate a practical application of lenses (we have a long list of ideas about this)
        \end{enumerate}
    \item Outcome: we need new techniques for some parts, but core library can be elegant
\end{enumerate}

\section{Full code}
\label{sec:impl-code}
perhaps appendix, or pointers to hosting, or an attachment to the dissertation, or some such thing
