\section{Introduction}
\label{sec:impl-intro}
synchronizes two simple, text-based databases according to a pre-determined lens by validating and extracting edits from user actions
\begin{enumerate}
    \item Purpose
        \begin{enumerate}
            \item validate that the fundamental design is complete enough to implement some examples
            \item investigate the connection between strings as a data model and structured data models
        \end{enumerate}
    \item Initial choices and assumptions
        \begin{enumerate}
            \item Haskell as the programming language -- and in particular not a mechanization of the theory
            \item Chose strings as a data model (because it is often used in practice)
            \item Edits are to be extracted from user operations (applies to the example and executable)
            \item Chose not to expand the existing asymmetric string editors, in favor of a simpler approach
        \end{enumerate}
    \item Challenges
        \begin{enumerate}
            \item representing the interrelations between `things'
            \item Haskell does not have dependent types, but they would have been very useful
            \item `parsing' user actions (string edits) into structured edits
        \end{enumerate}
    \item Outcome
        \begin{enumerate}
            \item can't apply standard techniques (like incremental parsing) to parsing user actions
            \item proposed some heuristics for the parsing, but they're special-purpose and don't adequately reflect all user actions (e.g. cut/paste is not translated to a reordering)
            \item demonstrated a small, clean core library design
        \end{enumerate}
\end{enumerate}

\section{Usage Example/Description of Functionality}
\label{sec:impl-usage}
\begin{enumerate}
    \item describe database format + lens connecting them
    \item screenshots showing synchronized databases
    \item a few simple edits that get reflected; and why we can't reflect before the edit is completed
\end{enumerate}

\section{Implementation Details}
\label{sec:impl-details}
annotated code, may describe selected functions or maybe all functions (?)
\begin{enumerate}
    \item edits + edit application: the Module type class
    \item lenses, simple lenses, lens+module triples
    \item basic lenses + maybe a few combinators
    \item unparsing (needs more motivation and explanation, or less if you consider this as not being reusable code)
    \item parsing (needs more motivation and explanation, or less if you consider this as not being reusable code)
    \item connecting to a GUI + storing complements in ref cells
    \item a `bad' choice - modules are based on type classes instead of being records
\end{enumerate}

\section{Conclusion}
\label{sec:impl-conclusion}
\begin{enumerate}
    \item Message: this is an existing library and an associated GUI that extracts alignment information from user actions
    \item Message: the existence of a working library is an indication that nothing important was overlooked in the theoretical foundation
    \item Message: this library could be used for further studies of edit lenses beyond the scope of the current work
        \begin{enumerate}
            \item original purpose: convert a string edit into a tree edit (resulted in a hard problem)
            \item demonstrate usability of the syntax by generating some practical examples
            \item show a performance advantage
            \item demonstrate a practical application of lenses (we have a long list of ideas about this)
        \end{enumerate}
    \item Outcome: we need new techniques for some parts, but core library can be elegant
\end{enumerate}

\section{Full code}
\label{sec:impl-code}
perhaps appendix, or pointers to hosting, or an attachment to the dissertation, or some such thing
