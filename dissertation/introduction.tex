TODO: bidirectional programming is advantageous because it is concise (one
iteration only) and has proven synchronization laws
% TODO: introduce jargon like ``repository'' and friends in here

\section{Asymmetric Lenses}
\label{sec:asymmetric-lenses}
\begin{itemize}
    \item Asymmetric Lenses
        \begin{itemize}
            \item Define what an asymmetric lens is and how its used
            \item This was the initial approach to lenses
            \item Asymmetric lenses needed to mature to add functionality
        \end{itemize}
\end{itemize}

One well-studied approach to bidirectional programming, summarized in
Figure~\ref{fig:asymmetric-lens-def}, is the framework of \emph{asymmetric},
\emph{state-based} lenses. In this model, one of the two repositories is a
% TODO: definitely, definitely need some citations
\emph{view} of or \emph{query} on the other: that is, it can be completely
reconstructed from the other without additional outside information in case
it is lost. The \GET component of a lens (together with the \rn{PutGet} law
which we discuss below) reflects this assumption. In the figure, we use the
convention that $S$ is the set of values that can be in the source
repository, and $V$ is the set of values that can be in the view repository;
likewise $s$ is a particular source and $v$ a particular view.
In most cases, a query will keep only some of the information available in
the source; as a result, the opposite reconstruction property---that the
source can be completely reconstructed from the view---usually does not
hold. Asymmetric, state-based lenses handle this situation by allowing their
other major function component to have access to both a modified value from
the view repository \emph{and} an original value from the source repository
to merge the new data into, as reflected in the type of \PUT. As a technical
detail, it is sometimes convenient to demand (and rarely difficult to
supply) a way to generate a value in the source repository with some sane
defaults.  This is the \CREATE component of
Figure~\ref{fig:asymmetric-lens-def}.
\begin{figure}
    \begin{minipage}{0.3333333\linewidth}
        \begin{align*}
            \aget &\in S \to V \\
            \aput &\in V \times S \to S \\
            \acreate &\in V \to S
        \end{align*}
    \end{minipage}
    \begin{minipage}{0.6666666\linewidth}
        \begin{align*}
            \aput(\aget(s),s) &= s  & \rn{GetPut} \\
            \aget(\aput(v,s)) &= v  & \rn{PutGet} \\
            \aget(\acreate(v)) &= v & \rn{CreateGet}
        \end{align*}
    \end{minipage}
    \caption{The required components and behavioral guarantees of a lens in
    $S \alens V$}
    \label{fig:asymmetric-lens-def}
\end{figure}

\section{Alignment}
\label{sec:intro-alignment}
One very common operation when doing functional (unidirectional) programming
is the \map operation\footnote{As of April 3, 2012, there were 3878 packages
on Hackage~\cite{Hackage2012}, the central code repository for Haskell
projects, which made a total of 90,040 calls to \map---an average of more
than twenty calls per project. In fact, the program used to calculate these
numbers itself makes two calls to \map:

\noindent\texttt{ack -cl '\textbackslash bmap\textbackslash b' | cut -d: -f2 |}

\noindent\texttt{ghc -e 'interact \$ unlines . map show . scanl (+) 0 . map read . lines'}
}, which runs a computation on each element of a list. Most serious attempts
at designing a bidirectional language therefore provide some variant of a
mapping operation. Since it is such a popular operation, it is important to
do a really good job of designing the bidirectional \map, and that job turns
out to be surprisingly difficult! To see why, let us implement \map in the
most obvious way; then we can discuss the deficiencies of this approach.

% TODO: add a subsection discussing all the notation in the whole
% dissertation? (including the whole ``record syntax'' thing)
Like the unidirectional \map, which is parameterized by a unidirectional
function to apply to list elements, our bidirectional \map will be
parameterized by a bidirectional operation. That is, when $\ell \in X \alens
Y$, we will have $\map(\ell) \in X^* \alens Y^*$ where $X^*$ is the type of
lists whose elements are drawn from $X$. In the following, we will use the
notation $\NIL$ for the empty list; $x \CONS t$ for the list whose first
element is $x$ and whose remaining elements are $t$; and
$\left<x_1,\ldots,x_n\right>$ for the list whose elements are exactly $x_1$
through $x_n$ in order.

\begin{figure}
    \begin{align*}
        \mapU(f,t) &= \cond{
            \NIL & t = \NIL \\
            f(x) \CONS \mapU(f,t') & t = x \CONS t'
        } \\
        \zip(f,g,h,t,u) &= \cond{
            f(x,y) \CONS \zip(f,g,h,t',u') & t = x:t' \land u = y:u' \\
            g(t) & t = x:t' \land u = \NIL \\
            h(u) & t = \NIL \land u = y:u' \\
            \NIL & t = u = \NIL
        } \\
        \constU(x) &= \lambda y.\;x
    \end{align*}
    \caption{Auxiliary unidirectional functions used in the definition of \map}
    \label{fig:uni-map-zip-const}
\end{figure}
\begin{figure}
    \begin{align*}
        \map(\ell).\aget(t) &= \mapU(\ell.\aget,t) \\
        \map(\ell).\acreate(u) &= \mapU(\ell.\acreate,u) \\
        \map(\ell).\aput(t,u) &=
            \zip(\ell.\aput,\mapU(\ell.\acreate),\constU(\NIL),t,u)
    \end{align*}
    \caption{A naive implementation of the bidirectional \map operation}
    \label{fig:naive-asymmetric-map}
\end{figure}
Figures~\ref{fig:uni-map-zip-const} and~\ref{fig:naive-asymmetric-map}
define the \map lens. In these figures, and in the remainder of the text, we
distinguish the unidirectional mapping operation \mapU from the
bidirectional \map.  The \GET and \CREATE operations are fairly
straightforward---direct analogues of the unidirectional version---but the
\PUT operation is more delicate. Recall that \PUT takes one value from each
repository, so again in the case where $\ell \in X \alens Y$, we will have
$\map(\ell).\aput$ taking two lists, one each of types $X^*$ and $Y^*$.
When these lists are the same length we can just ``zip'' them together with
$\ell.\aput$. When they are different lengths, we can zip together as much
as we can (up to the shorter of the two lengths), then either treat the
remainder as deletions (if the $X^*$ list is longer) and so do nothing, or
treat the remainder as insertions (if the $Y^*$ list is longer) and so use
$\ell$'s \CREATE method.

\begin{figure}
    \begin{align*}
        \tolower.\aget(c) &= \mbox{the lower case version of $c$} \\
        \tolower.\aput(c',c) &= \cond{
            \mbox{the upper case version of $c'$} & \mathtt{A} < c < \mathtt{Z} \\
            c' & \mbox{otherwise}
        } \\
        \tolower.\acreate(c) &= c
    \end{align*}
    \caption{The \tolower lens to convert a possibly-upper-case letter into
    a definitely-lower-case one}
    \label{fig:tolower-lens}
\end{figure}
Figure~\ref{fig:tolower-lens} defines a lens \tolower that converts a
character to lower case so that we can demonstrate the behavior of \map.
\begin{align*}
    \map(\tolower).\aget(\mathtt{UpperCasedQord})
        &= \mathtt{uppercasedqord} \\
    \map(\tolower).\aput(\mathtt{uppercasedword},\mathtt{UpperCasedQord})
        &= \mathtt{UpperCasedWord} \\
    \map(\tolower).\aput(\mathtt{uppercased},\mathtt{UpperCasedWord})
        &= \mathtt{UpperCased} \\
    \map(\tolower).\aput(\mathtt{uppercasedsentence},\mathtt{UpperCasedWord})
        &= \mathtt{UpperCasedSentence}
\end{align*}
All of these examples behave essentially optimally. However, not all is
well; a simple example of the so-called \emph{alignment problem} is
something like this, where we have an insertion in the middle of the word to
correct the spelling of ``upper'':
\[\map(\tolower).\aput(\mathtt{uppercasedword},\mathtt{UperCasedWord})
    = \mathtt{uppeRcaseDword}\]
Because $\map(\tolower).\aput$ only looks at a lower-cased element's
position when deciding which mixed-case character to match it up with, we
have incorrectly \emph{aligned} the new view with the old source this way:

\begin{diagram}[alignment diagram]
    \foreach \c in {U,p,e,r,C,a,s,e,d,W,o,r,d}
        {\node[on chain=source]{\c};}
    \node[on chain=view,below=5ex of source-1] {u};
    \foreach \c in {p,p,e,r,c,a,s,e,d,w,o,r,d}
        {\node[on chain=view]{\c};}
    \foreach \n in {1,...,13}
        {\draw (source-\n) -- (view-\n);}
\end{diagram}

\noindent A better alignment would look like this:

\begin{diagram}[alignment diagram]
    \foreach \c in {U,p,e,r,C,a,s,e,d,W,o,r,d}
        {\node[on chain=source]{\c};}
    \node[on chain=view,below=5ex of source-1] {u};
    \foreach \c in {p,p,e,r,c,a,s,e,d,w,o,r,d}
        {\node[on chain=view]{\c};}
    \foreach \n in {1,2}
        {\draw (source-\n) -- (view-\n);}
    \foreach \s in {3,...,13}
        {\pgfmathtruncatemacro\v{\s+1}\draw (source-\s) -- (view-\v);}
\end{diagram}

One natural reaction to this infelicity is to think of the \texttt{diff}
algorithm~\cite{hunt1976algorithm} or something similar. This idea has been
developed quite far~\cite{MatchingLenses09}; let us see how. At first blush,
it seems difficult to use the \texttt{diff} algorithm directly. Elements of
the source and view have different types, so it is not clear how to compare
them\footnote{In this case, the types are close enough that we could
probably fudge it, but in general there may be very different kinds of
objects in the source and view.}. However, the alignment diagram above may
be broken into two stages:

\begin{diagram}[alignment diagram]
    \foreach \c in {U,p,e,r,C,a,s,e,d,W,o,r,d}
        {\node[on chain=source]{\c};}
    \node[on chain=intermediate,below=5ex of source-1] {u};
    \foreach \c in {p,e,r,c,a,s,e,d,w,o,r,d}
        {\node[on chain=intermediate]{\c};}
    \node[on chain=view,below=5ex of intermediate-1] {u};
    \foreach \c in {p,p,e,r,c,a,s,e,d,w,o,r,d}
        {\node[on chain=view]{\c};}
    \foreach \n in {1,...,13}
        {\draw (source-\n) -- (intermediate-\n);}
    \foreach \n in {1,2}
        {\draw (intermediate-\n) -- (view-\n);}
    \foreach \s in {3,...,13}
        {\pgfmathtruncatemacro\v{\s+1}\draw (intermediate-\s) -- (view-\v);}
    \path
        node[right=3em of view-end,font=\rmfamily]           (view-type)
            {new view (of type $V^*$)}
        (intermediate-end -| view-type) node[font=\rmfamily] (intermediate-type)
            {old view (of type $V^*$)}
        (source-end       -| view-type) node[font=\rmfamily] (source-type)
            {old source (of type $S^*$)}
        ;
\end{diagram}

In this restructured alignment diagram, the upper alignment (which connects
elements of different types) will always be completely flat, and hence
requires no sophisticated tools to generate. In contrast, the lower
alignment contains all the interesting information, and is the one we hope
to compute with \texttt{diff}. Moreover, the connections in the lower
alignment are now between elements of the same type, making the use of
% TODO: expand these wrinkles into paragraphs/pages?
\texttt{diff} much more plausible. One wrinkle is that the data in this
example is unrealistically simple, and more complicated data often needs
more complicated tools for specifying the cost function that \texttt{diff}
uses. Another wrinkle is that in real-world situations, one often wants to
discover alignments with crossings like
\begin{diagram}[alignment diagram]
    \foreach \c in {D,i,r,G,r,a,p,h,R,e,s}
        {\node[on chain=source]{\c};}
    \node[on chain=intermediate,below=5ex of source-1] {d};
    \foreach \c in {i,r,g,r,a,p,h,r,e,s}
        {\node[on chain=intermediate]{\c};}
    \node[on chain=view,below=5ex of intermediate-1] {r};
    \foreach \c in {e,s,d,i,r,g,r,a,p,h}
        {\node[on chain=view]{\c};}
    \foreach \n in {1,...,11}
        {\draw (source-\n) -- (intermediate-\n);}
    \foreach \s in {1,...,8}
        {\pgfmathtruncatemacro\v{\s+3}
         \draw (intermediate-\s) -- (view-\v);}
    \foreach \s/\h in {9,...,11}
        {\pgfmathtruncatemacro\v{\s-8}
         \pgfmathparse{7.5-\s}
         \draw (intermediate-\s.south) to[|-|=\pgfmathresult ex] (view-\v.north);}
\end{diagram}
which require more sophisticated algorithms than the traditional
\texttt{diff}.
% TODO: expand the explanation of what's hard about guessing alignments? not
% sure; it would be pretty easy to fill a lot of space with text about that,
% but it seems sort of orthogonal to the point we're trying to make here.
% how should this whole section be structured?

Indeed, it is not even clear that it is always possible to correctly guess
the alignment given just an old and a new copy of the data, as shown in
Figure~\ref{fig:school-salaries}. Parts~\subref{fig:school-salaries-hr}
and~\subref{fig:school-salaries-sec-pre} show the human resources database
for a small school, which tracks the salaries of their teachers, along with
a document maintained by a secretary who should not be privy to salary
information. The document and the database are connected by a \map lens.
Now, suppose one of two scenarios happens:
\begin{itemize}
    \item Mary Jones gets married and changes her name to Mary Smith.
    \item Mary Jones retires, and the school hires a replacement who, by
        coincidence, shares her first name: Mary Smith.
\end{itemize}
In both cases, when the secretary updates her document, it will look as it
does in part~\subref{fig:school-salaries-sec-post}. As shown in
part~\subref{fig:school-salaries-align}, there are really two feasible
alignments. In the former scenario, we should align Mary with her former
self, and reflect the change as an update to her name (but keep her old
salary). In contrast, in the new scenario, we should not align the new Mary
with any of the teachers that used to teach at the school. Since only the
old and new copies of the secretary's document are available to a lens, the
lens cannot choose correctly: it has no way to distinguish between these two
scenarios.

\begin{figure}
    \begin{minipage}{0.33333333\linewidth}
        \centering
        \begin{tabular}{lr}
            Teacher name & Salary \\
            \hline
            Sam Rickard & 57,000 \\
            Jon Jacobs & 50,000 \\
            Mary Jones & 65,000 \\
        \end{tabular}
        \subcaption{HR's view}
        \label{fig:school-salaries-hr}
    \end{minipage}%
    \begin{minipage}{0.33333333\linewidth}
        \centering
        \begin{tabular}{l}
            Teacher name \\
            \hline
            Sam Rickard \\
            Jon Jacobs \\
            Mary Jones \\
        \end{tabular}
        \subcaption{A secretary's view}
        \label{fig:school-salaries-sec-pre}
    \end{minipage}%
    \begin{minipage}{0.33333333\linewidth}
        \centering
        \begin{tabular}{l}
            Teacher name \\
            \hline
            Sam Rickard \\
            Jon Jacobs \\
            Mary Smith \\
        \end{tabular}
        \subcaption{After an update}
        \label{fig:school-salaries-sec-post}
    \end{minipage}\\[3ex]

    \begin{minipage}{\linewidth}
        \begin{diagram}[alignment diagram, inner xsep=1em, start chain=salary]
            \path
                node[on chain=source]       {Sam Rickard}
                node[on chain=source]       {Jon Jacobs}
                node[on chain=source]       {Mary Jones}
                node[on chain=salary,below=of source-1]
                                            {57,000}
                node[on chain=salary,below=of source-2]
                                            {50,000}
                node[on chain=salary,below=of source-3]
                                            {65,000}
                node[on chain=intermediate, below=10ex of salary-1]
                                            {Sam Rickard}
                node[on chain=intermediate] {Jon Jacobs}
                node[on chain=intermediate] {Mary Jones}
                node[on chain=view, below=10ex of intermediate-1]
                                            {Sam Rickard}
                node[on chain=view]         {Jon Jacobs}
                node[on chain=view]         {Mary Smith}
                ;
            \foreach \n in {1,2,3} \draw (salary-\n) -- (intermediate-\n);
            \foreach \n in {1,2}   \draw (intermediate-\n) -- (view-\n);
            \draw[dashed] (intermediate-3) to node[right,font=\sffamily]{?} (view-3);
        \end{diagram}
        \subcaption{Whether the marked edge should be included or not
            depends on invisible context}
        \label{fig:school-salaries-align}
    \end{minipage}
    \caption{A school's staff list, as seen by HR and by the principal's secretary}
    \label{fig:school-salaries}
\end{figure}

Clearly, discovering alignment information is a tricky business.
Additionally, most current lens frameworks treat such alignment information
as a second-class citizen: it is not passed, stored, or returned by the
lens. Because of this, it is not possible for an outside tool to provide
hints about the alignment; the implementation of alignment discovery is
intermingled with the implementation of alignment usage and propagation
inside each lens' definition; and alignment information cannot be internally
communicated between lens components. The conclusion we must draw is that
doing a really good job of implementing \map involves rethinking some or all
of the theoretical foundations of lenses!

% TODO: it almost seems like this last paragraph appears out of nowhere. I
% wonder if it is worth trying to explode even that into a page or two.

\section{Symmetry}
\label{sec:intro-symmetry}
Continuing the example from \ref{sec:intro-alignment}, suppose our school
secretary decided to begin tracking which room each teacher taught in.
Figure~\ref{fig:school-rooms} shows how the two repositories might look
after this schema change. As before, the salary information should be hidden
from the secretary for privacy reasons; on the other hand, in our scenario
the human resources department is not interested in room assignments. A more
whimsical situation is shown in Figure~\ref{fig:cat-server}, in which a web
server must keep a file system storing pictures of cats synchronized with a
user-modifiable web page (modeled here as a list of cat pictures with
descriptive tags)\footnote{Pictures used with
    permission~\cite{pumpkin-cat,skateboard-cat,pineapple-cat}.}.

% TODO: possible idea: merge these two examples. e.g. perhaps the school
% example could have an org chart on the HR side; this lets you keep the
% whole ``I wish I could have a tree-flattening lens and a list mapping lens
% that I compose'' thing
\begin{figure}
    \centering
    \begin{tabular}{ll}
        Teacher name & Salary \\
        \hline
        Sam Rickard & 57,000 \\
        Jon Jacobs  & 50,000 \\
        Mary Jones  & 65,000
    \end{tabular}
    \hfil
    \begin{tabular}{ll}
        Teacher name & Room \\
        \hline
        Sam Rickard & 314 \\
        Jon Jacobs  & 108b \\
        Mary Jones  & 109
    \end{tabular}
    \caption{A slightly more complicated synchronization scenario}
    \label{fig:school-rooms}
\end{figure}

\begin{figure}
    \begin{diagram}
        \draw[short picture tree]
            node (root) {} child {
                node (Jan) {Jan}
                    \lolcatchildren{pumpkin,skateboard}
            } child {
                node (May) {May}
                    \lolcatchildren{pineapple}
            }
            ;
        \lolcattagsdef{pineapple-fs-pic}
            {pumpkin/{costume,food},skateboard/{anthro},pineapple/{food}}
    \end{diagram}
    \caption{A whimsical symmetric synchronization scenario}
    \label{fig:cat-server}
\end{figure}

Sadly, the slightly modified school scenario and the image server scenario
are both outside the realm of problems that our asymmetric, state-based lens
tools can help with. In each scenario, neither repository can be completely
reconstructed just from the information available in the other.

Since the problem is that neither repository contains all the information,
one thing that can be done is to design a third repository that \emph{does}
contain all the information. One would then design two lenses with that
third repository as a common source; Figure~\ref{fig:span-lenses} shows how
this architecture might look. The new repository sits at the top, and
contains teacher names, salaries, and room assignments all in one location.
The two repositories we are really interested in sit below, and are derived
via two lenses. (We introduce the notation $\pi_{i_1,\ldots,i_n}$ for the
lens which projects out distinct fields $i_1,\ldots,i_n$ of a tuple. To be
really precise, each omitted field would need an additional annotation
giving a value to return from the \CREATE operation, but we elide these
annotations to avoid clutter.)

Suppose the secretary updates the room assignments document. The process to
find a corresponding update for the salary document involves two lens
operations: first, we use $\map(\pi_{1,2}).\aput$ to update the common
source, then $\map(\pi_{1,3}).\aget$ to regenerate the salary document from
the common source.

\begin{figure}
    \begin{diagram}
        \node (common source) {
            \begin{tabular}{lll}
                Teacher name & Salary & Room \\
                \hline
                Sam Rickard & 57,000 & 314 \\
                Jon Jacobs  & 50,000 & 108b \\
                Mary Jones  & 65,000 & 109
            \end{tabular}
        };
        \node[below left=15ex] (salary) {
            \begin{tabular}{ll}
                Teacher name & Salary \\
                \hline
                Sam Rickard & 57,000 \\
                Jon Jacobs  & 50,000 \\
                Mary Jones  & 65,000
            \end{tabular}
        };
        \node[below right=15ex] (room) {
            \begin{tabular}{ll}
                Teacher name & Room \\
                \hline
                Sam Rickard & 314 \\
                Jon Jacobs  & 108b \\
                Mary Jones  & 109
            \end{tabular}
        };
        \draw[<->] (common source) -- node[left=1em]  {$\map(\pi_{1,2})$} (salary);
        \draw[<->] (common source) -- node[right=1em] {$\map(\pi_{1,3})$} (room);
    \end{diagram}
    \caption{If a lens doesn't work, use two!}
    \label{fig:span-lenses}
\end{figure}

This approach is workable, and is fairly comprehensive. However, it is a
little bit awkward in a few ways, the most notable of which is that we are
now constructing two lenses. Even in this simple example, we can see that
the structure of the lenses are very similar. Since one of the arguments for
using lenses in the first place was that we did not want to develop and
maintain two separate programs, this seems a bit hypocritical. It would be
better to develop some theory which models the two operations together, so
that we can write a single program and derive the two synchronization
operations of interest. One could continue by designing a
``bi-bidirectional'' language---where each term could be interpreted as two
lenses which are intended to be run back-to-back as in this example---but we
choose instead to start over from scratch and design a framework of
symmetric bidirectional transformations that natively handles scenarios like
the above one.

\begin{figure}
    \centering
    \subcaptionbox{Asymmetric, state-based lenses\label{fig:asymmetric-architecture}}
        {
        \begin{tikzpicture}
            \prettylensarchitectureoverview
            \draw
                (A.east) +(0,-0.1)
                    .. controls (B.west) and (B'.west) ..
                (near A'.center);
            \draw[->,dashed] (B)  to node[right] {user modification} (B');
            \draw[->,dashed] (A') to node[left]  {user modification} (A);
        \end{tikzpicture}
        }

    \vspace{6ex}

    \subcaptionbox{(Partial) isomorphisms\label{fig:isomorphism-architecture}}
        {
        \begin{tikzpicture}
            \prettylensarchitectureoverview
            \draw[->,dashed] (B)  to (B');
            \draw[->,dashed] (A') to (A);
        \end{tikzpicture}
        }
    \hfill
    \subcaptionbox{Constraint maintainers\label{fig:constraint-maintainer-architecture}}
        {
        \begin{tikzpicture}
            \prettylensarchitectureoverview
            \draw
                (A.east) +(0,-0.1)
                    .. controls (B.west) and (B'.west) ..
                (near A'.center);
            \draw
                (B'.west) +(0,0.1)
                    .. controls (A'.east) and (A.east) ..
                (near B.center);
            \draw[->,dashed] (B)  to (B');
            \draw[->,dashed] (A') to (A);
        \end{tikzpicture}
        }
    \caption{Asymmetric lens life cycle, and some proposed symmetric
    variants}
    \label{fig:asymmetry-vs-symmetry}
\end{figure}

Let us address ourselves to what makes asymmetric lenses asymmetric in the
first place. Figure~\ref{fig:asymmetric-architecture} shows the typical
life-cycle of an asymmetric lens $\ell \in S \alens T$. Drawing the types of
the \GET and \PUT operations this way highlights their asymmetry, and
quickly suggests two ways of symmetrizing the theory. Parts
\subref{fig:isomorphism-architecture} and
\subref{fig:constraint-maintainer-architecture} illustrate these two ways,
namely, removing the extra arc in the type of \PUT, or adding an extra arc
to the type of \GET. Together with some appropriate roundtrip laws, the
% TODO: Perhaps ask Benjamin for the Braun citation mentioned in the
% delta/presentation.tex, and ask for other likely citations to put here
former are known as isomorphisms, and several languages whose terms
represent invertible functions in this way have been
designed~\cite{xsugar,rendel2010invertible}. They are especially useful as a
formalism when the extra information available in the repositories is
unimportant; for example, when parsing text, the exact whitespace used may
not be available in the abstract syntax tree, but can often be replaced with
different whitespace without causing too much pain. In the example given
above, however, the extra information \emph{is} important, and cannot be
replaced with default data without pain: resetting room assignments and
salaries on each roundtrip would be very undesirable behavior.

The latter (again with some appropriate roundtrip laws) are known as
constraint maintainers~\cite{Meertens98}, and do handle extra information
quite explicitly. Constraint maintainers would be a good formalism to use
when designing a bidirectional transformation for the school scenario above.
They can express the connection between salaries and room numbers---that is,
no connection at all---well, and support a \map-like combinator to turn this
single-record maintainer into one which handles whole lists as are stored in
the repositories.

Constraint maintainers are not quite as natural a fit for the image server
scenario described above. One modular approach to implementing the
transformation needed in that scenario is pictured in
Figure~\ref{fig:cats-composition}. First, we separately implement two
constraint maintainers: a $\mathit{flatten}$ maintainer that flattens trees
to lists by extracting the leaves, and a $\mathit{relabel}$ maintainer that
describes the connection between a single leaf in our original tree and a
single list entry in our final list. We would then like to run these
maintainers back-to-back; that is, we would like a sequential composition
operator $-;-$ with a typing rule like
\infrule{k \in A \cmaint B \qquad \ell \in B \cmaint C}{k;\ell \in A \cmaint C}
where $A \cmaint B$ is the type of a constraint maintainer connecting sets
of type $A$ and $B$. Unfortunately, implementing this combinator is not
possible: we must design $(k;\ell).\aget \in A \times C \to C$ using the
components $k.\aget$, $k.\aput$, $\ell.\aget$, and $\ell.\aput$, all of
which require a $B$ as input. It is certainly possible to build a constraint
maintainer which has the desired behavior wholesale, but this involves
writing both constraint maintenance functions and proving that they are
consistent with each other -- the exact task we set out to avoid by
designing a language. Alternately, one can step a little bit outside the
constraint maintainer framework by keeping a copy of the ``intermediate''
repository around somewhere and running the constraint maintainers in
sequence on each update. Making this choice, however, leads one to
immediately ask how to model such maintainer chains and what behavioral
guarantees one can expect!

\begin{figure}
    \begin{diagram}
        \draw[short picture tree]
            node (root) {} child {
                node (Jan) {Jan}
                    \lolcatchildren{pumpkin,skateboard}
            } child {
                node (May) {May}
                    \lolcatchildren{pineapple}
            }
            ;
        \begin{scope}[start chain=going below,node distance=0]
            \foreach \name in {pumpkin,skateboard,pineapple} { \draw
                (root.north -| pineapple-fs-pic) +(3,0)
                node[on chain,anchor=north]    (\name-inter-pic)  {\lolcat{\name}}
                node[right=of \name-inter-pic] (\name-inter-name) {\tiny \name.jpg}
                ;
            }
        \end{scope}
        \lolcattags{(pumpkin-inter-pic.north -| pumpkin-inter-name.east) +(2,0)}
            {pumpkin/{costume,food},skateboard/{anthro},pineapple/{food}}
        \node[draw,rounded corners,fit=(root)
                (pumpkin-fs-name)    (pumpkin-fs-pic)
             (skateboard-fs-name) (skateboard-fs-pic)
              (pineapple-fs-name)  (pineapple-fs-pic)
             ] (fs) {};
        \node[draw,rounded corners,fit=
                (pumpkin-inter-pic)    (pumpkin-inter-name)
             (skateboard-inter-pic) (skateboard-inter-name)
              (pineapple-inter-pic)  (pineapple-inter-name)
             ] (inter) {};
        \node[draw,rounded corners,fit=
                (pumpkin-web-pic)    (pumpkin-web-tag)
             (skateboard-web-pic) (skateboard-web-tag)
              (pineapple-web-pic)  (pineapple-web-tag)
             ] (web) {};
        \draw[<->] ($(fs.south)+(0,-0.1)$)
            to[bend right] node[below] {$\mathit{flatten}$}
            ($(inter.south)+(-0.5,-0.1)$);
        \draw[<->] ($(inter.south)+(0.5,-0.1)$)
            to[bend right] node[below] {$\map(\mathit{relabel})$}
            ($(web.south)+(0,-0.1)$);
    \end{diagram}
    \caption{Adding an intermediate structure can improve modularity}
    \label{fig:cats-composition}
\end{figure}

So an ideal a model would capture the behavior of ``sequencing'', retain a
symmetric presentation, and allow each repository to retain information not
available in the other.

\section{Size}
\label{sec:intro-size}

There is a third consideration that real-world synchronization tools
inevitably address, and that is in communication costs. When the
repositories in question reside on separate computers, transferring even a
small copy of a repository across the network to the other computer can
take quite a noticeable amount of time. Mitigating this effect typically
involves using a compression scheme; empirically, one of the most effective
ones involves noting ``what has changed'' since previous incarnations of the
synchronization tool. For example, file system synchronizers like rsync,
DropBox, and Unison and revision control systems like CVS, SVN, darcs,
mercurial, and git all have some such notion internally. It seems likely
% TODO: citations for each of these tools
that a practical tool based on whatever theory we develop will need to use
similar tricks; so, for the theory to faithfully model such a tool, it
must model not just repository states but also repository edits and how they
affect the states.

\section{Contributions}
\label{sec:intro-contributions}
\begin{itemize}
    \item We have made some valuable progress on each of these issues
        \begin{itemize}
            \item alignment: showed specific examples of lenses that
                disambiguate some especially confusing repository
                modifications
            \item give a natural way of factoring out the descriptions of
                extra global information -- treat it completely generically
                and see where that takes us
            \item symmetry: showed how to design a lens framework that
                supports composition and symmetry
            \item size: designed a series of lenses where the computations
                operate on small edits, rather than the large repository
        \end{itemize}
    \item We implemented xxx, which demonstrates yyy
    \item Hint at the fact that there is more to be done if you want to
        operate on multiple repositories simultaneously
\end{itemize}
