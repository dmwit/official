\begin{itemize}
    \item Bidirectional programming is advantageous because it is concise
        (one iteration only) and has proven synchronization laws
\end{itemize}
% TODO: introduce jargon like ``repository'' and friends in here

\section{Asymmetric Lenses}
\label{sec:asymmetric-lenses}
\begin{itemize}
    \item Asymmetric Lenses
        \begin{itemize}
            \item Define what an asymmetric lens is and how its used
            \item This was the initial approach to lenses
            \item Asymmetric lenses needed to mature to add functionality
        \end{itemize}
    \item The extra functionality should address practical issues arising
        from the synchronization of the repositories
        \begin{itemize}
            \item alignment: there may be many ways to produce a
                synchronized pair, and we must give tools for disambiguating
                \begin{itemize}
                    \item to do a good job, a lens needs information about
                        what happened that's hard to recover locally
                    \item structural matching clearly does a bad job -- and
                        the naive asymmetric model can only make local
                        decisions, none of which are going to be good enough
                    \item producing descriptions of the global information
                        itself is messy, and you want that factored out --
                        you want a theory of how global information is
                        processed without worrying about it's produced
                \end{itemize}
            \item symmetry: there may be no canonical repository that
                contains all the data
            \item size: sometimes repositories are too large to facilitate
                functional computations or to transmit
        \end{itemize}
\end{itemize}

One well-studied approach to bidirectional programming, summarized in
Figure~\ref{fig:asymmetric-lens-def}, is the framework of \emph{asymmetric},
\emph{state-based} lenses. In this model, one of the two repositories is a
% TODO: definitely, definitely need some citations
\emph{view} of or \emph{query} on the other: that is, it can be completely
reconstructed from the other without additional outside information in case
it is lost. The \GET component of a lens (together with the \rn{PutGet} law
which we discuss below) reflects this assumption. In the figure, we use the
convention that $S$ is the set of values that can be in the source
repository, and $V$ is the set of values that can be in the view repository;
likewise $s$ is a particular source and $v$ a particular view.
In most cases, a query will keep only some of the information available in
the source; as a result, the opposite reconstruction property---that the
source can be completely reconstructed from the view---usually does not
hold. Asymmetric, state-based lenses handle this situation by allowing their
other major function component to have access to both a modified value from
the view repository \emph{and} an original value from the source repository
to merge the new data into, as reflected in the type of \PUT.
As a technical detail, it is convenient to demand a way to generate a value
in the source repository with some sane defaults (and not difficult to
satisfy this demand in practice). This is the \CREATE component of
Figure~\ref{fig:asymmetric-lens-def}.
\begin{figure}
    \begin{minipage}{0.3333333\linewidth}
        \begin{align*}
            \aget &\in S \to V \\
            \aput &\in V \times S \to S \\
            \acreate &\in V \to S
        \end{align*}
    \end{minipage}
    \begin{minipage}{0.6666666\linewidth}
        \begin{align*}
            \aput(\aget(s),s) &= s  & \rn{GetPut} \\
            \aget(\aput(v,s)) &= v  & \rn{PutGet} \\
            \aget(\acreate(v)) &= v & \rn{CreateGet}
        \end{align*}
    \end{minipage}
    \caption{The required components and behavioral guarantees of a lens in
    $S \alens V$}
    \label{fig:asymmetric-lens-def}
\end{figure}

\section{Contributions}
\label{sec:contributions}
\begin{itemize}
    \item We have made some valuable progress on each of these issues
        \begin{itemize}
            \item alignment: showed specific examples of lenses that
                disambiguate some especially confusing repository
                modifications
            \item give a natural way of factoring out the descriptions of
                extra global information -- treat it completely generically
                and see where that takes us
            \item symmetry: showed how to design a lens framework that
                supports composition and symmetry
            \item size: designed a series of lenses where the computations
                operate on small edits, rather than the large repository
        \end{itemize}
    \item We implemented xxx, which demonstrates yyy
    \item Hint at the fact that there is more to be done if you want to
        operate on multiple repositories simultaneously
\end{itemize}
\section{Alignment}
One very common operation when doing functional (unidirectional) programming
is the \map operation\footnote{As of April 3, 2012, there were 3878 packages
% TODO: add a citation for Hackage (!)
on Hackage, the central code repository for Haskell projects, which made a
total of 90,040 calls to \map---an average of more than twenty calls per
project. In fact, the program used to calculate these numbers itself makes
two calls to \map:

\noindent\texttt{ack -cl '\textbackslash bmap\textbackslash b' | cut -d: -f2 |}

\noindent\texttt{ghc -e 'interact \$ unlines . map show . scanl (+) 0 . map read . lines'}
}, which runs a computation on each element of a list. Most serious attempts
at designing a bidirectional language therefore provide some variant of a
mapping operation. Since it is such a popular operation, it is important to
do a really good job of designing the bidirectional \map, and that job turns
out to be surprisingly difficult! The most obvious way of implementing the
\map operation is developed below as a way to ground the discussion of what
makes this so difficult.

Like the unidirectional \map, which is parameterized by a unidirectional
function to apply to list elements, our bidirectional \map will be
parameterized by a bidirectional operation. That is, when $\ell \in X \alens
Y$, we will have $\map(\ell) \in X^* \alens Y^*$ where $X^*$ is the type of
lists whose elements are drawn from $X$. In the following, we will use the
notation $\NIL$ for the empty list; $x \CONS t$ for the list whose first
element is $x$ and whose remaining elements are $t$; and
$\left<x_1,\ldots,x_n\right>$ for the list whose elements are exactly $x_1$
through $x_n$ in order.

\begin{figure}
    \begin{align*}
        \mapU(f,t) &= \cond{
            \NIL & t = \NIL \\
            f(x) \CONS \mapU(f,t') & t = x \CONS t'
        } \\
        \zip(f,g,h,t,u) &= \cond{
            f(x,y) \CONS \zip(f,g,h,t',u') & t = x:t' \land u = y:u' \\
            g(t) & t = x:t' \land u = \NIL \\
            h(u) & t = \NIL \land u = y:u' \\
            \NIL & t = u = \NIL
        } \\
        \constU(x) &= \lambda y.\;x
    \end{align*}
    \caption{Auxiliary unidirectional functions used in the definition of \map}
    \label{fig:uni-map-zip-const}
\end{figure}
\begin{figure}
    \begin{align*}
        \map(\ell).\aget(t) &= \mapU(\ell.\aget,t) \\
        \map(\ell).\acreate(u) &= \mapU(\ell.\acreate,u) \\
        \map(\ell).\aput(t,u) &=
            \zip(\ell.\aput,\mapU(\ell.\acreate),\constU(\NIL),t,u)
    \end{align*}
    \caption{A naive implementation of the bidirectional \map operation}
    \label{fig:naive-asymmetric-map}
\end{figure}
Figures~\ref{fig:uni-map-zip-const} and~\ref{fig:naive-asymmetric-map}
define the \map lens. In these figures, and in the remainder of the text, we
distinguish the unidirectional mapping operation \mapU from the
bidirectional one \map.  The \GET and \CREATE operations are fairly
straightforward -- direct analogues of the unidirectional version -- but the
\PUT operation is more delicate. Recall that \PUT takes one value from each
repository, so again in the case where $\ell \in X \alens Y$, we will have
$\map(\ell).\aput$ taking two lists, one each of types $X^*$ and $Y^*$.
When these lists are the same length we can just ``zip'' them together with
$\ell.\aput$. When they are different lengths, we can zip together as much
as we can (up to the shorter of the two lengths), then either treat the
remainder as deletions (if the $X^*$ list is longer) and so do nothing, or
treat the remainder as insertions (if the $Y^*$ list is longer) and so use
$\ell$'s \CREATE method.

\begin{figure}
    \begin{align*}
        \tolower.\aget(c) &= \mbox{the lower case version of $c$} \\
        \tolower.\aput(c',c) &= \cond{
            \mbox{the upper case version of $c'$} & \mathtt{A} < c < \mathtt{Z} \\
            c' & \mbox{otherwise}
        } \\
        \tolower.\acreate(c) &= c
    \end{align*}
    \caption{The \tolower lens to convert a possibly-upper-case letter into
    a definitely-lower-case one}
    \label{fig:tolower-lens}
\end{figure}
For example, if we define a lens \tolower that converts a character to lower
case as in Figure~\ref{fig:tolower-lens}, then we can execute the
$\map(\tolower)$ lens a few times to see how it behaves:
\begin{align*}
    \map(\tolower).\aget(\mathtt{camelCasedQord})
        &= \mathtt{camelcasedqord} \\
    \map(\tolower).\aput(\mathtt{camelcasedword},\mathtt{camelCasedQord})
        &= \mathtt{camelCasedWord} \\
    \map(\tolower).\aput(\mathtt{camelcased},\mathtt{camelCasedWord})
        &= \mathtt{camelCased} \\
    \map(\tolower).\aput(\mathtt{camelcasedsentence},\mathtt{camelCasedWord})
        &= \mathtt{camelCasedSentence}
\end{align*}
All of these examples behave essentially optimally. However, not all is
well; a simple example of the so-called \emph{alignment problem} is
something like this, where we have an insertion in the middle of the word to
correct the spelling of ``camel'':
\[\map(\tolower).\aput(\mathtt{camelcasedword},\mathtt{camlCasedWord})
    = \mathtt{cameLcaseDword}\]
Because our \map's \PUT operation only looks at a lower-cased element's
position when deciding which mixed-case character to match it up with, we
have incorrectly \emph{aligned} the new view with the old source this way:

\begin{tikzpicture}[
    start chain=source,
    start chain=view,
    node distance=0,
    text depth=0.25ex, text height=1.5ex,
    every node/.style={font=\ttfamily}]
    \foreach \c in {c,a,m,l,C,a,s,e,d,W,o,r,d}
        {\node[on chain=source]{\c};}
    \node[on chain=view,below=5ex of source-1] {c};
    \foreach \c in {a,m,e,l,c,a,s,e,d,w,o,r,d}
        {\node[on chain=view]{\c};}
    \foreach \n in {1,...,13}
        {\draw (source-\n) -- (view-\n);}
\end{tikzpicture}

\noindent A better alignment would look like this:

\begin{tikzpicture}[
    start chain=source,
    start chain=view,
    node distance=0,
    text depth=0.25ex, text height=1.5ex,
    every node/.style={font=\ttfamily}]
    \foreach \c in {c,a,m,l,C,a,s,e,d,W,o,r,d}
        {\node[on chain=source]{\c};}
    \node[on chain=view,below=5ex of source-1] {c};
    \foreach \c in {a,m,e,l,c,a,s,e,d,w,o,r,d}
        {\node[on chain=view]{\c};}
    \foreach \s/\v in {1/1,2/2,3/3,4/4,5/6,6/7,7/8,8/9,9/10,10/11,11/12,12/13,13/14}
        {\draw (source-\s) -- (view-\v);}
\end{tikzpicture}

\noindent The alignment problem is about how to discover, propagate, and use
alignments that reflect the user's intention well.

\subsection{Getting a Good Alignment is Important}
Here's a subsection you might want to write: perhaps it is worth writing an
argument that concludes in a generic way that if we get the alignment wrong,
then we can definitely write a lens that behaves in an obviously bad way.
The advantage of such a section would be that it would mean that later
discussions could assume that showing a bad alignment is enough -- they
wouldn't have to go on to show how that bad alignment could manifest itself
as a bad update. (In fact, this sounds like such a convenient assumption
that I'm going to make it now even if I haven't figured out how to argue it
yet. Later, if I find out it's very very difficult to argue, then I will try
to go through and show how particular bad alignments can manifest a problem
instead.)

\subsection{``Just Use a Hashmap''}
One of the hard lenses to write is map.
The second-most-obvious way to write map involves letting some part of each
element be a key, and some part be a value.
Maybe something like the following would be a good example showing how to
confuse that implementation strategy.

(The explanation here is very telegraphic, intentionally. It needs to be
expanded considerably for anyone but me to understand it, I'm sure.)

\begin{verbatim}
data RoomAssignment =
    { room :: Int
    , teacher :: Person
    , students :: [Person]
    }
\end{verbatim}

The administrator may find he needs to swap two rooms (e.g. because one room
is bigger and would better accommodate some teacher's particularly large
class), swap two teachers (can't think of a good reason off the top of my
head other than ``correcting an administrative error made in the past''),
move a student from one class to another (e.g. because she decided to switch
from Spanish to French), etc.

What should we use as the key? Some obvious choices don't work well:
\begin{enumerate}
    \item room and teacher: seems like a natural choice, but then moving a
        class from one room to another or having a different teacher teach
        results in the student lists not being aligned
    \item just room: then if you swap rooms, the wrong student lists get aligned
        with each other
    \item just teacher: then if you swap teachers, the wrong student lists get
        aligned with each other
    \item students: student lists just don't even get aligned any more; e.g.
        after moving a student from one class to another we find neither
        class is correctly aligned
\end{enumerate}

Also, ``just use a hashmap'' assumes that keys are unique and never change.
Changing keys can be accommodated sometimes (e.g. the matching lenses
paper), but there's plenty of situations where the uniqueness assumption
hurts. With people, ``name'' as a key is a natural first guess but doomed to
failure.

\subsection{Ambiguity}
Maybe somebody still believes it's possible to design a clever enough
algorithm -- e.g. as a follow-on to having solved hard AI! Then it would be
good to have a really convincing example of the claim we always make to help
motivate edit lenses: that sometimes there are simply \emph{multiple}
reasonable intentions that all have the same effect on the state and that
result in different alignments.

Perhaps something so simple as this: continuing the previous example, in one
school district, ``Mary Jones'' gets married and changes her name to ``Mary
Smith''. In another, ``Mary Jones'' retires and a replacement named ``Mary
Smith'' is hired. Can we really expect an automated tool to be able to
distinguish these situations just by looking at what has changed alone?

Possible reasons this argument is unconvincing: this is probably very rare,
and covering the common case is more important than covering every case;
this same problem occurs even with edit lenses, but has been punted off to
some other sucker's plate; perhaps even in a tool that handles this problem
it is hard to communicate these subtleties to the user in a way that works
(i.e. is concise enough to expect them to inspect it on each synch but
verbose enough to show problems when they arise).

Not sure how to address these three complaints, to be honest.
