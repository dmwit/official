\begin{itemize}
    \item Bidirectional programming is advantageous because it is concise
        (one iteration only) and has proven synchronization laws
\end{itemize}
% TODO: introduce jargon like ``repository'' and friends in here

\section{Asymmetric Lenses}
\label{sec:asymmetric-lenses}
\begin{itemize}
    \item Asymmetric Lenses
        \begin{itemize}
            \item Define what an asymmetric lens is and how its used
            \item This was the initial approach to lenses
            \item Asymmetric lenses needed to mature to add functionality
        \end{itemize}
    \item The extra functionality should address practical issues arising
        from the synchronization of the repositories
        \begin{itemize}
            \item alignment: there may be many ways to produce a
                synchronized pair, and we must give tools for disambiguating
                \begin{itemize}
                    \item to do a good job, a lens needs information about
                        what happened that's hard to recover locally
                    \item structural matching clearly does a bad job -- and
                        the naive asymmetric model can only make local
                        decisions, none of which are going to be good enough
                    \item producing descriptions of the global information
                        itself is messy, and you want that factored out --
                        you want a theory of how global information is
                        processed without worrying about it's produced
                \end{itemize}
            \item symmetry: there may be no canonical repository that
                contains all the data
            \item size: sometimes repositories are too large to facilitate
                functional computations or to transmit
        \end{itemize}
\end{itemize}

One well-studied approach to bidirectional programming, summarized in
Figure~\ref{fig:asymmetric-lens-def}, is the framework of \emph{asymmetric},
\emph{state-based} lenses. In this model, one of the two repositories is a
% TODO: definitely, definitely need some citations
\emph{view} of or \emph{query} on the other: that is, it can be completely
reconstructed from the other without additional outside information in case
it is lost. The \GET component of a lens (together with the \rn{PutGet} law
which we discuss below) reflects this assumption. In the figure, we use the
convention that $S$ is the set of values that can be in the source
repository, and $V$ is the set of values that can be in the view repository;
likewise $s$ is a particular source and $v$ a particular view.
In most cases, a query will keep only some of the information available in
the source; as a result, the opposite reconstruction property---that the
source can be completely reconstructed from the view---usually does not
hold. Asymmetric, state-based lenses handle this situation by allowing their
other major function component to have access to both a modified value from
the view repository \emph{and} an original value from the source repository
to merge the new data into, as reflected in the type of \PUT.
As a technical detail, it is convenient to demand a way to generate a value
in the source repository with some sane defaults (and not difficult to
satisfy this demand in practice). This is the \CREATE component of
Figure~\ref{fig:asymmetric-lens-def}.
\begin{figure}
    \begin{minipage}{0.3333333\linewidth}
        \begin{align*}
            \aget &\in S \to V \\
            \aput &\in V \times S \to S \\
            \acreate &\in V \to S
        \end{align*}
    \end{minipage}
    \begin{minipage}{0.6666666\linewidth}
        \begin{align*}
            \aput(\aget(s),s) &= s  & \rn{GetPut} \\
            \aget(\aput(v,s)) &= v  & \rn{PutGet} \\
            \aget(\acreate(v)) &= v & \rn{CreateGet}
        \end{align*}
    \end{minipage}
    \caption{The required components and behavioral guarantees of a lens in
    $S \alens V$}
    \label{fig:asymmetric-lens-def}
\end{figure}

\section{Contributions}
\label{sec:contributions}
\begin{itemize}
    \item We have made some valuable progress on each of these issues
        \begin{itemize}
            \item alignment: showed specific examples of lenses that
                disambiguate some especially confusing repository
                modifications
            \item give a natural way of factoring out the descriptions of
                extra global information -- treat it completely generically
                and see where that takes us
            \item symmetry: showed how to design a lens framework that
                supports composition and symmetry
            \item size: designed a series of lenses where the computations
                operate on small edits, rather than the large repository
        \end{itemize}
    \item We implemented xxx, which demonstrates yyy
    \item Hint at the fact that there is more to be done if you want to
        operate on multiple repositories simultaneously
\end{itemize}
\section{Some Rambling About Alignment}
Below, I'm trying to develop a sort of ``garden path'' that starts with
people having no idea what alignment is about and ends with them believing
that it is an important problem to solve and that it is fundamental and
tricky. But I don't have a good idea about how this will go yet, so for now
it's just some notes to myself about things that might be good to talk
about.

Subsections in no particular order yet.

\subsection{Getting a Good Alignment is Important}
Here's a subsection you might want to write: perhaps it is worth writing an
argument that concludes in a generic way that if we get the alignment wrong,
then we can definitely write a lens that behaves in an obviously bad way.
The advantage of such a section would be that it would mean that later
discussions could assume that showing a bad alignment is enough -- they
wouldn't have to go on to show how that bad alignment could manifest itself
as a bad update. (In fact, this sounds like such a convenient assumption
that I'm going to make it now even if I haven't figured out how to argue it
yet. Later, if I find out it's very very difficult to argue, then I will try
to go through and show how particular bad alignments can manifest a problem
instead.)

\subsection{``Just Use a Hashmap''}
One of the hard lenses to write is map.
The second-most-obvious way to write map involves letting some part of each
element be a key, and some part be a value.
Maybe something like the following would be a good example showing how to
confuse that implementation strategy.

(The explanation here is very telegraphic, intentionally. It needs to be
expanded considerably for anyone but me to understand it, I'm sure.)

\begin{verbatim}
data RoomAssignment =
    { room :: Int
    , teacher :: Person
    , students :: [Person]
    }
\end{verbatim}

The administrator may find he needs to swap two rooms (e.g. because one room
is bigger and would better accommodate some teacher's particularly large
class), swap two teachers (can't think of a good reason off the top of my
head other than ``correcting an administrative error made in the past''),
move a student from one class to another (e.g. because she decided to switch
from Spanish to French), etc.

What should we use as the key? Some obvious choices don't work well:
\begin{enumerate}
    \item room and teacher: seems like a natural choice, but then moving a
        class from one room to another or having a different teacher teach
        results in the student lists not being aligned
    \item just room: then if you swap rooms, the wrong student lists get aligned
        with each other
    \item just teacher: then if you swap teachers, the wrong student lists get
        aligned with each other
    \item students: student lists just don't even get aligned any more; e.g.
        after moving a student from one class to another we find neither
        class is correctly aligned
\end{enumerate}

Also, ``just use a hashmap'' assumes that keys are unique and never change.
Changing keys can be accommodated sometimes (e.g. the matching lenses
paper), but there's plenty of situations where the uniqueness assumption
hurts. With people, ``name'' as a key is a natural first guess but doomed to
failure.

\subsection{Locality}
If it's possible/worthwhile to argue it, the argument would be that if map
makes its own local decision and then forces the sublens to make \emph{its}
own local decisions, that this can result in something worse than what
happens when there's some global analysis that's knowledgeable about both
levels of alignment which hands information about its global decision to
each lens.

Is it possible to argue the local vs. global thing? Is it useful to argue
the local vs. global thing?

\subsection{Ambiguity}
Maybe somebody still believes it's possible to design a clever enough
algorithm -- e.g. as a follow-on to having solved hard AI! Then it would be
good to have a really convincing example of the claim we always make to help
motivate edit lenses: that sometimes there are simply \emph{multiple}
reasonable intentions that all have the same effect on the state and that
result in different alignments.

Perhaps something so simple as this: continuing the previous example, in one
school district, ``Mary Jones'' gets married and changes her name to ``Mary
Smith''. In another, ``Mary Jones'' retires and a replacement named ``Mary
Smith'' is hired. Can we really expect an automated tool to be able to
distinguish these situations just by looking at what has changed alone?

Possible reasons this argument is unconvincing: this is probably very rare,
and covering the common case is more important than covering every case;
this same problem occurs even with edit lenses, but has been punted off to
some other sucker's plate; perhaps even in a tool that handles this problem
it is hard to communicate these subtleties to the user in a way that works
(i.e. is concise enough to expect them to inspect it on each synch but
verbose enough to show problems when they arise).

Not sure how to address these three complaints, to be honest.
