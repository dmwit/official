TODO: bidirectional programming is advantageous because it is concise (one
iteration only) and has proven synchronization laws
% TODO: introduce jargon like ``repository'' and friends in here

\section{Asymmetric Lenses}
\label{sec:asymmetric-lenses}
\begin{itemize}
    \item Asymmetric Lenses
        \begin{itemize}
            \item Define what an asymmetric lens is and how its used
            \item This was the initial approach to lenses
            \item Asymmetric lenses needed to mature to add functionality
        \end{itemize}
\end{itemize}

One well-studied approach to bidirectional programming, summarized in
Figure~\ref{fig:asymmetric-lens-def}, is the framework of \emph{asymmetric},
\emph{state-based} lenses. In this model, one of the two repositories is a
% TODO: definitely, definitely need some citations
\emph{view} of or \emph{query} on the other: that is, it can be completely
reconstructed from the other without additional outside information in case
it is lost. The \GET component of a lens (together with the \rn{PutGet} law
which we discuss below) reflects this assumption. In the figure, we use the
convention that $S$ is the set of values that can be in the source
repository, and $V$ is the set of values that can be in the view repository;
likewise $s$ is a particular source and $v$ a particular view.
In most cases, a query will keep only some of the information available in
the source; as a result, the opposite reconstruction property---that the
source can be completely reconstructed from the view---usually does not
hold. Asymmetric, state-based lenses handle this situation by allowing their
other major function component to have access to both a modified value from
the view repository \emph{and} an original value from the source repository
to merge the new data into, as reflected in the type of \PUT. As a technical
detail, it is sometimes convenient to demand (and rarely difficult to
supply) a way to generate a value in the source repository with some sane
defaults.  This is the \CREATE component of
Figure~\ref{fig:asymmetric-lens-def}.
\begin{figure}
    \begin{minipage}{0.3333333\linewidth}
        \begin{align*}
            \aget &\in S \to V \\
            \aput &\in V \times S \to S \\
            \acreate &\in V \to S
        \end{align*}
    \end{minipage}
    \begin{minipage}{0.6666666\linewidth}
        \begin{align*}
            \aput(\aget(s),s) &= s  & \rn{GetPut} \\
            \aget(\aput(v,s)) &= v  & \rn{PutGet} \\
            \aget(\acreate(v)) &= v & \rn{CreateGet}
        \end{align*}
    \end{minipage}
    \caption{The required components and behavioral guarantees of a lens in
    $S \alens V$}
    \label{fig:asymmetric-lens-def}
\end{figure}

\section{Alignment}
One very common operation when doing functional (unidirectional) programming
is the \map operation\footnote{As of April 3, 2012, there were 3878 packages
on Hackage~\cite{Hackage2012}, the central code repository for Haskell
projects, which made a total of 90,040 calls to \map---an average of more
than twenty calls per project. In fact, the program used to calculate these
numbers itself makes two calls to \map:

\noindent\texttt{ack -cl '\textbackslash bmap\textbackslash b' | cut -d: -f2 |}

\noindent\texttt{ghc -e 'interact \$ unlines . map show . scanl (+) 0 . map read . lines'}
}, which runs a computation on each element of a list. Most serious attempts
at designing a bidirectional language therefore provide some variant of a
mapping operation. Since it is such a popular operation, it is important to
do a really good job of designing the bidirectional \map, and that job turns
out to be surprisingly difficult! To see why, let us implement \map in the
most obvious way; then we can discuss the deficiencies of this approach.

% TODO: add a subsection discussing all the notation in the whole
% dissertation? (including the whole ``record syntax'' thing)
Like the unidirectional \map, which is parameterized by a unidirectional
function to apply to list elements, our bidirectional \map will be
parameterized by a bidirectional operation. That is, when $\ell \in X \alens
Y$, we will have $\map(\ell) \in X^* \alens Y^*$ where $X^*$ is the type of
lists whose elements are drawn from $X$. In the following, we will use the
notation $\NIL$ for the empty list; $x \CONS t$ for the list whose first
element is $x$ and whose remaining elements are $t$; and
$\left<x_1,\ldots,x_n\right>$ for the list whose elements are exactly $x_1$
through $x_n$ in order.

\begin{figure}
    \begin{align*}
        \mapU(f,t) &= \cond{
            \NIL & t = \NIL \\
            f(x) \CONS \mapU(f,t') & t = x \CONS t'
        } \\
        \zip(f,g,h,t,u) &= \cond{
            f(x,y) \CONS \zip(f,g,h,t',u') & t = x:t' \land u = y:u' \\
            g(t) & t = x:t' \land u = \NIL \\
            h(u) & t = \NIL \land u = y:u' \\
            \NIL & t = u = \NIL
        } \\
        \constU(x) &= \lambda y.\;x
    \end{align*}
    \caption{Auxiliary unidirectional functions used in the definition of \map}
    \label{fig:uni-map-zip-const}
\end{figure}
\begin{figure}
    \begin{align*}
        \map(\ell).\aget(t) &= \mapU(\ell.\aget,t) \\
        \map(\ell).\acreate(u) &= \mapU(\ell.\acreate,u) \\
        \map(\ell).\aput(t,u) &=
            \zip(\ell.\aput,\mapU(\ell.\acreate),\constU(\NIL),t,u)
    \end{align*}
    \caption{A naive implementation of the bidirectional \map operation}
    \label{fig:naive-asymmetric-map}
\end{figure}
Figures~\ref{fig:uni-map-zip-const} and~\ref{fig:naive-asymmetric-map}
define the \map lens. In these figures, and in the remainder of the text, we
distinguish the unidirectional mapping operation \mapU from the
bidirectional \map.  The \GET and \CREATE operations are fairly
straightforward---direct analogues of the unidirectional version---but the
\PUT operation is more delicate. Recall that \PUT takes one value from each
repository, so again in the case where $\ell \in X \alens Y$, we will have
$\map(\ell).\aput$ taking two lists, one each of types $X^*$ and $Y^*$.
When these lists are the same length we can just ``zip'' them together with
$\ell.\aput$. When they are different lengths, we can zip together as much
as we can (up to the shorter of the two lengths), then either treat the
remainder as deletions (if the $X^*$ list is longer) and so do nothing, or
treat the remainder as insertions (if the $Y^*$ list is longer) and so use
$\ell$'s \CREATE method.

\begin{figure}
    \begin{align*}
        \tolower.\aget(c) &= \mbox{the lower case version of $c$} \\
        \tolower.\aput(c',c) &= \cond{
            \mbox{the upper case version of $c'$} & \mathtt{A} < c < \mathtt{Z} \\
            c' & \mbox{otherwise}
        } \\
        \tolower.\acreate(c) &= c
    \end{align*}
    \caption{The \tolower lens to convert a possibly-upper-case letter into
    a definitely-lower-case one}
    \label{fig:tolower-lens}
\end{figure}
Figure~\ref{fig:tolower-lens} defines a lens \tolower that converts a
character to lower case so that we can demonstrate the behavior of \map.
\begin{align*}
    \map(\tolower).\aget(\mathtt{UpperCasedQord})
        &= \mathtt{uppercasedqord} \\
    \map(\tolower).\aput(\mathtt{uppercasedword},\mathtt{UpperCasedQord})
        &= \mathtt{UpperCasedWord} \\
    \map(\tolower).\aput(\mathtt{uppercased},\mathtt{UpperCasedWord})
        &= \mathtt{UpperCased} \\
    \map(\tolower).\aput(\mathtt{uppercasedsentence},\mathtt{UpperCasedWord})
        &= \mathtt{UpperCasedSentence}
\end{align*}
All of these examples behave essentially optimally. However, not all is
well; a simple example of the so-called \emph{alignment problem} is
something like this, where we have an insertion in the middle of the word to
correct the spelling of ``upper'':
\[\map(\tolower).\aput(\mathtt{uppercasedword},\mathtt{UperCasedWord})
    = \mathtt{uppeRcaseDword}\]
Because $\map(\tolower).\aput$ only looks at a lower-cased element's
position when deciding which mixed-case character to match it up with, we
have incorrectly \emph{aligned} the new view with the old source this way:

\begin{diagram}[alignment diagram]
    \foreach \c in {U,p,e,r,C,a,s,e,d,W,o,r,d}
        {\node[on chain=source]{\c};}
    \node[on chain=view,below=5ex of source-1] {u};
    \foreach \c in {p,p,e,r,c,a,s,e,d,w,o,r,d}
        {\node[on chain=view]{\c};}
    \foreach \n in {1,...,13}
        {\draw (source-\n) -- (view-\n);}
\end{diagram}

\noindent A better alignment would look like this:

\begin{diagram}[alignment diagram]
    \foreach \c in {U,p,e,r,C,a,s,e,d,W,o,r,d}
        {\node[on chain=source]{\c};}
    \node[on chain=view,below=5ex of source-1] {u};
    \foreach \c in {p,p,e,r,c,a,s,e,d,w,o,r,d}
        {\node[on chain=view]{\c};}
    \foreach \n in {1,2}
        {\draw (source-\n) -- (view-\n);}
    \foreach \s in {3,...,13}
        {\pgfmathtruncatemacro\v{\s+1}\draw (source-\s) -- (view-\v);}
\end{diagram}

One natural reaction to this infelicity is to think of the \texttt{diff}
algorithm~\cite{hunt1976algorithm} or something similar. This idea has been
developed quite far~\cite{MatchingLenses09}; let us see how. At first blush,
it seems difficult to use the \texttt{diff} algorithm directly. Elements of
the source and view have different types, so it is not clear how to compare
them\footnote{In this case, the types are close enough that we could
probably fudge it, but in general there may be very different kinds of
objects in the source and view.}. However, the alignment diagram above may
be broken into two stages:

\begin{diagram}[alignment diagram]
    \foreach \c in {U,p,e,r,C,a,s,e,d,W,o,r,d}
        {\node[on chain=source]{\c};}
    \node[on chain=intermediate,below=5ex of source-1] {u};
    \foreach \c in {p,e,r,c,a,s,e,d,w,o,r,d}
        {\node[on chain=intermediate]{\c};}
    \node[on chain=view,below=5ex of intermediate-1] {u};
    \foreach \c in {p,p,e,r,c,a,s,e,d,w,o,r,d}
        {\node[on chain=view]{\c};}
    \foreach \n in {1,...,13}
        {\draw (source-\n) -- (intermediate-\n);}
    \foreach \n in {1,2}
        {\draw (intermediate-\n) -- (view-\n);}
    \foreach \s in {3,...,13}
        {\pgfmathtruncatemacro\v{\s+1}\draw (intermediate-\s) -- (view-\v);}
    \path
        node[right=3em of view-end,font=\rmfamily]           (view-type)
            {new view (of type $V^*$)}
        (intermediate-end -| view-type) node[font=\rmfamily] (intermediate-type)
            {old view (of type $V^*$)}
        (source-end       -| view-type) node[font=\rmfamily] (source-type)
            {old source (of type $S^*$)}
        ;
\end{diagram}

In this restructured alignment diagram, the upper alignment (which connects
elements of different types) will always be completely flat, and hence
requires no sophisticated tools to generate. In contrast, the lower
alignment contains all the interesting information, and is the one we hope
to compute with \texttt{diff}. Moreover, the connections in the lower
alignment are now between elements of the same type, making the use of
% TODO: expand these wrinkles into paragraphs/pages?
\texttt{diff} much more plausible. One wrinkle is that the data in this
example is unrealistically simple, and more complicated data often needs
more complicated tools for specifying the cost function that \texttt{diff}
uses. Another wrinkle is that in real-world situations, one often wants to
discover alignments with crossings like
\begin{diagram}[alignment diagram]
    \foreach \c in {D,i,r,G,r,a,p,h,R,e,s}
        {\node[on chain=source]{\c};}
    \node[on chain=intermediate,below=5ex of source-1] {d};
    \foreach \c in {i,r,g,r,a,p,h,r,e,s}
        {\node[on chain=intermediate]{\c};}
    \node[on chain=view,below=5ex of intermediate-1] {r};
    \foreach \c in {e,s,d,i,r,g,r,a,p,h}
        {\node[on chain=view]{\c};}
    \foreach \n in {1,...,11}
        {\draw (source-\n) -- (intermediate-\n);}
    \foreach \s in {1,...,8}
        {\pgfmathtruncatemacro\v{\s+3}
         \draw (intermediate-\s) -- (view-\v);}
    \foreach \s/\h in {9,...,11}
        {\pgfmathtruncatemacro\v{\s-8}
         \pgfmathparse{7.5-\s}
         \draw (intermediate-\s.south) to[|-|=\pgfmathresult ex] (view-\v.north);}
\end{diagram}
which require more sophisticated algorithms than the traditional
\texttt{diff}.
% TODO: expand the explanation of what's hard about guessing alignments? not
% sure; it would be pretty easy to fill a lot of space with text about that,
% but it seems sort of orthogonal to the point we're trying to make here.
% how should this whole section be structured?

Indeed, it is not even clear that it is always possible to correctly guess
the alignment given just an old and a new copy of the data.
% TODO: can we make these references a little less unnatural looking in the
% rendered document?
Figures~\ref{fig:school-salaries-hr} and~\ref{fig:school-salaries-sec-pre}
show the human resources database for a small school, which tracks the
salaries of their teachers, along with a document maintained by a secretary
who should not be privy to salary information. The document and the database
are connected by a \map lens. Now, suppose one of two scenarios happens:
\begin{itemize}
    \item Mary Jones gets married and changes her name to Mary Smith.
    \item Mary Jones retires, and the school hires a replacement who, by
        coincidence, shares her first name: Mary Smith.
\end{itemize}
In both cases, when the secretary updates her document, it will look as it
does in Figure~\ref{fig:school-salaries-sec-post}. As shown in
Figure~\ref{fig:school-salaries-align}, there are really two feasible
alignments. In the former scenario, we should align Mary with her former
self, and reflect the change as an update to her name (but keep her old
salary). In contrast, in the new scenario, we should not align the new Mary
with any of the teachers that used to teach at the school. Since only the
old and new copies of the secretary's document are available to a lens, the
lens cannot choose correctly: it has no way to distinguish between these two
scenarios.

\begin{figure}
    \begin{minipage}{0.33333333\linewidth}
        \centering
        \begin{tabular}{lr}
            Teacher name & Salary \\
            \hline
            Sam Rickard & 57,000 \\
            Jon Jacobs & 50,000 \\
            Mary Jones & 65,000 \\
        \end{tabular}
        \subcaption{HR's view}
        \label{fig:school-salaries-hr}
    \end{minipage}%
    \begin{minipage}{0.33333333\linewidth}
        \centering
        \begin{tabular}{l}
            Teacher name \\
            \hline
            Sam Rickard \\
            Jon Jacobs \\
            Mary Jones \\
        \end{tabular}
        \subcaption{A secretary's view}
        \label{fig:school-salaries-sec-pre}
    \end{minipage}%
    \begin{minipage}{0.33333333\linewidth}
        \centering
        \begin{tabular}{l}
            Teacher name \\
            \hline
            Sam Rickard \\
            Jon Jacobs \\
            Mary Smith \\
        \end{tabular}
        \subcaption{After an update}
        \label{fig:school-salaries-sec-post}
    \end{minipage}\\[3ex]

    \begin{minipage}{\linewidth}
        \begin{diagram}[alignment diagram, inner xsep=1em, start chain=salary]
            \path
                node[on chain=source]       {Sam Rickard}
                node[on chain=source]       {Jon Jacobs}
                node[on chain=source]       {Mary Jones}
                node[on chain=salary,below=of source-1]
                                            {57,000}
                node[on chain=salary,below=of source-2]
                                            {50,000}
                node[on chain=salary,below=of source-3]
                                            {65,000}
                node[on chain=intermediate, below=10ex of salary-1]
                                            {Sam Rickard}
                node[on chain=intermediate] {Jon Jacobs}
                node[on chain=intermediate] {Mary Jones}
                node[on chain=view, below=10ex of intermediate-1]
                                            {Sam Rickard}
                node[on chain=view]         {Jon Jacobs}
                node[on chain=view]         {Mary Smith}
                ;
            \foreach \n in {1,2,3} \draw (salary-\n) -- (intermediate-\n);
            \foreach \n in {1,2}   \draw (intermediate-\n) -- (view-\n);
            \draw[dashed] (intermediate-3) to node[right,font=\sffamily]{?} (view-3);
        \end{diagram}
        \subcaption{Whether the marked edge should be included or not
            depends on invisible context}
        \label{fig:school-salaries-align}
    \end{minipage}
    \caption{A school's staff list, as seen by HR and by the principal's secretary}
    \label{fig:school-salaries}
\end{figure}

Clearly, discovering alignment information is a tricky business.
Additionally, most current lens frameworks treat such alignment information
as a second-class citizen: it is not passed, stored, or returned by the
lens. Because of this, it is not possible for an outside tool to provide
hints about the alignment; the implementation of alignment discovery is
intermingled with the implementation of alignment usage and propagation
inside each lens' definition; and alignment information cannot be internally
communicated between lens components. The conclusion we must draw is that
doing a really good job of implementing \map involves rethinking some or all
of the theoretical foundations of lenses!

% TODO: it almost seems like this last paragraph appears out of nowhere. I
% wonder if it is worth trying to explode even that into a page or two.

\section{Symmetry}
\label{sec:intro-symmetry}
TODO: there may be no canonical repository that contains all the data

some other ways to do symmetry, with their drawbacks:
\begin{itemize}
    \item two asymmetric lenses with a common source (writing two lenses
        leads to all the code maintenance problems of writing two functions)
    \item constraint maintainers (no composition)
    \item isomorphisms (transformations can't lose information)
    \item partial isomorphisms (same drawbacks as isomorphisms, plus
        partiality)
\end{itemize}

\section{Size}
\label{sec:intro-size}
TODO: sometimes repositories are too large to facilitate functional
computations or to transmit

\section{Contributions}
\label{sec:intro-contributions}
\begin{itemize}
    \item We have made some valuable progress on each of these issues
        \begin{itemize}
            \item alignment: showed specific examples of lenses that
                disambiguate some especially confusing repository
                modifications
            \item give a natural way of factoring out the descriptions of
                extra global information -- treat it completely generically
                and see where that takes us
            \item symmetry: showed how to design a lens framework that
                supports composition and symmetry
            \item size: designed a series of lenses where the computations
                operate on small edits, rather than the large repository
        \end{itemize}
    \item We implemented xxx, which demonstrates yyy
    \item Hint at the fact that there is more to be done if you want to
        operate on multiple repositories simultaneously
\end{itemize}
