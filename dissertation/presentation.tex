\documentclass{beamer}
\usepackage{presentation}
\title{Generalizing Lenses}
\subtitle{A New Foundation for Bidirectional Programming}
\author{Daniel Wagner} % for hyperref
\date{June 13, 2014}

\begin{document}

\author{Daniel Wagner\\[3ex]\includegraphics[width=0.2\linewidth]{plclub-logo.pdf}} % for beamer
\maketitle

\begin{frame}
    \frametitle{Bidirectional programming}
    Keep two pieces of data in synch. It's a common problem.

    Don't want to write two programs for maintenance reasons.
\end{frame}

\begin{frame}
    \frametitle{Databases}
    First interest was in the database community, via view-update problem.

    Generated idea of constant-complement updating.

    Basis for asymmetric lenses. Lots of language-based research followup.
\end{frame}

\begin{frame}
    \frametitle{UI}
    Separate research thread on user interfaces.

    Constraints between interface elements (e.g. when selecting a range, the
    upper bound is above the lower bound). But don't want to constrain user.

    So restore broken constraints. Led to constraint maintainers.
\end{frame}

\begin{frame}
    \frametitle{Dissatisfaction}
    Basic assumption of asymmetric lenses: source contains all data. View
    contains some chunk of interest to the user.

    Behavioral laws not strong enough.

    Surprisingly hard problem: alignment.

    Need modularity.
\end{frame}

\begin{frame}
    \frametitle{Symmetric lenses}
    First lens framework to support symmetry and address all the issues that
    composition causes -- computability, behavioral equality.

    But behavioral laws are no better, and no improvement on alignment.
\end{frame}

\begin{frame}
    \frametitle{Edit lenses}
    Extend symmetric lenses with explicit alignment handling.

    While we're at it, incremental operation for performance.

    Did an algebraic study of the framework, resulting in a large collection
    of abstract syntax.

    Prototype implementation exploring the problem of generating alignment
    information.
\end{frame}

\begin{frame}
    \frametitle{Related work preview}
    Table proving we are better than everybody else.
\end{frame}

\begin{frame}
    \frametitle{Other models of edits}

    \begin{itemize}
        \item $X \times X$ (before and after)
            \begin{itemize}
                \item State-based lenses
                \item[\ybullet] Very simple starting point
                \item[\nbullet] Not enough information about alignment
            \end{itemize}
        \item $X \to X$ (extensional edit operation)
            \begin{itemize}
                \item Stevens' algebraic study of delta lenses
                \item[\ybullet] Models many behaviors
                \item[\nbullet] Difficult to recover intensional data
            \end{itemize}
        \item category on $X$ (collection of edits for each before/after
            pair)
            \begin{itemize}
                \item Diskin, et al's delta lenses
                \item[\ybullet] Very rich information about change
                \item[\nbullet] Very rich information about change
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Modules}
    Keep the best features of each: collection of edits for easy
    introspection + mapping to functions to cover many behaviors.

    \vpause

    Module $\left<X,\DX,\odot_X,\init_X\right>$ is:
    \begin{itemize}
        \item Set of values to be edited $X$
        \item Monoid of edits $\DX$
        \item Homomorphism from edits to operations $\odot_X \in \DX \to X
            \partialto X$
        \item Default value $\init_X$ is a technical detail; explanation
            later
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Monoids}
    Quick review: monoid means
    \begin{itemize}
        \item There is an identity $\ONE$
        \item and an associative binary operation (juxtaposition).
    \end{itemize}

    Homomorphisms $f$ respect this structure.
    \[f(\ONE) = \ONE\]
    \[f(m\;n) = f(m)\;f(n)\]
    In particular, for edits: identity always succeeds and does nothing, and
    edits can be run in sequence.
\end{frame}

\begin{frame}
    \frametitle{Partiality}
    \[\odot_X \in \DX \to \alert<2>{X \partialto X}\]

    \pause\pause

    Requiring totality forces you to include unnatural edits.

    \[M \triangleq \{\ONE\} \cup \{a \mapsto b \mid a,b \in \N\}\]

    With totality:
    \begin{align*}
        (a \mapsto b)\;(b \mapsto c) \odot a &= c \\
        (a \mapsto b)\;(b \mapsto c) \odot b &= c
    \end{align*}
    \ldots must expand $M$ to accommodate this.

    With partiality, can define
    \[(a \mapsto b)\;(b \mapsto c) \triangleq a \mapsto c\]

    \pause
    Theorem: Partiality is an illusion.
\end{frame}

\begin{frame}
    \frametitle{Data structures}

    Common approach to implementing complex data structures:

    \[\tau := 0 \mid 1 \mid X \mid \tau+\tau \mid \tau\times\tau
           \mid \mu X\!.\;\tau {\color<2->{lightgray}\mid \tau\to\tau}\]

    Try to design edit modules for each of these types.

    \vpause

    \uncover<3>{\alert{Does not work well.}}
\end{frame}

\begin{frame}
    \frametitle{Free monoids}
    All modules in this talk based on lists:
    \begin{align*}
        \ONE &\triangleq \left<\right> \\
        \left<a_0,\cdots,a_m\right>\;\left<b_0,\cdots,b_n\right>
            &\triangleq \left<a_0,\cdots,a_m,b_0,\cdots,b_n\right>
    \end{align*}

    Elements are atomic edits, and get run in sequence:
    \[\left<a,b,c\right>\odot x \triangleq
        a \odot\gen (b \odot\gen (c \odot\gen x))\]
\end{frame}

\begin{frame}
    \frametitle{Products}
    How to edit $X \times Y$? Either edit $X$ or edit $Y$.

    \begin{align*}
        \D(X\times Y) &\triangleq \DX + \DY \\
        \mlleft \dx \odot\gen (x,y) &\triangleq (\dx \odot x, y) \\
        \mlright\dy \odot\gen (x,y) &\triangleq (x, \dy \odot y)
    \end{align*}
\end{frame}

\begin{frame}
    \frametitle{Sums}
    Choices are less canonical, and significantly more fiddly.

    Reset on a side, or stay and apply an edit.
\end{frame}

% TODO: I think can steal some slides explaining why alignment is
% important/hard to put here. Otherwise maybe it's hard to justify why
% ``rewrite the list elements'' isn't a good replacement for ``reorder the
% list'' later.

\begin{frame}
    \frametitle{Recursive types}
    Proposal 1: throw an ``unroll'' in the mix.

    Doesn't work well: can't insert, delete, swap elements.

    Can throw in insert, delete without much trouble.

    Swap harder: have to rethink products.
\end{frame}

\begin{frame}
    \frametitle{Recursive types}
    Proposal 2: start over from scratch with more types. Build new values by
    pointing at paths in the old one.

    Doesn't work well: environments get in the way. Type-based lets you look
    at too many holes for lenses to be able to do sane things.
\end{frame}

\begin{frame}
    \frametitle{Containers instead of recursive types}
    But the ``paths'' thing is a nice idea.

    Containers abstract from paths to just have uninterpreted pointers.

    Can't have pointers outside the container.
\end{frame}

\begin{frame}
    \frametitle{Containers}
    Details of containers as given by previous authors.
\end{frame}

\begin{frame}
    \frametitle{Container restrictions}
    Extra restrictions are needed for edits to make sense.

    Positions are live or not, rather than having a shape-indexed set of
    positions. Easier to model in non-dependent language.

    Partial order of shapes, with associated edit module.
\end{frame}

\begin{frame}
    \frametitle{Container module}
    Insertions/deletions are monotone shape edits. Rearrangements change
    shape but not size.

    Edit module for containers.
\end{frame}

\begin{frame}
    \frametitle{Container mapping lens}
    Delegate mods, copy structure changes.
\end{frame}

\begin{frame}
    \frametitle{Alignment}
    Explicit edit instructions simplifies alignment handling.

    Alignment slightly implicit in the edits. But need not be made explicit
    during handling.

    When underlying lens has trivial complement, this has trivial
    complement. (Lenses only make promises about good edits!)
\end{frame}

\begin{frame}
    \frametitle{Reshaping}
    Actually, not so important that source and target containers are the
    same.

    Position bijection $\Rightarrow$ lens. Bijection can even depend on
    state to have some hysteresis.

    Probably needs 2-3 more slides to do the details justice.
\end{frame}

\begin{frame}
    \frametitle{Other results}
    Lens equivalence needed for composition to be reasonable + proofs that
    all combinators respect equivalence classes

    CT-based study of algebra: tensor product/sum, but no real product/sum
    (did we do some functoriality/naturality proofs, too, somewhere?)

    Iterators for symmetric lenses

    Symmetric lenses subsume asymmetric lenses; edit lenses subsume
    symmetric lenses when given a diff operation

    Took a first step away from free monoid edit modules

    Implementation explores alignment generation problem

    Maybe should be exploded into one slide each?
\end{frame}

% TODO: some slides covering the conclusion (i.e. summarize what we did, say
% it was important, give a little context, and ask for questions)

\end{document}
outline proposal
-  5: background + motivation
    - keep two pieces of data in synch, even though they are stored in a
      different format or have slightly different ``stuff'' inside
    - design transformation pairs in tandem
    - perhaps a bit of history? databases+complements; lenses and subsequent
      bloom of research; dissatisfaction with laws/asymmetry/alignment
-  5: scope of my work + the thesis + my contributions
    - contributions:
        - framework that supports symmetry, alignment, performance
        - algebraic study of the framework + an inhabiting syntax
        - prototype implementation
- 25: deep drill into something technical and cool; possibilities:
    - containers + container mapping + how alignment is solved with the edit
      language for containers; perhaps leading to container reshaping lens;
      perhaps coming from discussion of why recursive types are hard to
      design edit languages for
        - skip the lenses, talk just about edit languages to begin with
        - (free) edit monoid for products
        - (free) edit monoid for sums
        - make a couple attempts at an edit monoid for recursive types
        - notice that what we really want is some concept of a pointer into
          these structures
        - so model it that way explicitly, use containers
        - (free) edit monoid for containers
        - mapping lens for containers
        - observe how alignment is handled
        - discuss reshaping lens
    - the category of (edit) lenses, the machinery needed to make it be a
      category, what structure you get and don't (and why), what open
      questions this settles/insight this gives
    - behavioral laws: why the old ones don't cut it and how our
      monoid-based ones help; observation that partition is tricky and may
      require lax laws and what this tells us about the partition lens
    - possibly: the monoid isomorphism route to lenses (i.e. start with
      isomorphisms, see why they are too strong, see how to relax them, then
      add complements; can also discuss the ``one module per type''
      philosophy along the way to motivate adding complements vs. choosing a
      different edit language when designing partition lens)
-  5: overview of all results
-  5: pop back up a level and give some perspective + summary
    - symmetric lenses: first framework to offer symmetry + serious study of
      composition and the associated machinery
    - edit lenses: add incremental operation, talk about the processing of
      alignment information
    - implementation: still need some theory about generating alignment
      information

BCP says:
    * give some motivation/perspective... but make it quick; almost
      everybody in the audience has seen my talks before, so they know
      what's going on
    * plan to make it to the list of contributions within about five minutes
    * two purposes for the presentation; should heavily weight my efforts
      towards really satisfying the second goal
        * as a public announcement of the work I've done and contributions
          I've made
        * gives the committee a chance to solidify their understanding and
          opinions of my work
SCW says:
    * BUT the focus should be on what I have contributed; the
      history/perspective should be there so that it's clear what I've
      contributed to the historical understanding, the technical stuff
      should be there so they understand what I've contributed, etc.; the
      technical content isn't the focus, but a means to conveying the focus
    * also, re-expressed the preference for explaining one thing well, i.e.
      it's reasonable to skimp on old work in favor of a good, in-depth
      explanation of the newest work
    * she mentioned in passing something like, "maybe half the talk is on
      your newest technical work, and five minutes is on how that connects
      with older work"
SAZ says:
    * definitely reiterate the motivation for the work
    * explain contributions to someone already familiar with the work
    * very important: situate this work compared to other work
    * might want to give the committee an overview of what they asked for at
      the proposal and how I addressed those recommendations
SAZ suggested a rough timing outline:
    *  5min background + motivation
    *  5min scope of my work + the thesis + my contributions
    * 30min deep drill into something technical and cool
    *  5min pop back up a level and give some perspective + summary
