\section{Graph-based delta lenses}
\label{sec:delta}

There is a closely related line of work focused on designing edit-based
lenses which begins with much the same motivation our work
does~\cite{diskin2011asymmetric,Diskin-Delta11,hermann2011correctness}. They
arrive at a slightly different point in the design space compared to us,
with a primary difference being their treatment of edits. For them, edits
are typed---with edit type $x \dedge x'$ classifying edits that can be
applied to value $x$ and result in value $x'$---and edit application is
total. Before we investigate their definitions of asymmetric and symmetric
delta lens, let us review their model of edits in detail. We will begin with
a few standard definitions to put some notation in place.

\begin{definition}
    A \emph{graph} $G$ is a quadruple $\left<G_0,G_1,\mldom,\mlcod\right>$
    consisting of a set of nodes $G_0$, a set of edges $G_1$, and two
    functions $\mldom,\mlcod \in G_1 \to G_0$ giving the source and target
    of each edge. We will write $e:v \dedge v'$ as shorthand for the
    assertion that $e \in G_1$, that $\mldom(e)=v$, and that $\mlcod(e)=v'$.
    If the directionality of the edge is uninteresting, we will write $e:v
    \uedge v'$ to mean either $e: v \dedge v'$ or $e: v' \dedge v$.
\end{definition}

Below, we will use graphs to model edits: nodes of the graph will correspond
to repository states, and an edge $\dx : x \to x'$ will correspond to an
edit $\dx$ which, when applied to state $x$, results in state $x'$. As in
our development, it is natural to impose a little bit of structure on edges,
such as the existence of a ``do-nothing'' edit and the ability to combine
two edits into one. We introduce these restrictions separately so that we
may talk about lenses between edit models with only some of this structure.
We will also introduce a constraint that says that no matter which two
repository states you choose, there is some edit between them, which may be
an important practical consideration but does not seem to affect the theory
significantly one way or another.

% TODO: do we really need to define semicategory? we don't use it anywhere,
% do we? let's just skip straight from ``reflexive'' to ``category''

\begin{definition}
    A graph $G$ is \emph{reflexive} if it comes equipped with a function
    $\id_G \in G_0 \to G_1$ which chooses a distinguished self loop
    $\id_{G,v} : v \dedge v$ for each node $v$. By abuse of notation, we
    will write $\id_v$ instead of $\id_{G,v}$ when there can be no confusion
    about which graph is meant.
\end{definition}

\begin{definition}
    A graph $G$ is a \emph{semicategory} if it comes equipped with a partial
    function $;_G \in G_1 \times G_1 \partialto G_1$ such that
    \begin{itemize}
        \item $e;_Ge' : v \to v''$ iff there is $v'$ for which $e : v \to
            v'$ and $e' : v' \to v''$, and
        \item $e_1;_G(e_2;_Ge_3)=(e_1;_Ge_2);_Ge_3$.
    \end{itemize}
    As with identities, we will often omit the $G$ subscript, writing just
    $;$ when the graph is clear from context.
\end{definition}

\begin{definition}
    A graph $G$ is \emph{connected} if for each $v,v'\in G_0$ there exists
    an edge $e : v \dedge v'$.
\end{definition}

It's easy to see that a reflexive semicategory is a category, so long as the
``do-nothing'' edits and the edit composition work together in the sense
that $\id_v;e=e;\id_{v'}=e$ whenever $e : v \to v'$. For the discussion of
symmetric delta lenses, we will also want to consider edits which can be
``undone''.

\begin{definition}
    A reflexive graph $G$ is \emph{involutive} if it comes equipped with a
    function $\swoop \in G_1 \to G_1$ which associates with each edge $e : v
    \dedge v'$ an opposing edge $e\swoop : v' \dedge v$. It is required to
    be an involution (so that $e\swoop\swoop = e$) and to respect the
    reflexive structure of the graph (so that $\id_v\swoop=\id_v$).
\end{definition}

Before we come to a discussion of the lens frameworks proposed in this line
of work, it is worth comparing our modules to their choice of edit model.
They essentially consider two models: their asymmetric lenses are based on a
connected category model of edits, and their symmetric lenses are based on a
connected involutive graph model of edits.

In both cases, there is an underlying graph, and in particular this means
that each edit must uniquely identify the state that it can be applied to
along with the state it produces. At least naively, this requirement seems
to be in conflict with our goal of representing edits with objects
significantly smaller than the repository states. Many of our edit modules
exploit the ability to reuse edits as modifications to many different
repository states. Nevertheless, totality of edit application is a nice
feature. One can view the two approaches as two extremes, with on one end
graphs with a single node representing all possible repository states and on
the other end graphs with many nodes where each node represents a single
repository state. There may be a middle ground in which graph nodes each
represent many possible repository states; the hope then would be that one
could keep the benefit of a total edit application function while reusing
single edits on many different states. For example, consider our list edits.
One might consider a graph with one node for each possible length of list.
Then one would have, for example, deletion edges $\mldelete : m \dedge n$
when $m<n$; such an edge must store marginally more information than our
edit module did (the source and target length rather than a single number
telling their difference), but the set of repositories to which it applies
is much more clearly delimited. Attempting to recast the edit modules and
lenses proposed above in this light would be an interesting area for future
work.

% TODO: give the precise connection between modules and categories (show how
% to translate between them), as we did in the edit lens paper
The connection between modules and edit graphs can be made precise as
follows. To pass from a module $X$ to a graph $G$, let $G_0=|X|$ be the set
of nodes and $G_1=\{m : x \dedge y \mid mx=y\}$ be the set of edges (so that
$\mldom(m : x \dedge y)=x$ and $\mlcod(m : x \dedge y)=y$, hence $(m : x
\dedge y) : x \dedge y$). The graph can be made reflexive by defining $\id_x
= \ONE : x \dedge x$; if we further define the composition $(m : x \dedge
y);(m' : y \dedge z)=mm' : x \dedge z$, the monoid action laws guarantee
that we can regard the graph as a category.

The involutive graph model of edits demands the existence of undo edits,
something we did not consider carefully in the edit lens framework above. A
suitable module-based analog of the typed involution would be to require
each module to include an untyped involution $\swoop$ such that
$(\dx\swoop\;\dx)\odot x=x$ whenever $\dx\odot x$ is defined. (Thus
$\dx\swoop\;\dx$ is a restricted identity: not necessarily equal to $\ONE$,
but behaves like it for some subset of the values being edited.) Many of the
modules and module combinators we have defined above can be equipped with
this structure. A notable few that cannot include edit operations which
actually delete information, such as the sum module's $\ml{switch}$ edits
and the list module's $\mldelete$ edits. These edits would need to be
enriched or restricted to include the information being deleted; for
example, one could modify the action associated with $\mldelete$ edits to
only succeed when the list elements being deleted were $\init$ (so that
edits which wish to delete an element must first modify it to being $\init$
with $\mlmodify$ edits), and one could enrich the $\ml{switch}$ edits with
an edit that returns the value to a tagged $\init$ before switching sides of
the sum. Thus in general it seems that requiring an ``undo'' ability can
require somewhat larger edit operations.

\subsection{Asymmetric}
\label{sec:delta:asymmetric}
There is a closely related line of work on designing edit-based
\emph{asymmetric} lenses by Diskin, et al~\cite{diskin2011asymmetric}.

% TODO: high points of this paper: a definition of an asymmetric delta lens,
% how to do sequential composition, a characterization of diffing, and a
% neat weakening of PutPut based on diffing

\subsection{Symmetric}
\label{sec:delta:symmetric}
% describe ``From state-based to delta-based bidirectional transformations:
% the symmetric case''

% TODO: rework now that we've moved some discussion into the shared prefix
% above
Diskin et al. also spend some effort considering what machinery is needed to
support transformations between domains that each have missing
information---that is, symmetric transformations~\cite{Diskin-Delta11}.
Before we get to their somewhat idiosyncratic algebraic structure
abstracting edits, let us introduce some notation for handling graphs.

\begin{definition}
    A \emph{model space} is a triple $\left<G,\id,\swoop\right>$ of a
    graph $G$ together with an involution $\swoop\in G_1 \to G_1$ which
    associates with each edge $e : v \dedge v'$ an opposing edge $e\swoop:
    v' \dedge v$ and a function $\id \in G_0 \to G_1$ which chooses a
    distinguished self loop $\id_v : v \dedge v$ for each node $v$. The two
    operations are required to be coherent in the sense that $\id_v\swoop =
    \id_v$.
\end{definition}

Model spaces are---like modules in our development---intended to abstract
edits and values. With this motivation in mind, there are a few points of
interest about this definition. Most notable is that a given edit (edge)
uniquely identifies both the value it can be applied to and the value that
results. Additionally, edits are required to support an ``undo'' operation
via $\swoop$. However, because there is no notion of edit composition, we
cannot require that identity edits are a unit or that $e$ and $e\swoop$
compose to the identity. We will see later that the $\id$ and $\swoop$
operations are included to aid in stating behavioral laws about lenses;
perhaps this explains why there is little attempt to give behavioral laws
about the edit structure implied by these operations.

\begin{definition}
    Given graphs $G$ and $H$, we define the \emph{source-} and
    \emph{target-coincident} edge pairings as follows:
    \begin{align*}
        G \domco H &= \{(e_g,e_h) \mid e_g : v \dedge v' \in G_1 \land e_h :
        v \uedge v'' \in H_1\} \\
        G \codco H &= \{(e_g,e_h) \mid e_g : v \dedge v' \in G_1 \land e_h :
        v' \uedge v'' \in H_1\}
    \end{align*}
\end{definition}

\begin{definition}
    A \emph{symmetric delta lens} $\ell$ connecting model spaces $X$ and
    $Y$, written $\ell \in X \sdlens Y$, consists of:
    \begin{itemize}
        \item a bipartite graph $R$ whose two parts are $X_0$ and $Y_0$ (the
            edges of $R$ are called \emph{correspondence relations}),
        \item a function $\mlfppg \in X \domco R \to Y_1 \times R_1$,
            and
        \item a function $\mlbppg \in Y \domco R \to X_1 \times R_1$.
    \end{itemize}
    We will write $\mlfppg_1$ and $\mlfppg_2$ (and similarly for $\mlbppg$)
    for the $Y_1$ and $R$ parts of $\mlfppg$'s output, respectively.
\end{definition}

The preconditions for $\mlfppg$ above stating that the edit and
correspondence relations are source-coincident is somewhat similar to our
precondition requiring an edit which applies cleanly.

A major contribution of this line of research is an exploration of
behavioral guarantees that reasonable symmetric delta lenses might offer.
The obvious laws are too strong; but the insight of this development is that
if we take the obvious laws and replace equalities by a slightly coarser
equivalence relation, we get laws that are much more plausible. The core of
the problem is that equality on $X$ edits distinguishes between edits that
modify information not available in $Y$; we would prefer a relation that
compares only the parts of the edit that affect the shared information.
At first it seems difficult to define ``shared information'' formally, but
lenses are exactly transformations that define what information is shared;
so the relation is parameterized by a lens.

\begin{definition}
    Given function $f \in X \to Y$ we say $x$ and $x'$ are \emph{equivalent
    under $f$}, denoted $x \under_f x'$, when $f(x)=f(x')$.
\end{definition}

It is easy to see that $\under_f$ is an equivalence relation for any $f$.

\begin{definition}
    Given symmetric delta lens $\ell \in X \sdlens Y$ and a correspondence
    relation $r : x \uedge y$ for $\ell$, we define equivalence relations on
    edits to $x$ and $y$, respectively:
    \begin{align*}
        \eqsharedl*\ell r &={} \under_{\lambda \dx.\;\ell.\mlfppg_1(\dx,r)} \\
        \eqsharedr*\ell r &={} \under_{\lambda \dy.\;\ell.\mlbppg_1(\dy,r)}
    \end{align*}
    When the lens is understood from context, we will write $\dx\eqsharedl
    r\dx'$ instead of $\dx\eqsharedl*\ell r\dx'$ (and similarly for
    $\dy\eqsharedr r\dy'$).
\end{definition}

Armed with this notation, they propose several possible restrictions that
one could place on symmetric delta lenses. The first two restrictions are
analogous to ones discussed in our work above. Like our demand that
applicable edits get translated to applicable edits that restore
consistency, rule \rn{SDWellTyped} below demands that the edits and
correspondence relations involved in an invocation of $\mlfppg$ form a
well-typed square. They also demand that the propagation functions preserve
the self-loop structure of the edit graphs via the \rn{SDIdId} rule.
\infrule[SDWellTyped]
    {\mlfppg(\dx,r) = (\dy,r')}
    {r  : \mldom(\dx) \uedge \mldom(\dy) \\
     r' : \mlcod(\dx) \uedge \mlcod(\dy)}
\infrule[SDId]{r : x \uedge y}{\mlfppg(\id_x,r)=(\id_y,r)}

The edit graphs have another kind of structure given by the $\swoop$
undo operation. One might hope that this structure is preserved in a similar
way; for example, a rule like \rn{SDUndo-Strong*} seems reasonable at first
blush.
\infrule[SDUndo-Strong*]
    {\mlfppg(\dx,r)=(\dy,r')}
    {\mlfppg(\dx\swoop,r')=(\dy\swoop,r)}
Unfortunately, this rule is very restrictive. Suppose the $Y$ side of the
lens were to store some information not available in the $X$ side, and
propagating $\dx$ produces a $\dy$ that deletes some of that information.
Then this information could not be restored from the information in
$\dx\swoop$\footnote{One could imagine storing just enough information in
the correspondence relations to allow undoing one operation. Perhaps this
could be made to work, but it is unlikely this would scale well in
situations where there are composite edits (and hence composite undos).}.
One way to weaken this law to something more plausible would be to demand
that we output something that behaves like $\dy\swoop$ on the shared
information; that is, by weakening the equality in the conclusion to our
coarser equivalence relation from above:
\infrule[SDUndo]
    {\mlfppg(\dx,r)=(\dy,r')}
    {\mlfppg_1(\dx\swoop,r') \eqsharedr{r'} \dy\swoop}

The fourth and final behavioral law proposed demands that the edit
propagation functions be near inverses: that is, if we propagate $\dx$ to
$\dy$, then the corresponding edit determined by the other propagation
function should be $\dx$. As stated, this law is again too strong, because
some of the modifications described by $\dx$ are to unshared data, and hence
are not available in $\dy$ during re-propagation. As before, we can make the
rule more reasonable by weakening from equality to equivalence:
\infax[SDInvertible]{\mlbppg_1(\mlfppg_1(\dx,r),r)\eqsharedl r\dx}
This behavioral law is called a roundtrip law in their development, but that
name is a little misleading, as the update to the $y$ value and the updated
correspondence relation are discarded before applying the $\mlbppg$
function. (It is as if two separate people happened to take flights that
crossed paths in the middle, rather than a single person taking a round
trip.) We will instead call this law a \emph{triple-trip} law---for the two
trips evident in the law plus one trip hidden by the equivalence relation.

The line of research goes on to describe other theoretical
frameworks with interfaces closer to what an end-user programmer might want
to implement that can give rise to symmetric delta lenses. In particular,
they describe a framework they call \emph{consistency
maintainers}~\cite{Diskin-Delta11} which include explicit alignment and
consistency-restoration phases as well as explore conditions under which a
triple-graph grammar can be used to produce a law-abiding
lens~\cite{hermann2011correctness}. No concrete instantiations are given for
any of the three frameworks. We have found that undertaking this endeavor is
a valuable crucible in which to test prospective frameworks, as the design
of a lens language makes a mismatch between behavioral laws and actual
behavior much more clear. (Just as a good framework helps to spot
potential implementation bugs, an implementation helps point out potential
framework bugs.) In particular, sequential composition---in our experience,
a crucial tool for building practical lenses---is not considered, and the
ensuing need for a notion of lens equivalence is not addressed.

The proposed \rn{SDInvertible} and \rn{SDUndo} laws seem on the surface to
be quite natural restrictions. Our development does not have analagous laws,
and it seems that including them would necessitate a stronger equational
theory for many of the modules proposed above. Exploring the consequences of
these laws could be an interesting avenue for future work on edit lenses.

\section{Algebraic rephrasing}
\label{sec:algebraic}
% TODO: Do we need to mention somehow that this is a continuation of the
% (similarly-algebraically-motivated) exploration of state-based lenses in
% the 2007 Stevens paper that's cited elsewhere?
There is a line of work on algebraic foundations for delta lenses that
arrives at a model very similar to the edit lens framework described
above~\cite{stevens2008tat}. They consider, as we do, edit monoids together
with edit translation morphisms and (total) edit application actions.
One significant difference is that they consider generalizing asymmetric
rather than symmetric lenses, adopting correspondingly modified behavioral
laws. In particular, in their setting, a delta lens is a \emph{lens-like
split short exact sequence}. Below we discuss each of these restrictions in
right-to-left order. We begin with two standard definitions to establish
some notation.

\begin{definition}
    The \emph{image} of a function $f \in X \to Y$ is the set of elements
    $\im(f) \subset Y$ that $f$ can output:
    \[\im(f) = \{f(x) \mid x \in X\}\]
\end{definition}

\begin{definition}
    The \emph{kernel} of a monoid homomorphism $f$, denoted $\ker(f)$, is
    the preimage of $\ONE$:
    \[\ker(f) = \{x \mid f(x) = \ONE\}\]
\end{definition}

\begin{definition}
    An \emph{exact sequence} is a sequence $\blist f_1 \clist f_n \elist$ of
    monoid morphisms with compatible domains and codomains, that is,
    \begin{diagram}
        \path
            node                      (0)    {$X_0$}
            node[right=2.5em of 0]    (1)    {$X_1$}
            node[right=2.5em of 1]    (2)    {$X_2$}
            node[right=2.5em of 2]    (dots) {$\cdots$}
            node[right=2.5em of dots] (n2)   {$X_{n-2}$}
            node[right=2.5em of n2]   (n1)   {$X_{n-1}$}
            node[right=2.5em of n1]   (n0)   {$X_n$}
            (0)    edge[->] node[above] {$f_1$}     (1)
            (1)    edge[->] node[above] {$f_2$}     (2)
            (2)    edge[->] node[above] {$f_3$}     (dots)
            (dots) edge[->] node[above] {$f_{n-2}$} (n2)
            (n2)   edge[->] node[above] {$f_{n-2}$} (n1)
            (n1)   edge[->] node[above] {$f_n$}     (n0)
        ;
    \end{diagram}
    and such that $\im(f_i)=\ker(f_{i+1})$ for each $i$.
\end{definition}

\begin{definition}
    An exact sequence is \emph{short} if it has four morphisms and starts
    and ends at $\D\Unit$:
    \begin{diagram}
        \path
            node                   (1-1) {$\D\Unit$}
            node[right=4em of 1-1] (K)   {$K$}
            node[right=4em of K]   (X)   {$\DS$}
            node[right=4em of X]   (Y)   {$\DV$}
            node[right=4em of Y]   (1-2) {$\D\Unit$}
            (1-1) edge[->] node[above] {$i$} (K)
            (K)   edge[->] node[above] {$k$} (X)
            (X)   edge[->] node[above] {$f$} (Y)
            (Y)   edge[->] node[above] {$s$} (1-2)
            ;
    \end{diagram}
    We will say \emph{around} to mean the third element of a sequence, as
    in, ``$\blist i \mlist k \mlist f \mlist s \elist$ is a short exact
    sequence around $f$.''
\end{definition}

Before we define what split and lens-like mean, let us consider when an
edit translation homomorphism $f \in \DS \to \DV$ may be extended to a short
exact sequence. The homomorphism $s \in \DV \to \D\Unit$ must be the
constantly-$\ONE$ function (there are no other functions with that type), so
that its kernel is $\ker(s)=Y$. Hence the restriction $\im(f)=\ker(s)$ that
arises from extending the sequence to the right says that $f$ must be
surjective. On the other hand, the sequence may always be extended to the
left by choosing $K$ to be the submonoid $\ker(f)$ and $k$ to be the
inclusion function. (The homomorphism $i$ is completely determined by the
homomorphism laws once we have chosen a monoid $K$: it must map the sole
input element $\ONE_{\D\Unit}$ to $\ONE_K$.) Other choices for $K$ are
possible---for example, by adding a fresh generator to $K$ that $k$ maps to
any non-trivial element of $X$---but we will not be interested in this
ability below.

In lens terms, one should think of $f$ as being an edit-lens analog of the
asymmetric lens framework's \GET function. Giving a short exact sequence
amounts to identifying an edit translation function $f\in\DS\to\DV$ that is
compatible with the monoid structure on edits and such that each $V$-edit
has at least one analogous $S$-edit.

\begin{definition}
    A short exact sequence around $f\in\DS\to\DV$ is said to \emph{split} if
    there is a homomorphism $g\in\DV\to\DS$ such that $g;f = \id_{\DV}$.
\end{definition}

We are guaranteed that there is a \emph{function} $g$ by the fact that $f$
is surjective, but not guaranteed that any such function is a monoid
homomorphism. If we do have such a homomorphism $g$ that splits the
sequence, then in lens terms we should consider that $g$ to be an edit-lens
analog of the \PUT function. Then $g;f = \id_{\DV}$ says that all the
information available in $V$-edits are also available in $S$-edits, an
analogous restriction to the one on state-based lenses that says that all
the information available in the view repository is available in the source
repository.

The final condition placed on this variant of delta lenses is that they be
lens-like. Thus far, all the conditions have been purely in terms of edits;
this final pair of properties connect the world of edits and the world of
states. This is similar to the edit lens law that requires $\dputr$ and
$\dputl$ to respect a consistency relation on states.

\begin{definition}
    A monoid action $\odot \in \DX \times |X| \to |X|$ is \emph{transitive}
    if for all $x,x' \in |X|$ there is $\dx \in \DX$ such that $\dx\odot
    x=x'$. We will say a module is transitive when its action is.
\end{definition}

\begin{definition}
    A short exact sequence around $f\in\DS\to\DV$ split by $g$ is
    \emph{lens-like} if it comes equipped with transitive, total modules for
    $\DS$ and $\DV$ such that two conditions hold:
    \infrule[LL1]
        {\ds\;\init_S = \ds'\;\init_S}
        {f(\ds)\;\init_V = f(\ds')\;\init_V}
    \infrule[LL2]
        {\dv\;f(\ds)\;\init_V = f(\ds)\;\init_V}
        {g(\dv)\;\ds\;\init_S = \ds\;\init_S}
\end{definition}

Rule \rn{LL1} amounts to saying that $f$ is (part of) a module homomorphism
(not just a monoid homomorphism). Rule \rn{LL2} is a bit more subtle, but is
motivated by this rephrasing of the state-based asymmetric lens framework's
\rn{GetPut} law:
\infrule[GetPutAlt]
    {\aget(s)=v}
    {\aput(v,s)=s}
Rule \rn{GetPutAlt} says, roughly, ``if the view $v$ has not changed since
the last synchronization, then the source $s$ should not change, either.''
Similarly, \rn{LL2} says, roughly, ``if the edit we are about to translate
does not change the view $f(\ds)\;\init_V$, then the edit we output should
not change the source $\ds\;\init_S$.''

That work goes on to explore the properties of this kind of delta lens. One
can take a lens-like sequence around $f\in\DS\to\DV$ equipped with a diffing
operation $\dif\in|S|\times|V|\to\DV$ (satisfying the obvious sanity
condition) and produce an asymmetric, state-based lens. Additionally, there
is a close relationship between demanding the existence of inverse
edits---that is, working with edit groups rather than edit monoids---and the
\rn{PutPut} asymmetric lens law:
\infax[PutPut]{\aput(v,\aput(v',s))=\aput(v,s)}
They show that one can define suitably restricted submonoids $\DV \subset V
\to V$ and $\DS \subset S \to S$ and lift \rn{PutPut}-abiding asymmetric
lenses into a lens-like sequence on groups. Furthermore, the two
translations agree with each other: converting a lens to a lens-like
sequence and back is the identity transformation, regardless of the choice
of $\dif$ operation in the latter transformation.

The primary difference between their work and ours is that they consider
only asymmetric situations. However, they also consider many fundamentally
different restrictions than the current development does, even after
accounting for the different setting. For example, they propose a law
requiring that when $g$ splits a sequence around $f$ we additionally have
$g;f=\id$. Since $f$ is surjective, this is the same as demanding $f;g;f=f$,
akin to Diskin's proposed triple-trip law discussed above. As mentioned in
that discussion, it is not a law that we have considered carefully; but it
seems we may be able to achieve something similar in many of the lenses we
defined by introducing appropriate equalities to our edit monoids for
structured data. The paper also spends some time discussing the
ramifications of demanding an edit group rather than an edit monoid. We have
not explored this restriction deeply, but some cursory investigations
suggest that including enough information to undo each operation may be at
odds with the size benefits promised above. Another restriction they have
throughout their development is that their edit application actions are
invariably total. We believe that partiality of these actions is an
important real-world consideration. Treating it carefully allows us to
distinguish between error conditions and edits which successfully do
nothing, and to give a guarantee that our lenses do not spuriously turn a
succesful nothing into an error condition.

They also treat backwards-compatibility with asymmetric, state-based lenses
very seriously, which gives rise to their lens-like restrictions.  Their
rule \rn{LL1} stating that the \GET direction is a module homomorphism can
be seen as saying that edit translation is consistent with state
translation.  Our demand that the edit translations preserve a consistency
relation can be seen as a generalization of this. On the other hand, their
rule \rn{LL2}---necessary to ensure that their delta lenses behave like
state-based lenses regardless of $\dif$ operation---seems quite strong. The
goal appears to be to preserve the state-based behavior that changing
nothing on one side changes nothing on the other; however, it is our view
that demanding that the distinguished do-nothing edit from one module be
translated to the distinguished do-nothing edit from the other module
already captures this intuition. There are edits which appear to do nothing
to a given view but which nevertheless have semantic content, and should
therefore be allowed to be distinguished by a lens. Consider the example of
Figure~\ref{fig:school-salaries} again, reproduced here as
Figure~\ref{fig:school-salaries-delins}. An edit which deletes the last
element of the secretary's view, then inserts a fresh element with value
``Mary Jones'', apparently does nothing to the current view. Nevertheless,
it seems quite natural\footnote{Possibly even desirable---an obviously
incorrect value is often preferable to a plausible incorrect value.} for the
translation of this edit to reset the salary associated with ``Mary Jones''
to a default value; a rule like \rn{LL2} would prevent lenses from having
this kind of nuanced behavior.

\begin{figure}
    \begin{minipage}{0.5\linewidth}
        \centering
        \begin{tabular}{lr}
            Teacher name & Salary \\
            \hline
            Sam Rickard & 57,000 \\
            Jon Jacobs & 50,000 \\
            Mary Jones & 65,000 \\
        \end{tabular}
        \subcaption{HR's view}
        \label{fig:school-salaries-delins-hr}
    \end{minipage}%
    \begin{minipage}{0.5\linewidth}
        \centering
        \begin{tabular}{l}
            Teacher name \\
            \hline
            Sam Rickard \\
            Jon Jacobs \\
            Mary Jones \\
        \end{tabular}
        \subcaption{A secretary's view}
        \label{fig:school-salaries-delins-sec-pre}
    \end{minipage}%
    \caption{A school's staff list, as seen by HR and by the principal's secretary}
    \label{fig:school-salaries-delins}
\end{figure}

Finally, our development includes significantly more effort instantiating
the lens framework to particular lenses and lens combinators. We believe
that this is good evidence that our behavioral restrictions are relaxed
enough to accomodate important use cases; nevertheless, they were strict
enough to prevent many genuinely undesirable behaviors in early proposals
for these combinators (not documented here).

% TODO: notation correspondence
% our \D\Unit is their 1
% our \init is their \Omega
% we use f and g for a split sequence; they use \mu and \lambda
% we use \ds and \dv for edits, they use g
% we say \dif operation; they say oracle

\section{Matching lenses}
\label{sec:matching}
% defining good alignment heuristics along with your lens
% decouples alignment discovery from lens operation
% does give concrete operations for discovering alignments; but is
% significantly more complex; can only handle containers with a single kind
% of data inside (e.g. could give good treatment to either the [a] or the
% [b] in a ([a], [b]))

\section{Hole-based delta lenses}
\label{sec:holes}
% lenses that operate on full data structures with node
% creation/deletion/modification ``holes'' in them -- tackles alignment
% problems, but not size or symmetry
%
% some text below that we can also scan for ideas about what to write here

\section{Fibrations}
\label{sec:fibrations}
% Johnson+Rosebrugh's work on sketch-based data modeling; see FogBugz for a
% list of resources to consult when it comes time to write this section
%
% still digesting, but it seems they have a notion of edit but that it
% doesn't help with alignment (?) and that they don't really propose much in
% the way of syntax -- they only give a way to check if a particular
% hand-constructed transformation is allowed

\section{Constraint maintainers}
\label{sec:constraint-maintainers}
% symmetric, but we improve in many ways
%
% some text below that we can also scan for ideas about what to write here

\section{Others}
\label{sec:other-related-work}
% In case of time crunch, may be able to drop this section!

\subsection{Graph transformations}
\label{sec:other-related-work:graph}
% BiG-lab's stuff -- check if they make any attempt at symmetry or edits

\subsection{Triple graph grammars}
\label{sec:other-related-work:triple}
% gives an attempt at parsing graphs; some of the tools are symmetric, and
% may be in use, but need to review a bit before knowing what to say here

\subsection{Incremental XML transformations}
\label{sec:other-related-work:xml}
% sort of tangentially related; lots of stuff is based on tree transducers;
% very interested in good models for edits and edit transformations so
% perhaps we have something to teach them there

% dump from our delta lenses paper {{{
%
%The most closely related attempt at developing a theory of update
%propagation is \cite{Diskin-Delta11} by Diskin et al. Their starting
%point is the observation (also discussed in \cite{Matching10}) that discovery of
%edits should be decoupled from their propagation. They thus propose a
%formalism, \emph{sd-lenses}, for the propagation of edits across
%synchronized data structures, bearing some similarities with our
%edit lenses. The replicas, which we model as modules, are there modeled
%as categories (presented as reflexive graphs)\iffull, as we discussed in 
%\S \ref{cats}\fi. Thus, for any two states $x,x'$ there is a set of
%edits $X(x,x')$. An sd-lens then comprises two reflexive graphs $X,Y$
%and for any $x\in X$ and $y\in Y$ a set $C(x,y)$ of
%``correspondences'' which roughly correspond to our
%complements. Forward and backward operations similar to our $\dputl$ and
%$\dputr$ then complete the picture. No concrete
%examples are given of sd-lenses, no composition, no notion of equivalence, and
%no combinators for constructing sd-lenses; the focus of the paper is
%rather on the discovery of suitable axioms, such as invertibility and
%undoability of edits, and a 
%generalization of {\em hippocraticness} in the sense of
%Stevens~\cite{Stevens07}. They also develop a comparison 
%with the state-based framework (cf.\ \S \ref{stateb} above). In
%our opinion, the separation of edits and correspondences according to
%the states that they apply to or relate has two important
%disadvantages.  First, in our examples, it is often the case that one
%and the same edit applies to more than one state and can be
%meaningfully propagated (and more compactly represented) as such. For example, while many of the
%container edits tend to only work for a particular shape, they are
%completely polymorphic in the contents of the container. Second, the
%fact that state sets are already categories suggests 
%that a category of sd-lenses would be
%2-categorical in flavor, entailing extra technical difficulties such as
%coherence conditions. 
%
% [dmwit comments after the fact: perhaps there is a middle ground! e.g. a
% category whose objects represent a set of similar states -- lists might
% have one object per length, for example. also I don't understand the
% complaint about 2-categorical flavor; seems it is the *objects* of the
% sd-lens category that have categorical structure, whereas the difficulties
% of 2-categories arise from arrows having categorical structure.]
%
%%% \finish{Here's a quick start from a brief scan of their most recent
%%%   paper~\cite{Diskin-Delta11} by BCP...
%%%   \begin{itemize}
%%%   \item Their motivations and goals are exactly the same.
%%%   \item The technicalities of their approach are pretty dense.  I haven't
%%%   internalized them yet.  In particular, I don't have a good intuition for
%%%   their ``sameness'' relations---what they say makes sense for ``flat''
%%%   structures like lists or simple graphs, but not for more structured data
%%%   (where you'd want to know about correspondences at various levels of
%%%   structure). 
%%%   \item They don't say anything about the size of their deltas, and at
%%%   least a naive representation would be big.  We're much more careful about
%%%   this. 
%%%   \item They propose two new laws (weak invertability and undoability).  I'm
%%%   not sure what to say about these, but I guess it's an important point of
%%%   comparison, since it's one of the main points of their paper.
%%%   \item They don't handle $\missing$ (a small point)
%%%   \item They don't define any combinators, just the semantic space itself (a
%%%   larger point, and related) 
%%%   \item Their Definition 19 and Theorem 5 relate their delta-lenses to our
%%%   symmetric lenses.  I'm not completely sure how to interpret it (does our
%%%   ``trivial module'' correspond to their ``simple graph''?), but in any case
%%%   our result is stronger because it goes both directions.  (Their
%%%   characterization of our symmetric lenses is a little bit wrong---it puts
%%%   $C$ in the wrong place---but I'm not sure this matters.)
%%%   \end{itemize}
%%% }
%
%Meertens's seminal paper on {\em constraint maintainers}~\cite{Meertens98}
%discusses a form of containers for lists equipped with a notion of edits
%similar to our edit language for lists, but does not develop a general
%theory of edit-transforming constraint maintainers.
%
%A long series of papers from the group at the University of Tokyo
%\cite[etc.]{Hu04, Mu2004, MuAlgebraic2004, HuModels07,
%  Hidaka10}\iffull\discuss{double-check these, and add more, and add to abstract
%  too}\fi{} deal with the alignment issue using an approach that might be
%characterized as a hybrid of state-based and edit-based.  Lenses work with
%whole states, but these states are internally annotated with tags showing
%where edits have been applied---e.g., marking inserted or deleted elements
%of lists.
%%
%Barbosa et al.'s {\em matching lenses}~\cite{Matching10} offer another 
%approach to dealing with issues of alignment in the framework of pure
%state-based lenses.  
%
%
%%% \noindent
%%% Other things we definitely need to compare to:
%%% \begin{itemize}
%%% \item Diskin's ``tile algebras'' \cite{DBLP:conf/gttse/Diskin09}
%%% \item The other delta-lens papers that Diskin refers to in the intro
%%% of~\cite{Diskin-Delta11} 
%%% \item Other papers addressing the alignment problem in different ways (e.g.,
%%% our Matching Lenses~\cite{Matching10}, Tokyo group papers such
%%% as~\cite{Mu2004} and maybe the ICFP10 paper on bidirectional graph
%%% transformations)
%%% \item Maybe some papers on edits in the context of version management (see
%%% last year's grant proposal for some citations)
%%% \item other lens-like things that have used some kind of deltas~\cite{HuModels07} 
%%% \begin{itemize}
%%% \item \finish{Meertens \cite{Meertens98} introduces edit operations in section 5.3
%%% (p. 68ff) to talk about edits to lists.  I have not grokked yet exactly how
%%% all this works, or how it fits into his general framework of constraint
%%% maintainers.  Some possible text:}
%
%%% \item 
%%% \end{itemize}
%%% \end{itemize}
%
%%% \iflater
%%% \finish{
%%% Other things to think about:
%%% \begin{itemize}
%%%     \item other research on edit lenses
%%%     \item practical tools that use notions of an edit
%%%     \item Is there any correspondence with other tools like SVN, Unison,
%%%     ...? 
%%% \item operation transform papers?
%%% \end{itemize}
%%% }
%%% \fi
%
% }}}

% dump from our complement lenses paper {{{
%
%There is a large literature on lenses and related approaches to
%propagating updates between connected structures.  We discuss only the most
%closely related work here; good general surveys of the area can be found
%in~\cite{FosterThesis,DBLP:conf/icmt/CzarneckiFHLST09}.  Connections to the
%literature on {\em view update} in databases are surveyed
%in~\cite{Focal2005-shortcite}. \iffull A short version of this paper is available
%in~\cite{HofmannPierceWagner10}.\fi
%
%The first symmetric approach to update propagation was proposed by
%Meer\-tens~\cite{Meertens98} and followed up \iffull in the context of
%model-driven design \fi by Stevens~\cite{Stevens07},
%Diskin~\cite{DBLP:conf/models/Diskin08}, and Xiong, et
%al~\cite{xiong2009supporting}.
%%
%Meertens suggests modeling synchronization between two sets
%$X$ and $Y$ by a {\em consistency relation} $R\subseteq
%X\times Y$ and two {\em consistency maintainers}
%$\triangleleft: X\times Y\rightarrow X$ and $\triangleright: X\times Y
%\rightarrow Y$ such that $(x\triangleleft y) \relR y$ and
%$x \relR (x\triangleright y)$ always hold, and such that $x \relR y$ implies
%$x \triangleleft y = x$ and $x \triangleright y = y$.
%
%The main advantage of symmetric lenses over consistency maintainers is
%their closure under composition. Indeed, all of the aforementioned
%authors note that, in general, consistency maintainers do not compose
%and view this as a drawback.
%%
%Suppose that we have relations $R\subseteq X\times Y$ and
%$R'\subseteq Y\times Z$ maintained by $\triangleright,\triangleleft$
%and $\triangleright', \triangleleft'$, resp. If we want to construct a
%maintainer for the composition $R;R'$, we face the problem that, given
%$x\in X$ and $z\in Z$, there is no canonical way of coming up with a
%$y\in Y$ that will allow us to use either of the existing maintainer
%functions. Concretely, Meertens gives the following counterexample.
%Let $X$ be the set of nonempty context free grammars over some alphabet, and let
%$Y$ be the set of words over that same alphabet. Let $R\subseteq
%X\times Y$ be given by $G \relR x\iff x\in L(G)$. It is easy to define
%computable maintainer functions making this relation a constraint
%maintainer. Composing this relation with its opposite yields an 
%undecidable relation (namely, whether the intersection of two context-free
%grammars is nonempty), so there cannot be computable maintainer functions.
%
%We can transform any constraint maintainer into a  symmetric lens as
%follows: take the relation $R$ itself (viewed as a set of pairs) as
%the complement, and define $\putl(x',(x,y))=(x'\triangleright
%y,(x',x'\triangleright y))$ and similarly 
%for $\putr$. If we compose such a symmetric lens with its opposite
%we obtain $R\times R\op$ as the complement and, for example,
%$\putr(x',((x_1,y_1),(y_2,x_2))) = 
%(x_2\triangleleft(x'\triangleright y_1), ((x',x'\triangleright
%y_1),(x'\triangleright y_1,x_2\triangleleft(x'\triangleright y_1))))$. 
%%
%For Meertens' counterexample, we would have complements of the form
%$((G_1,w_1),(w_2,G_2))$, with $w_1\in L(G_1)$
%and $w_2\in L(G_2)$; ``$\putr$''-ing a new grammar
%$G_1'$ through the composed lens yields the complement
%$((G_1',w_1'),(w_1',G_2'))$, where $w_1'$ is $w_1$ if $w_1\in L(G_1)$ and
%some default otherwise, and where $G_2'=G_2$ if $w_1'\in L(G_2)$ and
%$S{\rightarrow}w_1'$ (where $S$ is the start state) otherwise. We observe
%that there is a property of lenses analogous to Meertens' requirement that
%$x \relR y$ implies $x \triangleleft y = x$. This property is not
%necessarily preserved by composition, and in particular the lens described
%above for synchronizing languages does not have it.
%%
%Meertens recommends using a {\em chain} of consistency maintainers in such a
%situation to achieve a similar effect; however, the properties of such
%chains have not been explored.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%For asymmetric lenses, a number of alternative \iffull choices of behavioral
%\fi
%laws 
%have been explored.  Some of these are \iffull strictly \fi weaker than ours; for
%example, a number of papers from a community of researchers based in Tokyo
%replace the \rn{PutGet} law with a somewhat looser \rn{PutGetPut} law,
%permitting a broader range of useful behaviors for lenses that duplicate
%information.  It would be interesting to see what kind of categorical
%structures arise from these choices.  The proposal by Matsuda et
%al.~\cite{matsuda2007btb} is particularly interesting because it also employs
%the idea of complements.  Conversely, stronger laws can be imagined, such as
%the \rn{PutPut} law discussed by Foster et
%al.~\cite{Focal2005-shortcite}\iffull{} and the more refined variants
%in~\cite{updatable-security-views}\fi\iflater\finish{Say something more
%  about this?}\fi.
%
%A different foundation for defining lenses by recursion was explored by
%Foster et al.~\cite{Focal2005-shortcite}, using standard tools from domain
%theory to define monotonicity and continuity for lens combinators
%parametrized on other lenses.  The main drawback of this approach is that
%the required (manual) proofs that such recursive lenses are total tend to be
%somewhat intricate.  By contrast, we expect that our initial-algebra
%approach can be equipped with automatic proofs of totality (that is, choices
%of the weight function $w$) in many cases of interest.
%
%\ifdelta
%\finish{
%Updates: (note that the point in our paper is not update as such but rather
%how to marry it with lenses)  \finish{BCP will look for a good canonical
%  reference for updates}
%\begin{itemize}
%\item lens-like things that have used deltas~\cite{Hu04,Meertens98,MuAlgebraic2004,HuModels07}
%\item old update transformation
%\item old view update stuff
%\item new Waterloo stuff 
%\begin{itemize}
%\item flexibility, not efficiency
%\item no proposal for syntax---composition is the only operator they study
%at all
%\end{itemize}
%\end{itemize}
%}
%\fi
%
% }}}
