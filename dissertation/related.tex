\begin{table}
     % TODO: add \cite commands for each row
    \begin{center}
    \begin{tabular}{l|ccccc}
        & Align. & Symm. & Perf. & Synt. & Disc. \\
        \hline
%        triple graph grammars   &\N&\Y&\N&\Y&\\
        asymmetric delta lenses &\Y&\N&\N&\Y&\S\ref{sec:delta:asymmetric}\\
        symmetric delta lenses  &\Y&\Y&\N&\N&\S\ref{sec:delta:symmetric}\\
        comma category lenses   &\Y&\N&\N&\N&\S\ref{sec:clenses}\\
        group-based lenses      &\Y&\N&\N&\N&\S\ref{sec:algebraic}\\
        matching lenses         &\Y&\N&\N&\Y&\S\ref{sec:matching}\\
        annotation-based lenses &\Y&\N&\N&\Y&\S\ref{sec:annotations}\\
        constraint maintainers  &\Y&\Y&\N&\Y&\S\ref{sec:constraint-maintainers}\\
        symmetric lenses        &\N&\Y&\N&\Y&Chap.~\ref{chap:complement}\\
        edit lenses             &\Y&\Y&\Y&\Y&Chap.~\ref{chap:delta}\\
    \end{tabular}
    \end{center}
    \caption{Feature coverage for various alternatives to edit lenses}
    \label{tab:related-work-matrix-2}
\end{table}

Recent years have seen a large body of work on bidirectional transformations
in general, and frameworks based on the language-based approach embodied by
lenses in particular. A great deal of the work is motivated by the apparent
difficulty of the alignment problem discussed in
\S\ref{sec:intro-alignment}. Table~\ref{tab:related-work-matrix-2} gives a
summary of the most closely related work in the area. The first four columns
indicate whether the approach addresses alignment, symmetry, performance,
and syntax concerns, while the final columns gives a pointer to a section
with more in-depth discussion of the approach.

Asymmetric delta lenses and group-based lenses are extensions of asymmetric,
state-based lenses which replace all or most of the repository data that a
lens consumes or produces with edit information, instead. Symmetric delta
lenses extend asymmetric delta lenses with some significant additional
machinery for handling complement information, very similarly to the way our
symmetric lenses generalize asymmetric, state-based lenses. The two variants
of delta lenses are predicated on a model of edits which includes
information about the repositories themselves; this makes it difficult to
guarantee that the lenses are not traversing the repositories and causing
performance problems. Additionally, the body of work on symmetric delta
lenses does not yet include a collection of lenses which satisfy the
proposed behavioral laws, and in particular, the need for behavioral
equivalence to redress the loss of equational reasoning is not explored. The
group-based lenses seem to have the potential to address performance issues,
but it is difficult to know for sure without an instantiation of the lens
framework to particular lenses.

Matching lenses and annotation-based lenses take a complementary approach:
rather than specifying how edits should behave and trying to instantiate
those behavioral expectations with edit sets, as the previous group of
approaches did, matching and annotation-based lenses begin with a particular
representation of alignment information and build a specialized lens
framework around that representation. As a result, these two approaches are
both instantiated with a significant collection of syntax. There is no
attempt to generalize to symmetric settings here, though, and the alignment
information involved is provided in addition to the repository states, so
performance issues remain. Finally, constraint maintainers have a very
complete syntax, and address alignment by treating alignment information as
simply more repository data. This has the advantage of being a very
intuitive model, but little consideration is given to the extra properties
one would want from a repository consisting of alignment information.
Finally, it is worth noting that this is one of the only symmetric
approaches with a significant body of syntax; however, sequential
composition, a valuable tool for modular bidirectional programming, is not
supported.

\section{Graph-based delta lenses}
\label{sec:delta}
There is a closely related line of work focused on designing edit-based
lenses which begins with much the same motivation our work
does~\cite{diskin2011asymmetric,Diskin-Delta11,hermann2011correctness,Pacheco2012}.
They arrive at a slightly different point in the design space compared to
us, with a primary difference being their treatment of edits. For them,
edits are typed---with edit type $x \dedge x'$ classifying edits that can be
applied to value $x$ and result in value $x'$---and edit application is
total. Before we investigate their definitions of asymmetric and symmetric
delta lens, let us review their model of edits in detail. We will begin with
a few standard definitions to put some notation in place. Whenever possible,
we will pun notation between graphs and categories; after all, a graph with
suitable extra structure \emph{is} a category.

\begin{definition}
    A \emph{graph} $G$ is a quadruple $\left<G_0,G_1,\mldom,\mlcod\right>$
    consisting of a set of nodes $G_0$, a set of edges $G_1$, and two
    functions $\mldom,\mlcod \in G_1 \to G_0$ giving the domain and codomain
    of each edge. We will write $e:v \dedge v'$ as shorthand for the
    assertion that $e \in G_1$, that $\mldom(e)=v$, and that $\mlcod(e)=v'$.
    If the directionality of the edge is uninteresting, we will write $e:v
    \uedge v'$ to mean either $e: v \dedge v'$ or $e: v' \dedge v$.
\end{definition}

Below, we will use graphs to model edits: nodes of the graph will correspond
to repository states, and an edge $\dx : x \to x'$ will correspond to an
edit $\dx$ which, when applied to state $x$, results in state $x'$. As in
our development, it is natural to impose a little bit of structure on edges,
such as the existence of a ``do-nothing'' edit and the ability to combine
two edits into one. We introduce these restrictions separately so that we
may talk about lenses between edit models with only some of this structure.
We will also introduce a constraint that says that no matter which two
repository states you choose, there is some edit between them, which may be
an important practical consideration but does not seem to affect the theory
significantly one way or another. For the discussion of symmetric delta
lenses, we will also want to consider edits which can be ``undone''.

\begin{definition}
    Given function $f \in X \to Y$, we say $x$ and $x'$ are \emph{equivalent
    under $f$}, denoted $x \under_f x'$, when $f(x)=f(x')$.
\end{definition}

It is easy to see that $\under_f$ is an equivalence relation for any $f$.

\begin{definition}
    A graph $G$ is \emph{reflexive} if it comes equipped with a function
    $\id_G \in G_0 \to G_1$ which chooses a distinguished self loop
    $\id_{G,v} : v \dedge v$ for each node $v$. By abuse of notation, we
    will write $\id_v$ instead of $\id_{G,v}$ when there can be no confusion
    about which graph is meant.
\end{definition}

\begin{definition}
    A graph $G$ is \emph{connected} if for each $v,v'\in G_0$ there exists
    an edge $e : v \dedge v'$.
\end{definition}

\begin{definition}
    A reflexive graph $G$ is \emph{involutive} if it comes equipped with a
    function $\swoop \in G_1 \to G_1$ which associates with each edge $e : v
    \dedge v'$ an opposing edge $e\swoop : v' \dedge v$. It is required to
    be an involution (so that $e\swoop\swoop = e$) and to respect the
    reflexive structure of the graph (so that $\id_v\swoop=\id_v$).
\end{definition}

The delta lens frameworks discussed here are based on two edit models: their
asymmetric lenses are based on a connected category model of edits, and
their symmetric lenses are based on a connected involutive graph model of
edits.

In both cases, there is an underlying graph, and in particular this means
that each edit must uniquely identify the state that it can be applied to
along with the state it produces. At least naively, this requirement seems
to be in conflict with our goal of representing edits with objects
significantly smaller than the repository states. Many of our edit modules
exploit the ability to reuse edits as modifications to many different
repository states. Nevertheless, totality of edit application is a nice
feature.

The connection between edit modules and edit graphs can be made precise as
follows. To pass from a module $X$ to a graph $\Gr(X)$, let $\Gr(X)_0=|X|$
be the set of nodes and $\Gr(X)_1=\{m : x \dedge y \mid mx=y\}$ be the set
of edges (so that $\mldom(m : x \dedge y)=x$ and $\mlcod(m : x \dedge y)=y$,
hence $(m : x \dedge y) : x \dedge y$). The graph can be made reflexive by
defining $\id_x = \ONE : x \dedge x$; if we further define the composition
$(m : x \dedge y);(m' : y \dedge z)=m'm : x \dedge z$, the monoid action
laws guarantee that we can regard the graph as a category. Now let us see
how to pass from a category $G$ to a module $\Mod(G)$. (An arbitrary
reflexive graph may be turned into a category: for the arrows between nodes
$v$ and $v'$, use the set of paths from $v$ to $v'$ that do not have any
$\id$ edges\footnote{Equivalently, the set of paths quotiented by the
smallest congruence relation containing the equation that ensures that $\id$
edges are the unit for composition: $\blist \id \elist = \NIL$.}; for the
composition, use path concatenation; and for the identities, use empty
paths.) Let the values $|\Mod(G)|=G_0$ be the set of nodes, and edits $\D
\Mod(G)=G_1\LIST/{\sim}_;$ be the set of paths quotiented by the congruence
relation that identifies factorable paths $\blist f;g \elist$ with the
factoring $\blist g \mlist f \elist$. In other words, the edits of $\Mod(G)$
are sequences of edges $\blist g_1 \clist g_n \elist$ which are \emph{not}
well-typed: $\mlcod(g_{i+1}) \ne \mldom(g_i)$ for each $i$. (One can further
identify all lists of length more than one---that is, lists that have an
internal typing error---with a single $\fail$ edit. The result is still a
module, but the lens lifting we perform below would not result in a lens:
the monoid homomorphism laws may require some ill-typed compositions in the
source to be translated to well-typed compositions in the view.)
The empty list serves as the identity. Edit application is generated by the
equation $\dx \odot_g x = x'$ when $\dx : x \dedge x'$ (and undefined
otherwise). One may choose any object to play the role of $\init$ (so that
there are as many ways to turn a category into a module as there are objects
in the category). Passing from a category to a module and back adjoins a
fresh identity edit to each object, but otherwise leaves the category
unchanged. On the other hand, passing from a module to a category and back
may produce a significantly more verbose edit language, even after
accounting for the many ways to represent internal failure: each edit $m$ in
the source module induces a collection of edits $\{\blist m : x \dedge
y\elist \mid mx = y\}$ in the target module.

The involutive graph model of edits demands the existence of undo edits,
something we did not consider carefully in the edit lens framework above. A
suitable module-based analog of the typed involution would be to require
each module to include an untyped involution $\swoop$ such that
$(\dx\swoop\;\dx)\odot x=x$ whenever $\dx\odot x$ is defined. (Thus
$\dx\swoop\;\dx$ is a restricted identity: not necessarily equal to $\ONE$,
but behaves like it for some subset of the values being edited.) Many of the
modules and module combinators we have defined above can be equipped with
this structure. A notable few that cannot include edit operations which
actually delete information, such as the sum module's $\ml{switch}$ edits
and the list module's $\mldelete$ edits. These edits would need to be
enriched or restricted to include the information being deleted; for
example, one could modify the action associated with $\mldelete$ edits to
only succeed when the list elements being deleted were $\init$ (so that
edits which wish to delete an element must first modify it to being $\init$
with $\mlmodify$ edits), and one could enrich the $\ml{switch}$ edits with
an edit that returns the value to a tagged $\init$ before switching sides of
the sum. Thus in general it seems that requiring an ``undo'' ability can
require mildly larger edit operations.

With these considerations about edits in mind, let us discuss how to
generalize asymmetric, state-based lenses first to asymmetric delta lenses
and then to symmetric delta lenses.

\subsection{Asymmetric}
\label{sec:delta:asymmetric}
Now, let us take the edit model above and see how to enrich asymmetric
lenses to take edit information rather than states. As with the state-based
version, we will assume that there is strictly more information in the
source category $S$ than in the view category $V$. This means that in the
\GET direction, it seems natural to assume that each source edit $\ds : s
\dedge s'$ uniquely determines a view edit $\dv : v \dedge v'$ by ``throwing
away'' the extra information. It is also quite natural to require this \GET
transformation to respect the category structure in $S$: that is, we should
expect $\aget(\id)=\id$ and $\aget(\ds;\ds')=\aget(\ds);\aget(\ds')$.
Together, these say that $\aget$ is a functor from $S$ to $V$.

As with all asymmetric frameworks, the \PUT direction is a bit more
delicate, because it needs to restore missing information. Suppose we have a
view edit $\dv : v \dedge v'$ and wish to produce a source edit. It seems
natural to wish that the source edit we produce respects typing in the sense
that if we produce $\ds : s \dedge s'$, then $s$ is in the preimage of $v$
and $s'$ is in the preimage of $v'$. But this is still very unconstrained;
in particular, since there really is a particular $s_0$ which is currently
in synch with $v$, we really want to produce an edit $\ds$ whose domain is
$s_0$---that is, there is simply not enough information available in a view
edit to produce a reasonable translation function \PUT. So we cannot
translate directly from a view edit to a source edit; however, the key
insight of this line of work is that we can translate from a view edit to a
\emph{family} of source edits indexed by the source that is currently
synchronized with the view.

In detail, given an object mapping $\aget_0 \in S_0 \to V_0$, we can
construct the preimage category $S/\aget_0$ as follows. The objects of
$S/\aget_0$ are the equivalence classes of objects of $S$ under
$\under_{\aget_0}$. The arrows $f : [s_i] \dedge [s_o]$ are the functions
which take an element $s \in [s_i]$ and produce an arrow $f(s) : s \dedge
s'$ for some $s' \in [s_o]$. The identity arrow is the one which associates
to each $s$ the arrow $\id_s$; the composition is defined by
$(f;g)(s)=f(s);g(\mlcod(f(s)))$. When $\aget$ is a graph morphism, we will
write $S/\aget$ as shorthand for $S/\aget_0$. With this category in hand, we
are ready to define asymmetric delta lenses.

\begin{definition}
    A \emph{graph morphism} $f \in S \to V$ between graphs $S$ and $V$ is a
    pair $\left<f_0,f_1\right>$ of mappings $f_0 \in S_0 \to V_0$ and $f_1
    \in S_1 \to V_1$ such that $f_1(e) : f_0(\mldom(e)) \dedge
    f_0(\mlcod(e))$.
\end{definition}

\begin{definition}
    A \emph{semifunctor} $f \in S \to V$ between reflexive graphs is a graph
    morphism for which $f_1(\id_s)=\id_{f_0(s)}$.
\end{definition}

\begin{definition}
    An \emph{asymmetric delta lens} $\ell \in S \adlens V$ between connected
    categories $S$ and $V$ is a pair $\left<\aget,\aput\right>$ of graph
    morphisms $\aget \in S \to V$ and $\aput \in V \to S/\aget$. The lens is
    \emph{well behaved} (respectively, \emph{very well behaved}) if $\aget$
    and $\aput$ are semifunctors (resp. functors) and satisfy the behavioral
    law:
    \infax[ADPutGet]{\aget(\aput(\dv)(s))=\dv}
    We will abbreviate ``well behaved asymmetric delta lens'' to ``\WBADL''
    and ``very well behaved asymmetric delta lens'' to ``\VWBADL''.
\end{definition}

The suggested behavioral law enforces the intuition given above that all of
the information available in the view edits is available in source edits,
too. It turns out that the obvious definitions for identity and composition
lenses satisfy the behavioral law and induce a category whose objects are
connected categories and arrows are \VWBADLs. As in our discussion above
relating edit lenses to symmetric lenses, one can connect \WBADLs to
asymmetric state-based lenses by adjoining an operation to compute the
difference between two states. The paper goes on to show that \VWBADLs only
violate the controversial \rn{PutPut} law if their differencing operation
violates a similar \rn{DiffDiff} law---that is, failure is never due to
incorrect edit propagation, only incorrect edit discovery.

One can construct an edit lens out of a \VWBADL as follows. The complement
set will be source objects adjoined with a fresh $\fail$ value, so that the
partial edit application can be extended to a total one with explicit
failure:
\begin{align*}
    \ds \odot_t \mlinl s &= \mlinl {\ds \odot s} & \ds\odot s\Defined \\
    \ds \odot_t s &= \mlinr \fail & \mbox{otherwise}
\end{align*}
Then the lens construction goes as follows.
\lensdef{delta_symmetrize}
    {\infruleplain
        {\ell \in S \adlens V \qquad \ell\mbox{ is a \VWBADL} \qquad s \in S_0}
        {\mlsymm_s(\ell) \in \Mod(S) \dlens \Mod(V)}
    }
    {
        C &=& S_0 \uplus \{\fail\} \\
        \missing &=& \mlinl s \\
        K &=& \{(s,\mlinl s,\ell.\aget_0(s)) \mid s \in S_0\} \\
        \dputr_g(\ds, s) &=& (\ell.\aget_1(\ds),\ds\odot_t s) \\
        \dputl_g(\dv, \mlinl s) &=& \mllet \ds = \ell.\aput_1(\dv)(s) \mlinm (\ds, \ds\odot_t \mlinl s) \\
        && \mbox{when }\mldom(\dv)=\ell.\aget_0(s) \\
        \dputl_g(\dv, s) &=& (\ONE,\mlinr \fail) \mbox{ otherwise}
    }
The proof that this is well-defined and forms a lens is tedious but
straightforward. It relies critically on $\ell.\aget$ and $\ell.\aput$
respecting arrow composition and on the object part of the roundtrip law,
but not that $\ell.\aget$ and $\ell.\aput$ respect identities (because we
introduce a fresh identity) or that they roundtrip on arrows (as our
formalism does not have an analogous law). We conjecture that a construction
similar to the one used to decompose symmetric lenses into a pair of
asymmetric, state-based lenses can be used to decompose edit lenses into a
pair of \VWBADLs.
% TODO: could try to flesh out this conjecture a bit

Later work proposes a concrete edit model and a collection of \WBADLs and
combinators~\cite{Pacheco2012}. In addition to the above definition of
\WBADLs, they give a proposal for a framework of \emph{horizontal delta
lenses} which are more convenient to implement but whose behavioral
guarantees are less intuitive. Horizontal delta lenses are nevertheless
suitably constrained so that they can be converted into \WBADLs as
necessary. Their data model is based on containers, with edits containing
(in part) an injective relation between the positions of the old and new
pieces of data. In addition to many constructions similar to ours, they also
discuss fold and unfold operations for containers that are built from
fixpoints of regular higher-order functors. These give rise to significant
complications in handling the full range of edits; they discuss how to
handle insertions and deletions of nodes, but do not discuss reordering.
Unlike our development, all repositories are homogeneous containers; in
particular, their tensor product analog restricts the contained values in
the two parts of the tuple to have identical types.
% TODO: REW suggests: This is a lot of detail in the summary, but does not
% relate explicitly how this type of approach satisfies or does not satisfy
% your four criteria:  alignment, symmetry, performance, syntax.  Somehow,
% the reader needs to be reminded what all of this means in that context.
% [and similar comments at the end of all the other sections]

\subsection{Symmetric}
\label{sec:delta:symmetric}
Diskin et al. also spend some effort considering what machinery is needed to
support transformations between domains that each have missing
information---that is, symmetric transformations~\cite{Diskin-Delta11}. As
we observed in our symmetric lens development, passing from asymmetric to
symmetric lenses is cleanest if one introduces a complement---some extra
information about how the values in the two repositories correspond. Their
development similarly allows for extra information, with a little bit of
extra notational complexity arising from the pervasive use of typing: edits
are typed via a category, as discussed above, and complements are also
typed, as we discuss now. Because complements are typed, we will need a
notion of when the types of an edit and a complement match. We give two such
notions below: one for complements that match before an edit is applied, and
one for complements that match after.

\begin{definition}
    Given graphs $G$ and $H$, we define the \emph{domain-} and
    \emph{codomain-coincident} edge pairings as follows:
    \begin{align*}
        G \domco H &= \{(e_g,e_h) \mid e_g : v \dedge v' \in G_1 \land e_h :
        v \uedge v'' \in H_1\} \\
        G \codco H &= \{(e_g,e_h) \mid e_g : v \dedge v' \in G_1 \land e_h :
        v' \uedge v'' \in H_1\}
    \end{align*}
\end{definition}

\begin{definition}
    A \emph{symmetric delta lens} $\ell$ connecting connected categories $X$
    and $Y$, written $\ell \in X \sdlens Y$, consists of:
    \begin{itemize}
        \item a bipartite graph $R$ whose two parts are $X_0$ and $Y_0$ (the
            edges of $R$ are called \emph{correspondence relations}),
        \item a function $\mlfppg \in X \domco R \to Y_1 \times R_1$,
            and
        \item a function $\mlbppg \in Y \domco R \to X_1 \times R_1$.
    \end{itemize}
    We will write $\mlfppg_1$ and $\mlfppg_2$ (and similarly for $\mlbppg$)
    for the $Y_1$ and $R$ parts of $\mlfppg$'s output, respectively.
\end{definition}

The preconditions for $\mlfppg$ above stating that the edit and
correspondence relations are domain-coincident is somewhat similar to our
precondition requiring an edit which applies cleanly. The bipartite graph
$R$ plays a similar role to our consistency relations: if there is an edge
$r : x \uedge y$, then we can think of $r$ as being a (typed) complement
that is consistent with states $x$ and $y$.

A major contribution of this line of research is an exploration of
behavioral guarantees that reasonable symmetric delta lenses might offer.
The obvious laws are too strong; but the insight of this development is that
if we take the obvious laws and replace equalities by a slightly coarser
equivalence relation, we get laws that are much more plausible. The core of
the problem is that equality on $X$ edits distinguishes between edits that
modify information not available in $Y$; we would prefer a relation that
compares only the parts of the edit that affect the shared information.
At first it seems difficult to define ``shared information'' formally, but
lenses are exactly transformations that define what information is shared;
so the relation is parameterized by a lens.

\begin{definition}
    Given symmetric delta lens $\ell \in X \sdlens Y$ and a correspondence
    relation $r : x \uedge y$ for $\ell$, we define equivalence relations on
    edits to $x$ and $y$, respectively:
    \begin{align*}
        \eqsharedl*\ell r &={} \under_{\lambda \dx.\;\ell.\mlfppg_1(\dx,r)} \\
        \eqsharedr*\ell r &={} \under_{\lambda \dy.\;\ell.\mlbppg_1(\dy,r)}
    \end{align*}
    When the lens is understood from context, we will write $\dx\eqsharedl
    r\dx'$ instead of $\dx\eqsharedl*\ell r\dx'$ (and similarly for
    $\dy\eqsharedr r\dy'$).
\end{definition}

Armed with this notation, they propose several possible restrictions that
one could place on symmetric delta lenses. The first two restrictions are
analogous to ones discussed in our work above. Like our demand that
applicable edits get translated to applicable edits that restore
consistency, rule \rn{SDWellTyped} below demands that the edits and
correspondence relations involved in an invocation of $\mlfppg$ form a
well-typed square. They also demand that the propagation functions preserve
the self-loop structure of the edit graphs via the \rn{SDId} rule.
\infrule[SDWellTyped]
    {\mlfppg(\dx,r) = (\dy,r')}
    {r  : \mldom(\dx) \uedge \mldom(\dy) \\
     r' : \mlcod(\dx) \uedge \mlcod(\dy)}
\infrule[SDId]{r : x \uedge y}{\mlfppg(\id_x,r)=(\id_y,r)}

The edit graphs have another kind of structure given by the $\swoop$
undo operation. One might hope that this structure is preserved in a similar
way; for example, a rule like \rn{SDFUndo-Strong*} seems reasonable at first
blush.
\infrule[SDFUndo-Strong*]
    {\mlfppg(\dx,r)=(\dy,r')}
    {\mlfppg(\dx\swoop,r')=(\dy\swoop,r)}
Unfortunately, this rule is very restrictive. Suppose the $Y$ side of the
lens were to store some information not available in the $X$ side, and
propagating $\dx$ produces a $\dy$ that deletes some of that information.
Then this information could not be restored from the information in
$\dx\swoop$\footnote{One could imagine storing just enough information in
the correspondence relations to allow undoing one operation. Perhaps this
could be made to work, but it is unlikely this would scale well in
situations where there are composite edits (and hence composite undos).}.
One way to weaken this law to something more plausible would be to demand
that we output something that behaves like $\dy\swoop$ on the shared
information; that is, by weakening the equality in the conclusion to our
coarser equivalence relation from above:
\infrule[SDFUndo]
    {\mlfppg(\dx,r)=(\dy,r')}
    {\mlfppg_1(\dx\swoop,r') \eqsharedr{r'} \dy\swoop}

The fourth and final behavioral law proposed demands that the edit
propagation functions be near inverses: that is, if we propagate $\dx$ to
$\dy$, then the corresponding edit determined by the other propagation
function should be $\dx$. As stated, this law is again too strong, because
some of the modifications described by $\dx$ are to unshared data, and hence
are not available in $\dy$ during re-propagation. As before, we can make the
rule more reasonable by weakening from equality to equivalence:
\infax[SDInvertible]{\mlbppg_1(\mlfppg_1(\dx,r),r)\eqsharedl r\dx}
This behavioral law is called a roundtrip law in their development, but that
name is a little misleading, as the update to the $y$ value and the updated
correspondence relation are discarded before applying the $\mlbppg$
function. (It is as if two separate people happened to take flights that
crossed paths in the middle, rather than a single person taking a round
trip.) We will instead call this law a \emph{triple-trip} law---for the two
trips evident in the law plus one trip hidden by the equivalence relation.

The line of research goes on to describe other theoretical
frameworks with interfaces closer to what an end-user programmer might want
to implement that can give rise to symmetric delta lenses. In particular,
they describe a framework they call \emph{consistency
maintainers}~\cite{Diskin-Delta11} which include explicit alignment and
consistency-restoration phases as well as explore conditions under which a
triple-graph grammar can be used to produce a law-abiding
lens~\cite{hermann2011correctness}. No concrete instantiations are given for
any of the three frameworks. We have found that undertaking this endeavor is
a valuable crucible in which to test prospective frameworks, as the design
of a lens language makes a mismatch between behavioral laws and actual
behavior much more clear. (Just as a good framework helps to spot
potential implementation bugs, an implementation helps point out potential
framework bugs.) In particular, sequential composition---in our experience,
a crucial tool for building practical lenses---is not considered, and the
ensuing need for a notion of lens equivalence is not addressed.

The proposed \rn{SDInvertible} and \rn{SDFUndo} laws seem on the surface to
be quite natural restrictions. Our development does not have analogous laws,
and it seems that including them would necessitate a stronger equational
theory for many of the modules proposed above. Exploring the consequences of
these laws could be an interesting avenue for future work on edit lenses.

\section{Comma category lenses}
\label{sec:clenses}
% TODO: the chapter summary at the beginning needs a sentence about these
Johnson, Rosebrugh, and Wood independently developed a lens framework with a
very similar flavor to asymmetric delta lenses%
~\cite{Johnson11,johnson2013delta,johnson2001view,johnson2012lens}. Like the
asymmetric delta lens framework, the \emph{comma category lens} (henceforth
\emph{C-lens}) framework is based on a category whose objects are meant to
model states and whose arrows are meant to model edits. However, for
C-lenses, the category's arrows are not intended to span all possible edits,
as we will see, but only those edits which model ``insertions''. Handling
edits which model deletions and support composition requires significant
extra machinery. Before defining what a C-lens is, we will review the
definition of a comma category; the $\aput$ of a C-lens will map objects in
the comma category representing an edit to a view tagged with the source the
original view came from to objects in the source category representing an
updated source.

\begin{definition}
    Given a functor $\aget \in S \to V$, we can form the comma category
    $\aget\comma\id_V$ as follows:
    \begin{itemize}
        \item Objects are pairs $(s,\dv : \aget(s) \to v)$ of an object $s$ of
            $S$ and an arrow $\dv$ of $V$.
        \item Arrows are pairs $(\ds,\dv)$ of an arrow $\ds : s \to s'$ from $S$
            and an arrow $\dv : v \to v'$ from $V$ that forms a commuting
            square:
            \begin{diagram}
                \commaarrowpathdef
            \end{diagram}
        \item The identity arrows are pairs $(\id,\id)$ of appropriate
            identities from $S$ and $V$, and composition corresponds to
            diagram pasting, so that $(\ds, \dv); (\ds', \dv') = (\ds;
            \ds', \dv; \dv')$.
    \end{itemize}
\end{definition}

We are now ready for the main definition, which establishes the behavioral
laws that C-lenses must satisfy.

\begin{definition}
    A \emph{C-lens} $\ell \in S \clens V$ between categories $S$ and $V$ is
    a pair $\left<\aget,\aput\right>$ of functors $\aget \in S \to V$ and
    $\aput \in V \to \aget\comma\id_V$ satisfying the behavioral laws:
    \infax[CPutGet]{\aget\left(\aput\left(\commaarrowdef\right)\right) = \dv}
    \infax[CGetPut]{\aput\left(\commaarrow s{\aget(\id)}{\aget(s)}{s'}{\aget(\id)}{\aget(s')}\ds{\aget(\ds)}\right)=\ds}
    \infrule[CPutPut]
        {\aput\left(\commaarrow s{\dv_\mldom}v{s'}{\dv_\mlcod}{v'}\ds{\dv}\right)=p : t \to t' \\
         \aput\left(\commaarrow t{\dw_\mldom}w{t'}{\dw_\mlcod}{w'}{p}{\dw}\right)=p' : u \to u'
        }
        {
        \aput\left(\commaarrow s{\dv_\mldom;\dw_\mldom}w{s'}{\dv_\mlcod;\dw_\mlcod}{w'}\ds\dw\right)
        =
        p'
        }
\end{definition}

The three behavioral laws may seem daunting at first, but the bulk of their
character can be understood by considering their implications on the
behavior of $\aget$ and $\aput$ on objects (which is induced by
functoriality). For example, on objects, \rn{CPutGet} says
$\aget(\aput(\dv : \aget(s) \to v))=v$, that is, if we update the view to $v$,
then the resulting updated source corresponds via $\aget$ to $v$. This is
somewhat like our behavioral law which requires translated edits to move
from consistent triples to consistent triples. On objects, \rn{CGetPut} says
$\aput(\id : \aget(s) \to \aget(s)) = s$, that is, if we do not change the
view, the source also does not change, much like our behavioral law
requiring the identity edit to be translated to the identity edit. Finally,
\rn{CPutPut}, when restricted to objects, is about translating two edits at
once: the computation $\aput(\dv;\dv' : \aget(s) \to v'')$ should have the same
result as computing $\aput(\dv : \aget(s) \to v')$ (producing a source state
$s'$ for which $\aget(s')=v'$) and then $\aput(\dv' : \aget(s') \to v'')$. This is
quite similar in flavor to our law requiring that edit translations respect
the edit monoid's binary operator structure. The latter two laws, while
having a very strong functorial flavor---they prescribe the behavior of
$\aput$ on identity and composition edits---are independent of the
requirement that $\aput$ be a functor. The distinction is that the functor
laws prescribe the behavior when the horizontal arrows are identities or
compositions, while the behavioral laws prescribe the behavior when the
vertical arrows are identities or compositions.

A major result of the work is that these behavioral laws have a hidden
consequence: in a certain strong sense, the edits output by $\aput$ are
\emph{minimal}.
% TODO

\section{Algebraic rephrasing}
\label{sec:algebraic}
% TODO: Do we need to mention somehow that this is a continuation of the
% (similarly-algebraically-motivated) exploration of state-based lenses in
% the 2007 Stevens paper that's cited elsewhere?
There is a line of work on algebraic foundations for delta lenses that
arrives at a model very similar to the edit lens framework described
above~\cite{stevens2008tat}. They consider, as we do, edit monoids together
with edit translation morphisms and (total) edit application actions.
One significant difference is that they consider generalizing asymmetric
rather than symmetric lenses, adopting correspondingly modified behavioral
laws. In particular, in their setting, a delta lens is a \emph{lens-like
split short exact sequence}. Below we discuss each of these restrictions in
right-to-left order. We begin with two standard definitions to establish
some notation.

\begin{definition}
    The \emph{image} of a function $f \in X \to Y$ is the set of elements
    $\im(f) \subset Y$ that $f$ can output:
    \[\im(f) = \{f(x) \mid x \in X\}\]
\end{definition}

\begin{definition}
    The \emph{kernel} of a monoid homomorphism $f$, denoted $\ker(f)$, is
    the preimage of $\ONE$:
    \[\ker(f) = \{x \mid f(x) = \ONE\}\]
\end{definition}

\begin{definition}
    An \emph{exact sequence} is a sequence $\blist f_1 \clist f_n \elist$ of
    monoid morphisms with compatible domains and codomains, that is,
    \begin{diagram}
        \path
            node                      (0)    {$X_0$}
            node[right=2.5em of 0]    (1)    {$X_1$}
            node[right=2.5em of 1]    (2)    {$X_2$}
            node[right=2.5em of 2]    (dots) {$\cdots$}
            node[right=2.5em of dots] (n2)   {$X_{n-2}$}
            node[right=2.5em of n2]   (n1)   {$X_{n-1}$}
            node[right=2.5em of n1]   (n0)   {$X_n$}
            (0)    edge[->] node[above] {$f_1$}     (1)
            (1)    edge[->] node[above] {$f_2$}     (2)
            (2)    edge[->] node[above] {$f_3$}     (dots)
            (dots) edge[->] node[above] {$f_{n-2}$} (n2)
            (n2)   edge[->] node[above] {$f_{n-2}$} (n1)
            (n1)   edge[->] node[above] {$f_n$}     (n0)
        ;
    \end{diagram}
    and such that $\im(f_i)=\ker(f_{i+1})$ for each $i$.
\end{definition}

\begin{definition}
    An exact sequence is \emph{short} if it has four morphisms and starts
    and ends at $\D\Unit$:
    \begin{diagram}
        \path
            node                   (1-1) {$\D\Unit$}
            node[right=4em of 1-1] (K)   {$K$}
            node[right=4em of K]   (X)   {$\DS$}
            node[right=4em of X]   (Y)   {$\DV$}
            node[right=4em of Y]   (1-2) {$\D\Unit$}
            (1-1) edge[->] node[above] {$i$} (K)
            (K)   edge[->] node[above] {$k$} (X)
            (X)   edge[->] node[above] {$f$} (Y)
            (Y)   edge[->] node[above] {$s$} (1-2)
            ;
    \end{diagram}
    We will say \emph{around} to mean the third element of a sequence, as
    in, ``$\blist i \mlist k \mlist f \mlist s \elist$ is a short exact
    sequence around $f$.''.
\end{definition}

Before we define what split and lens-like mean, let us consider when an
edit translation homomorphism $f \in \DS \to \DV$ may be extended to a short
exact sequence. The homomorphism $s \in \DV \to \D\Unit$ must be the
constantly-$\ONE$ function (there are no other functions with that type), so
that its kernel is $\ker(s)=\DV$. Hence the restriction $\im(f)=\ker(s)$ that
arises from extending the sequence to the right says that $f$ must be
surjective. On the other hand, the sequence may always be extended to the
left by choosing $K$ to be the submonoid $\ker(f)$ and $k$ to be the
inclusion function. (The homomorphism $i$ is completely determined by the
homomorphism laws once we have chosen a monoid $K$: it must map the sole
input element $\ONE_{\D\Unit}$ to $\ONE_K$.) Other choices for $K$ are
possible---for example, by adding a fresh generator to $K$ that $k$ maps to
any non-trivial element of $\DS$---but we will not be interested in this
ability below.

In lens terms, one should think of $f$ as being an edit-lens analog of the
asymmetric lens framework's \GET function. Giving a short exact sequence
amounts to identifying an edit translation function $f\in\DS\to\DV$ that is
compatible with the monoid structure on edits and such that each $V$-edit
has at least one analogous $S$-edit.

\begin{definition}
    A short exact sequence around $f\in\DS\to\DV$ is said to \emph{split} if
    there is a homomorphism $g\in\DV\to\DS$ such that $g;f = \id_{\DV}$.
\end{definition}

We are guaranteed that there is a \emph{function} $g$ by the fact that $f$
is surjective, but not guaranteed that any such function is a monoid
homomorphism. If we do have such a homomorphism $g$ that splits the
sequence, then in lens terms we should consider that $g$ to be an edit-lens
analog of the \PUT function. Then $g;f = \id_{\DV}$ says that all the
information available in $V$-edits are also available in $S$-edits, an
analogous restriction to the one on state-based lenses that says that all
the information available in the view repository is available in the source
repository.

The final condition placed on this variant of delta lenses is that they be
lens-like. Thus far, all the conditions have been purely in terms of edits;
this final pair of properties connect the world of edits and the world of
states. This is similar to the edit lens law that requires $\dputr$ and
$\dputl$ to respect a consistency relation on states.

\begin{definition}
    A monoid action $\odot \in \DX \times |X| \to |X|$ is \emph{transitive}
    if for all $x,x' \in |X|$ there is $\dx \in \DX$ such that $\dx\odot
    x=x'$. We will say a module is transitive when its action is.
\end{definition}

\begin{definition}
    A short exact sequence around $f\in\DS\to\DV$ split by $g$ is
    \emph{lens-like} if it comes equipped with transitive, total modules for
    $\DS$ and $\DV$ such that two conditions hold:
    \infrule[LL1]
        {\ds\;\init_S = \ds'\;\init_S}
        {f(\ds)\;\init_V = f(\ds')\;\init_V}
    \infrule[LL2]
        {\dv\;f(\ds)\;\init_V = f(\ds)\;\init_V}
        {g(\dv)\;\ds\;\init_S = \ds\;\init_S}
\end{definition}

Rule \rn{LL1} amounts to saying that $f$ is (part of) a module homomorphism
(not just a monoid homomorphism). Rule \rn{LL2} is a bit more subtle, but is
motivated by this rephrasing of the state-based asymmetric lens framework's
\rn{GetPut} law:
\infrule[GetPutAlt]
    {\aget(s)=v}
    {\aput(v,s)=s}
Rule \rn{GetPutAlt} says, roughly, ``If the view $v$ has not changed since
the last synchronization, then the source $s$ should not change, either.''.
Similarly, \rn{LL2} says, roughly, ``If the edit we are about to translate
does not change the view $f(\ds)\;\init_V$, then the edit we output should
not change the source $\ds\;\init_S$.''.

That work goes on to explore the properties of this kind of delta lens. One
can take a lens-like sequence around $f\in\DS\to\DV$ equipped with an
operation to compute differences, denoted $\dif\in|S|\times|V|\to\DV$ and
satisfying an obvious sanity condition, and produce an asymmetric,
state-based lens. Additionally, there is a close relationship between
demanding the existence of inverse edits---that is, working with edit groups
rather than edit monoids---and the \rn{PutPut} asymmetric lens law:
\infax[PutPut]{\aput(v,\aput(v',s))=\aput(v,s)}
They show that one can define suitably restricted submonoids $\DV \subset V
\to V$ and $\DS \subset S \to S$ and lift \rn{PutPut}-abiding asymmetric
lenses into a lens-like sequence on groups. Furthermore, the two
translations agree with each other: converting a lens to a lens-like
sequence and back is the identity transformation, regardless of the choice
of $\dif$ operation in the latter transformation.

The primary difference between their work and ours is that they consider
only asymmetric situations. However, they also consider many fundamentally
different restrictions than the current development does, even after
accounting for the different setting. For example, they propose a law
requiring that when $g$ splits a sequence around $f$ we additionally have
$g;f=\id$. Since $f$ is surjective, this is the same as demanding $f;g;f=f$,
akin to Diskin's proposed triple-trip law discussed above. As mentioned in
that discussion, it is not a law that we have considered carefully; but it
seems we may be able to achieve something similar in many of the lenses we
defined by introducing appropriate equalities to our edit monoids for
structured data. The paper also spends some time discussing the
ramifications of demanding an edit group rather than an edit monoid. We have
not explored this restriction deeply, but some cursory investigations
suggest that including enough information to undo each operation may be at
odds with the size benefits promised above. Another restriction they have
throughout their development is that their edit application actions are
invariably total. We believe that partiality of these actions is an
important real-world consideration. Treating it carefully allows us to
distinguish between error conditions and edits which successfully do
nothing, and to give a guarantee that our lenses do not spuriously turn a
succesful nothing into an error condition.

They also treat backwards-compatibility with asymmetric, state-based lenses
very seriously, which gives rise to their lens-like restrictions.  Their
rule \rn{LL1} stating that the \GET direction is a module homomorphism can
be seen as saying that edit translation is consistent with state
translation.  Our demand that the edit translations preserve a consistency
relation can be seen as a generalization of this. On the other hand, their
rule \rn{LL2}---necessary to ensure that their delta lenses behave like
state-based lenses regardless of $\dif$ operation---seems quite strong. The
goal appears to be to preserve the state-based behavior that changing
nothing on one side changes nothing on the other; however, it is our view
that demanding that the distinguished do-nothing edit from one module be
translated to the distinguished do-nothing edit from the other module
already captures this intuition. There are edits which appear to do nothing
to a given view but which nevertheless have semantic content, and should
therefore be allowed to be distinguished by a lens. Consider the example of
Figure~\ref{fig:school-salaries} again, reproduced here as
Figure~\ref{fig:school-salaries-delins}. An edit which deletes the last
element of the secretary's view, then inserts a fresh element with value
``Mary Jones'', apparently does nothing to the current view. Nevertheless,
it seems quite natural\footnote{Possibly even desirable---an obviously
incorrect value is often preferable to a plausible incorrect value.} for the
translation of this edit to reset the salary associated with ``Mary Jones''
to a default value; a rule like \rn{LL2} would prevent lenses from having
this kind of nuanced behavior.

\begin{figure}
    \begin{minipage}{0.5\linewidth}
        \centering
        \begin{tabular}{lr}
            Teacher name & Salary \\
            \hline
            Sam Rickard & 57,000 \\
            Jon Jacobs & 50,000 \\
            Mary Jones & 65,000 \\
        \end{tabular}
        \subcaption{HR's view}
        \label{fig:school-salaries-delins-hr}
    \end{minipage}%
    \begin{minipage}{0.5\linewidth}
        \centering
        \begin{tabular}{l}
            Teacher name \\
            \hline
            Sam Rickard \\
            Jon Jacobs \\
            Mary Jones \\
        \end{tabular}
        \subcaption{A secretary's view}
        \label{fig:school-salaries-delins-sec-pre}
    \end{minipage}%
    \caption{A school's staff list, as seen by HR and by the principal's secretary}
    \label{fig:school-salaries-delins}
\end{figure}

Finally, our development includes significantly more effort instantiating
the lens framework to particular lenses and lens combinators. We believe
that this is good evidence that our behavioral restrictions are relaxed
enough to accomodate important use cases; nevertheless, they were strict
enough to prevent many genuinely undesirable behaviors in early proposals
for these combinators (not documented here).

% TODO: notation correspondence
% our \D\Unit is their 1
% our \init is their \Omega
% we use f and g for a split sequence; they use \mu and \lambda
% we use \ds and \dv for edits, they use g
% we say \dif operation; they say oracle

\section{Matching lenses}
\label{sec:matching}
Dictionary lenses~\cite{Boomerang07} and their sequel, matching
lenses~\cite{Matching10}, are also motivated by the alignment problems
discussed above. We will consider a variation of our motivating example from
Chapter~\ref{chap:introduction} which showcases a particularly annoying
example of bad alignment---annoying both because it is a common scenario and
because it seems especially clear how to get the right answer.
Figure~\ref{fig:school-salaries-keys} shows again the bad behavior of
positional alignment. Gray annotations mark changes with respect to a
previous version of a given repository. The salary column of the updated
source repository is marked in red because it has been misaligned with the
updated view: the names have been shuffled, but the salaries have not.

\begin{figure}
    \begin{diagram}
        \draw
            node[tabular, hline] (S) {
                Teacher name & Salary & Room \\
                Sam Rickard & 57,000 & 314 \\
                Jon Jacobs & 50,000 & 108b \\
                Mary Jones & 65,000 & 109 \\
            }
            (S.north east) +(2, 0)
            node[matrix anchor=north west, tabular, hline] (V) {
                Teacher name & Room \\
                Sam Rickard & 314 \\
                Jon Jacobs & 108b \\
                Mary Jones & 109 \\
            }
            (V.south) +(0, -1)
            node[matrix anchor=north, tabular, hline] (V') {
                Teacher name & Room \\
                Jon Jacobs & 108b \\
                Mary Jones & |[fill=lightgray]| 111 \\
                Sam Rickard & 314 \\
            }
            (S |- V')
            node[tabular, hline] (S') {
                Teacher name & Salary & Room \\
                Jon Jacobs  & |[darkred]| 57,000 & 108b \\
                Mary Jones  & |[darkred]| 50,000 & |[fill=lightgray]| 111 \\
                Sam Rickard & |[darkred]| 65,000 & 314 \\
            }

            ($(V'-2-2.east |- V'-2-2.east) +(0.5em,0)$) edge[reorder, bend left=60] ($(V'-2-2.east |- V'-4-2.east) +(0.5em,0)$)
              (V'-2-2.east |- V'-3-2.east)              edge[reorder, bend right]     (V'-2-2.east |- V'-2-2.east)
              (V'-2-2.east |- V'-4-2.east)              edge[reorder, bend right]     (V'-2-2.east |- V'-3-2.east)

            ($(S'-2-1.west) +(-0.5em,0)$) edge[reorder, bend right=60] ($(S'-4-1.west) +(-0.5em,0)$)
              (S'-3-1.west)               edge[reorder, bend left]       (S'-2-1.west)
              (S'-4-1.west)               edge[reorder, bend left]       (S'-3-1.west)

            (S)  edge[->] node[above] {\GET}                    (V)
            (V)  edge[->] node[right] {\tiny user modification} (V')
            (V') edge[->] node[below] {\PUT}                    (S')
            (S.east) +(0, -1ex) edge[bend left=90] (S'.east)
            ;
    \end{diagram}
    \caption{An easily fixed misalignment}
    \label{fig:school-salaries-keys}
\end{figure}

The observation of dictionary lenses is that the teacher names in the view
repository act somewhat like a key: the reordering that the user did can be
recovered by comparing the order of names before and after the modification.
Experience with lens programming shows that the existence of a key is fairly
common, so merely giving the programmer the ability to specify which parts
of the data correspond to keys can improve the \PUT behavior in a wide range
of applications. However, there is an unfortunate behavioral regression:
with positional alignment, changing a key is handled gracefully, but with a
dictionary lens, a changed key results in a loss of any associated
information. Figure~\ref{fig:school-salaries-key-change} gives an example of
a dictionary lens resetting a salary that a plain lens would preserve. The
observation here is that simple key equality is too strict. Matching lenses
relax this restriction; they parameterize lenses by an alignment
strategy---which can do arbitrary computation---that computes how chunks of
the old and new copies of the repository correspond. Several heuristics that
satisfy the interface of an alignment strategy are given, for example, for
computing the least-cost alignment according to some function that computes
the cost of a single-chunk change.

\begin{figure}
    \begin{diagram}
        \draw
            node[tabular, hline] (S) {
                Teacher name & Salary & Room \\
                Sam Rickard & 57,000 & 314 \\
                Jon Jacobs & 50,000 & 108b \\
                Mary Jones & 65,000 & 109 \\
            }
            (S.north east) +(2, 0)
            node[matrix anchor=north west, tabular, hline] (V) {
                Teacher name & Room \\
                Sam Rickard & 314 \\
                Jon Jacobs & 108b \\
                Mary Jones & 109 \\
            }
            (V.south) +(0, -1)
            node[matrix anchor=north, tabular, hline] (V') {
                Teacher name & Room \\
                Sam Richards & 314 \\
                Jon Jacobs & 108b \\
                |[fill=lightgray]| Mary Smith & 109 \\
            }
            (S |- V')
            node[tabular, hline] (S') {
                Teacher name & Salary & Room \\
                Sam Richards & 57,000 & 314 \\
                Jon Jacobs & 50,000 & 108b \\
                |[fill=lightgray]| Mary Smith &
                \path
                    node[anchor=west] (phantom) {\phantom{65,000}} (phantom.east)
                    node[anchor=east, darkred, fill=lightgray] {0}
                    ;
                & 109 \\
            }

            (S)  edge[->] node[above] {\GET}                    (V)
            (V)  edge[->] node[right] {\tiny user modification} (V')
            (V') edge[->] node[below] {\PUT}                    (S')
            (S.east) +(0, -1ex) edge[bend left=90] (S'.east)
            ;
    \end{diagram}
    \caption{With dictionary lenses, changing a key causes information loss}
    \label{fig:school-salaries-key-change}
\end{figure}

Matching lenses give a concrete way to separate alignment discovery from
update propagation, and propose several promising discovery heuristics.
There is also an implementation available for a string-based data model.

The basic model of matching lenses formalizes a framework for container mapping and
restructuring lenses: the structure of the source and view containers need
not be identical, but there must be an identical set of positions (and the
connection between the positions in the source and the positions in the view
must be the trivial one---that is, no reordering). They show how to extend
the basic model to allow the contained values to have different types, to
allow reordering, and to allow the contained values to themselves be
containers. The framework of the basic model of matching lenses is already
complicated; by the time it is extended in this way, the machinery is quite
baroque. By comparison, the basic formalism of edit lenses can be summarized
quite compactly, and is nevertheless flexible enough to accommodate all the
extensions proposed. Additionally, edit lenses support a more flexible array
of container operations, and in particular may be used to define lenses
between structures with differing numbers of holes.

\section{Annotation-based delta lenses}
\label{sec:annotations}
A weakness of our approach is that the lack of categorical products
indicates that we cannot duplicate information during our transformations.
For some applications, this is a critical feature, and allowing this requires
different fundamentals. Work on annotation-based delta lenses addresses this
need~\cite{Hu04,HuEditor08,MuAlgebraic2004}. Their foundations are
fundamentally symmetric; however, the way they propose using it is
essentially asymmetric. Besides that, there are two key differences between
their development and ours. First, their data model is ordered, node-labeled
trees, and rather than separating edits from the data, they merge them:
edits are represented by annotating the trees with insertion, deletion, and
modification markings. Reordering is not considered at all; furthermore,
annotated trees are always at least as big as the real tree they represent,
so the performance issues associated with the size of a repository are not
addressed. Additionally, their behavioral laws govern
how lenses treat annotated values. There is an erasure process to turn
annotated trees into plain ones (by performing the respective insertions,
deletions, and modifications), but no exploration of the interaction between
erasure and the lens' behavioral laws. The second key difference is that
allowing duplication requires them to significantly relax the behavioral
laws: for example, if only one copy of some duplicated information is
modified, one wishes a roundtrip of the transformations to modify the other
copy analogously. The weakened laws allow this, but also allow many other
apparently undesirable behaviors like ignoring all changes indiscriminately.

\section{Constraint maintainers}
\label{sec:constraint-maintainers}
Constraint maintainers are an early exploration of a symmetric framework for
bidirectional transformations~\cite{Meertens98}. The framework is a very
natural one, as mentioned in \S\ref{sec:intro-symmetry}: given a relation $R
\subset X \times Y$, a constraint maintainer is a pair of functions
$\triangleright \in X \times Y \to Y$ and $\triangleleft \in X \times Y \to
X$ for which $x\relR(x \triangleright y)$ and $(x \triangleleft y)\relR y$.
One may optionally also require that related values remain unchanged, that
is:

\noindent
\hfil$\infruleplain{x \relR y}{x \triangleright y = y}$
\hfil$\infruleplain{x \relR y}{x \triangleleft y = x}$
\hfil

\noindent Some discussion of generalizing these behavioral laws to a Principle of
Least Change is given; in any case, those maintainers which satisfy the
property above can be lifted to symmetric lenses as follows.
\lensdef
    {cmaint}
    {\infruleplain
        {\left<\triangleleft,\triangleright\right>
            \mbox{ a maintainer for }
            R \subset X \times Y \\
            x \relR y
        }
        {\mathit{cmaint}(R,\triangleleft,\triangleright,x,y) \in X \lens Y}
    }
    {
        C &=& R \\
        \missing &=& (x,y) \\
        \putr(x,(x',y)) &=& (x \triangleright y, (x, x \triangleright y)) \\
        \putl(y,(x,y')) &=& (x \triangleleft y, (x \triangleleft y, y))
    }
% TODO: could give the counterexample for composition and discuss why we can
% do it and maintainers can't
The work on constraint maintainers is especially commendable for its wide
coverage of bidirectional transformations. Many transformations on concrete
data types not considered in other bodies of work---particularly arithmetic
and set theoretic operations---are discussed and implemented here.
Nevertheless, general maintainer composition is shown to be uncomputable. A
restricted composition in the case where one of the two maintainers
corresponds to an asymmetric lens is given, and there is a proposal to use
maintainer chains when this is insufficient, but the properties of these
chains are not considered. There is some exploration of how to deal with
alignment issues; the main idea they propose is to lift relations on values
to relations on the edit sequences used to build values. One can then define
constraint maintainers which inspect such edit sequences. However, little
consideration is given to desirable behavioral laws with respect to these
more fine-grained structures; furthermore, the incremental capability we
expose from our edit lenses to allow for small updates is not explored.

% TODO: REW suggests: This review chapter seems to me to accomplish two
% general themes:
% 1. It lists some reasonable 'future work' directions for symmetric edit
%    lenses.
% 2. It illustrates how each alternative approach to edit languages succeeds
%    or fails to meet the four objectives you have laid out in the
%    introduction.
%
% So you need to follow the entire review with a summary of these two
% points, and what you learned from them.
