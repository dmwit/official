\section{Graph-based delta lenses}
\label{sec:delta}
There is a closely related line of work focused on designing edit-based
lenses which begins with much the same motivation our work
does~\cite{diskin2011asymmetric,Diskin-Delta11,hermann2011correctness,Pacheco2012}.
They arrive at a slightly different point in the design space compared to
us, with a primary difference being their treatment of edits. For them,
edits are typed---with edit type $x \dedge x'$ classifying edits that can be
applied to value $x$ and result in value $x'$---and edit application is
total. Before we investigate their definitions of asymmetric and symmetric
delta lens, let us review their model of edits in detail. We will begin with
a few standard definitions to put some notation in place. Whenever possible,
we will pun notation between graphs and categories; after all, a graph with
suitable extra structure \emph{is} a category.

\begin{definition}
    A \emph{graph} $G$ is a quadruple $\left<G_0,G_1,\mldom,\mlcod\right>$
    consisting of a set of nodes $G_0$, a set of edges $G_1$, and two
    functions $\mldom,\mlcod \in G_1 \to G_0$ giving the domain and codomain
    of each edge. We will write $e:v \dedge v'$ as shorthand for the
    assertion that $e \in G_1$, that $\mldom(e)=v$, and that $\mlcod(e)=v'$.
    If the directionality of the edge is uninteresting, we will write $e:v
    \uedge v'$ to mean either $e: v \dedge v'$ or $e: v' \dedge v$.
\end{definition}

Below, we will use graphs to model edits: nodes of the graph will correspond
to repository states, and an edge $\dx : x \to x'$ will correspond to an
edit $\dx$ which, when applied to state $x$, results in state $x'$. As in
our development, it is natural to impose a little bit of structure on edges,
such as the existence of a ``do-nothing'' edit and the ability to combine
two edits into one. We introduce these restrictions separately so that we
may talk about lenses between edit models with only some of this structure.
We will also introduce a constraint that says that no matter which two
repository states you choose, there is some edit between them, which may be
an important practical consideration but does not seem to affect the theory
significantly one way or another. For the discussion of symmetric delta
lenses, we will also want to consider edits which can be ``undone''.

\begin{definition}
    Given function $f \in X \to Y$, we say $x$ and $x'$ are \emph{equivalent
    under $f$}, denoted $x \under_f x'$, when $f(x)=f(x')$.
\end{definition}

It is easy to see that $\under_f$ is an equivalence relation for any $f$.

\begin{definition}
    A graph $G$ is \emph{reflexive} if it comes equipped with a function
    $\id_G \in G_0 \to G_1$ which chooses a distinguished self loop
    $\id_{G,v} : v \dedge v$ for each node $v$. By abuse of notation, we
    will write $\id_v$ instead of $\id_{G,v}$ when there can be no confusion
    about which graph is meant.
\end{definition}

\begin{definition}
    A graph $G$ is \emph{connected} if for each $v,v'\in G_0$ there exists
    an edge $e : v \dedge v'$.
\end{definition}

\begin{definition}
    A reflexive graph $G$ is \emph{involutive} if it comes equipped with a
    function $\swoop \in G_1 \to G_1$ which associates with each edge $e : v
    \dedge v'$ an opposing edge $e\swoop : v' \dedge v$. It is required to
    be an involution (so that $e\swoop\swoop = e$) and to respect the
    reflexive structure of the graph (so that $\id_v\swoop=\id_v$).
\end{definition}

The delta lens frameworks discussed here are based on two edit models: their
asymmetric lenses are based on a connected category model of edits, and
their symmetric lenses are based on a connected involutive graph model of
edits.

In both cases, there is an underlying graph, and in particular this means
that each edit must uniquely identify the state that it can be applied to
along with the state it produces. At least naively, this requirement seems
to be in conflict with our goal of representing edits with objects
significantly smaller than the repository states. Many of our edit modules
exploit the ability to reuse edits as modifications to many different
repository states. Nevertheless, totality of edit application is a nice
feature. One can view the two approaches as two extremes, with on one end
graphs with a single node representing all possible repository states and on
the other end graphs with many nodes where each node represents a single
repository state. There may be a middle ground in which graph nodes each
represent many possible repository states; the hope then would be that one
could keep the benefit of a total edit application function while reusing
single edits on many different states. For example, for list edits, one
might consider a graph with one node for each possible length of list. Then
one would have, for example, deletion edges $\mldelete : m \dedge n$ when
$m<n$; such an edge must store marginally more information than our edit
module did (the domain and codomain length rather than a single number telling
their difference), but the set of repositories to which it applies is much
more clearly delimited. Attempting to recast the edit modules and lenses
proposed above in this light would be an interesting area for future work.

The connection between modules and edit graphs can be made precise as
follows. To pass from a module $X$ to a graph $\Gr(X)$, let $\Gr(X)_0=|X|$
be the set of nodes and $\Gr(X)_1=\{m : x \dedge y \mid mx=y\}$ be the set
of edges (so that $\mldom(m : x \dedge y)=x$ and $\mlcod(m : x \dedge y)=y$,
hence $(m : x \dedge y) : x \dedge y$). The graph can be made reflexive by
defining $\id_x = \ONE : x \dedge x$; if we further define the composition
$(m : x \dedge y);(m' : y \dedge z)=m'm : x \dedge z$, the monoid action
laws guarantee that we can regard the graph as a category. Now let us see
how to pass from a category $G$ to a module $\Mod(G)$. (An arbitrary
reflexive graph may be turned into a category: for the arrows between nodes
$v$ and $v'$, use the set of paths from $v$ to $v'$ that do not have any
$\id$ edges\footnote{Equivalently, the set of paths quotiented by the
smallest congruence relation containing the equation that ensures that $\id$
edges are the unit for composition: $\blist \id \elist = \NIL$.}; for the
composition, use path concatenation; and for the identities, use empty
paths.) Let the values $|\Mod(G)|=G_0$ be the set of nodes, and edits $\D
\Mod(G)=G_1\LIST/{\sim}_;$ be the set of paths quotiented by the congruence
relation that identifies factorable paths $\blist f;g \elist$ with the
factoring $\blist g \mlist f \elist$. In other words, the edits of $\Mod(G)$
are sequences of edges $\blist g_1 \clist g_n \elist$ which are \emph{not}
well-typed: $\mlcod(g_{i+1}) \ne \mldom(g_i)$ for each $i$. (One can further
identify all lists of length more than one---that is, lists that have an
internal typing error---with a single $\fail$ edit. The result is still a
module, but the lens lifting we perform below would not result in a lens.)
The empty list serves as the identity. Edit application is generated by the
equation $\dx \odot_g x = x'$ when $\dx : x \dedge x'$ (and undefined
otherwise). One may choose any object to play the role of $\init$ (so that
there are as many ways to turn a category into a module as there are objects
in the category). Passing from a category to a module and back adjoins a
fresh identity edit to each object, but otherwise leaves the category
unchanged. On the other hand, passing from a module to a category and back
may produce a significantly more verbose edit language, even after
accounting for the many ways to represent internal failure: each edit $m$ in
the source module induces a collection of edits $\{\blist m : x \dedge
y\elist \mid mx = y\}$ in the target module.

The involutive graph model of edits demands the existence of undo edits,
something we did not consider carefully in the edit lens framework above. A
suitable module-based analog of the typed involution would be to require
each module to include an untyped involution $\swoop$ such that
$(\dx\swoop\;\dx)\odot x=x$ whenever $\dx\odot x$ is defined. (Thus
$\dx\swoop\;\dx$ is a restricted identity: not necessarily equal to $\ONE$,
but behaves like it for some subset of the values being edited.) Many of the
modules and module combinators we have defined above can be equipped with
this structure. A notable few that cannot include edit operations which
actually delete information, such as the sum module's $\ml{switch}$ edits
and the list module's $\mldelete$ edits. These edits would need to be
enriched or restricted to include the information being deleted; for
example, one could modify the action associated with $\mldelete$ edits to
only succeed when the list elements being deleted were $\init$ (so that
edits which wish to delete an element must first modify it to being $\init$
with $\mlmodify$ edits), and one could enrich the $\ml{switch}$ edits with
an edit that returns the value to a tagged $\init$ before switching sides of
the sum. Thus in general it seems that requiring an ``undo'' ability can
require mildly larger edit operations.

With these considerations about edits in mind, let us discuss how to
generalize asymmetric, state-based lenses first to asymmetric delta lenses
and then to symmetric delta lenses.

\subsection{Asymmetric}
\label{sec:delta:asymmetric}
Now, let us take the edit model above and see how to enrich asymmetric
lenses to take edit information rather than states. As with the state-based
version, we will assume that there is strictly more information in the
source category $S$ than in the view category $V$. This means that in the
\GET direction, it seems natural to assume that each source edit $\ds : s
\dedge s'$ uniquely determines a view edit $\dv : v \dedge v'$ by ``throwing
away'' the extra information. It is also quite natural to require this \GET
transformation to respect the category structure in $S$: that is, we should
expect $\aget(\id)=\id$ and $\aget(\ds;\ds')=\aget(\ds);\aget(\ds')$.
Together, these say that $\aget$ is a functor from $S$ to $V$.

As with all asymmetric frameworks, the \PUT direction is a bit more
delicate, because it needs to restore missing information. Suppose we have a
view edit $\dv : v \dedge v'$ and wish to produce a source edit. It seems
natural to wish that the source edit we produce respects typing in the sense
that if we produce $\ds : s \dedge s'$, then $s$ is in the preimage of $v$
and $s'$ is in the preimage of $v'$. But this is still very unconstrained;
in particular, since there really is a particular $s_0$ which is currently
in synch with $v$, we really want to produce an edit $\ds$ whose domain is
$s_0$---that is, there is simply not enough information available in a view
edit to produce a reasonable translation function \PUT. So we cannot
translate directly from a view edit to a source edit; however, the key
insight of this line of work is that we can translate from a view edit to a
\emph{family} of source edits indexed by the source that is currently
synchronized with the view.

In detail, given an object mapping $\aget_0 \in S_0 \to V_0$, we can
construct the preimage category $S/\aget_0$ as follows. The objects of
$S/\aget_0$ are the equivalence classes of objects of $S$ under
$\under_{\aget_0}$. The arrows $f : [s_i] \dedge [s_o]$ are the functions
which take an element $s \in [s_i]$ and produce an arrow $f(s) : s \dedge
s'$ for some $s' \in [s_o]$. The identity arrow is the one which associates
to each $s$ the arrow $\id_s$; the composition is defined by
$(f;g)(s)=f(s);g(\mlcod(f(s)))$. When $\aget$ is a graph morphism, we will
write $S/\aget$ as shorthand for $S/\aget_0$. With this category in hand, we
are ready to define asymmetric delta lenses.

\begin{definition}
    A \emph{graph morphism} $f \in S \to V$ between graphs $S$ and $V$ is a
    pair $\left<f_0,f_1\right>$ of mappings $f_0 \in S_0 \to V_0$ and $f_1
    \in S_1 \to V_1$ such that $f_1(e) : f_0(\mldom(e)) \dedge
    f_0(\mlcod(e))$.
\end{definition}

\begin{definition}
    A \emph{semifunctor} $f \in S \to V$ between reflexive graphs is a graph
    morphism for which $f_1(\id_s)=\id_{f_0(s)}$.
\end{definition}

\begin{definition}
    An \emph{asymmetric delta lens} $\ell \in S \adlens V$ between connected
    categories $S$ and $V$ is a pair $\left<\aget,\aput\right>$ of graph
    morphisms $\aget \in S \to V$ and $\aput \in V \to S/\aget$. The lens is
    \emph{well behaved} (respectively, \emph{very well behaved}) if $\aget$
    and $\aput$ are semifunctors (resp. functors) and satisfy the behavioral
    law:
    \infax[ADPutGet]{\aget(\aput(\dv)(s))=\dv}
    We will abbreviate ``well behaved asymmetric delta lens'' to ``\WBADL''
    and ``very well behaved asymmetric delta lens'' to ``\VWBADL''.
\end{definition}

The suggested behavioral law enforces the intuition given above that all of
the information available in the view edits is available in source edits,
too. It turns out that the obvious definitions for identity and composition
lenses satisfy the behavioral law and induce a category whose objects are
connected categories and arrows are \VWBADLs. As in our discussion above
relating edit lenses to symmetric lenses, one can connect \WBADLs to
asymmetric state-based lenses by adjoining an operation to compute the
difference between two states. The paper goes on to show that \VWBADLs only
violate the controversial \rn{PutPut} law if their differencing operation
violates a similar \rn{DiffDiff} law---that is, failure is never due to
incorrect edit propagation, only incorrect edit discovery.

One can construct an edit lens out of a \VWBADL as follows. The complement
set will be source objects adjoined with a fresh $\fail$ value, so that the
partial edit application can be extended to a total one with explicit
failure:
\begin{align*}
    \ds \odot_t \mlinl s &= \mlinl {\ds \odot s} & \ds\odot s\Defined \\
    \ds \odot_t s &= \mlinr \fail & \mbox{otherwise}
\end{align*}
Then the lens construction goes as follows.
\lensdef{delta_symmetrize}
    {\infruleplain
        {\ell \in S \adlens V \qquad \ell\mbox{ is a \VWBADL} \qquad s \in S_0}
        {\mlsymm_s(\ell) \in \Mod(S) \dlens \Mod(V)}
    }
    {
        C &=& S_0 \uplus \{\fail\} \\
        \missing &=& \mlinl s \\
        K &=& \{(s,\mlinl s,\ell.\aget_0(s)) \mid s \in S_0\} \\
        \dputr_g(\ds, s) &=& (\ell.\aget_1(\ds),\ds\odot_t s) \\
        \dputl_g(\dv, \mlinl s) &=& \mllet \ds = \ell.\aput_1(\dv)(s) \mlinm (\ds, \ds\odot_t \mlinl s) \\
        && \mbox{when }\mldom(\dv)=\ell.\aget_0(s) \\
        \dputl_g(\dv, s) &=& (\ONE,\mlinr \fail) \mbox{ otherwise}
    }
The proof that this is well-defined and forms a lens is tedious but
straightforward. It relies critically on $\ell.\aget$ and $\ell.\aput$
respecting arrow composition and on the object part of the roundtrip law,
but not that $\ell.\aget$ and $\ell.\aput$ respect identities (because we
introduce a fresh identity) or that they roundtrip on arrows (as our
formalism does not have an analogous law). We conjecture that a construction
similar to the one used to decompose symmetric lenses into a pair of
asymmetric, state-based lenses can be used to decompose edit lenses into a
pair of \VWBADLs.
% TODO: could try to flesh out this conjecture a bit

Later work proposes a concrete edit model and a collection of \WBADLs and
combinators~\cite{Pacheco2012}. In addition to the above definition of
\WBADLs, they give a proposal for a framework of \emph{horizontal delta
lenses} which are more convenient to implement but whose behavioral
guarantees are less intuitive. Horizontal delta lenses are nevertheless suitably
constrained so that they can be converted into \WBADLs as necessary. Their
data model is based on containers, with edits containing (in part) an
injective relation between the positions of the old and new pieces of data.
In addition many constructions similar to ours, they also discuss fold and
unfold operations for containers that are built from fixpoints of regular
higher-order functors. These give rise to significant complications in
handling the full range of edits; they discuss how to handle insertions and
deletions of nodes, but do not discuss reordering. Unlike our development,
all repositories are homogeneous containers; in particular, their tensor
product analog restricts the contained values in the two parts of the tuple
to have identical types.

\subsection{Symmetric}
\label{sec:delta:symmetric}
Diskin et al. also spend some effort considering what machinery is needed to
support transformations between domains that each have missing
information---that is, symmetric transformations~\cite{Diskin-Delta11}. As
we observed in our symmetric lens development, passing from asymmetric to
symmetric lenses is cleanest if one introduces a complement---some extra
information about how the values in the two repositories correspond. This
development similarly allows for extra information, with a little bit of
extra notational complexity arising from the pervasive use of typing: edits
are typed via a category, as discussed above, and correspondence information
is also typed, as we discuss now.

% TODO: this might need more introduction

\begin{definition}
    Given graphs $G$ and $H$, we define the \emph{domain-} and
    \emph{codomain-coincident} edge pairings as follows:
    \begin{align*}
        G \domco H &= \{(e_g,e_h) \mid e_g : v \dedge v' \in G_1 \land e_h :
        v \uedge v'' \in H_1\} \\
        G \codco H &= \{(e_g,e_h) \mid e_g : v \dedge v' \in G_1 \land e_h :
        v' \uedge v'' \in H_1\}
    \end{align*}
\end{definition}

\begin{definition}
    A \emph{symmetric delta lens} $\ell$ connecting connected categories $X$
    and $Y$, written $\ell \in X \sdlens Y$, consists of:
    \begin{itemize}
        \item a bipartite graph $R$ whose two parts are $X_0$ and $Y_0$ (the
            edges of $R$ are called \emph{correspondence relations}),
        \item a function $\mlfppg \in X \domco R \to Y_1 \times R_1$,
            and
        \item a function $\mlbppg \in Y \domco R \to X_1 \times R_1$.
    \end{itemize}
    We will write $\mlfppg_1$ and $\mlfppg_2$ (and similarly for $\mlbppg$)
    for the $Y_1$ and $R$ parts of $\mlfppg$'s output, respectively.
\end{definition}

The preconditions for $\mlfppg$ above stating that the edit and
correspondence relations are domain-coincident is somewhat similar to our
precondition requiring an edit which applies cleanly. The bipartite graph
$R$ plays a similar role to our consistency relations: if there is an edge
$r : x \uedge y$, then we can think of $r$ as being a (typed) complement
that is consistent with states $x$ and $y$.

A major contribution of this line of research is an exploration of
behavioral guarantees that reasonable symmetric delta lenses might offer.
The obvious laws are too strong; but the insight of this development is that
if we take the obvious laws and replace equalities by a slightly coarser
equivalence relation, we get laws that are much more plausible. The core of
the problem is that equality on $X$ edits distinguishes between edits that
modify information not available in $Y$; we would prefer a relation that
compares only the parts of the edit that affect the shared information.
At first it seems difficult to define ``shared information'' formally, but
lenses are exactly transformations that define what information is shared;
so the relation is parameterized by a lens.

\begin{definition}
    Given symmetric delta lens $\ell \in X \sdlens Y$ and a correspondence
    relation $r : x \uedge y$ for $\ell$, we define equivalence relations on
    edits to $x$ and $y$, respectively:
    \begin{align*}
        \eqsharedl*\ell r &={} \under_{\lambda \dx.\;\ell.\mlfppg_1(\dx,r)} \\
        \eqsharedr*\ell r &={} \under_{\lambda \dy.\;\ell.\mlbppg_1(\dy,r)}
    \end{align*}
    When the lens is understood from context, we will write $\dx\eqsharedl
    r\dx'$ instead of $\dx\eqsharedl*\ell r\dx'$ (and similarly for
    $\dy\eqsharedr r\dy'$).
\end{definition}

Armed with this notation, they propose several possible restrictions that
one could place on symmetric delta lenses. The first two restrictions are
analogous to ones discussed in our work above. Like our demand that
applicable edits get translated to applicable edits that restore
consistency, rule \rn{SDWellTyped} below demands that the edits and
correspondence relations involved in an invocation of $\mlfppg$ form a
well-typed square. They also demand that the propagation functions preserve
the self-loop structure of the edit graphs via the \rn{SDIdId} rule.
\infrule[SDWellTyped]
    {\mlfppg(\dx,r) = (\dy,r')}
    {r  : \mldom(\dx) \uedge \mldom(\dy) \\
     r' : \mlcod(\dx) \uedge \mlcod(\dy)}
\infrule[SDId]{r : x \uedge y}{\mlfppg(\id_x,r)=(\id_y,r)}

The edit graphs have another kind of structure given by the $\swoop$
undo operation. One might hope that this structure is preserved in a similar
way; for example, a rule like \rn{SDUndo-Strong*} seems reasonable at first
blush.
\infrule[SDUndo-Strong*]
    {\mlfppg(\dx,r)=(\dy,r')}
    {\mlfppg(\dx\swoop,r')=(\dy\swoop,r)}
Unfortunately, this rule is very restrictive. Suppose the $Y$ side of the
lens were to store some information not available in the $X$ side, and
propagating $\dx$ produces a $\dy$ that deletes some of that information.
Then this information could not be restored from the information in
$\dx\swoop$\footnote{One could imagine storing just enough information in
the correspondence relations to allow undoing one operation. Perhaps this
could be made to work, but it is unlikely this would scale well in
situations where there are composite edits (and hence composite undos).}.
One way to weaken this law to something more plausible would be to demand
that we output something that behaves like $\dy\swoop$ on the shared
information; that is, by weakening the equality in the conclusion to our
coarser equivalence relation from above:
\infrule[SDUndo]
    {\mlfppg(\dx,r)=(\dy,r')}
    {\mlfppg_1(\dx\swoop,r') \eqsharedr{r'} \dy\swoop}

The fourth and final behavioral law proposed demands that the edit
propagation functions be near inverses: that is, if we propagate $\dx$ to
$\dy$, then the corresponding edit determined by the other propagation
function should be $\dx$. As stated, this law is again too strong, because
some of the modifications described by $\dx$ are to unshared data, and hence
are not available in $\dy$ during re-propagation. As before, we can make the
rule more reasonable by weakening from equality to equivalence:
\infax[SDInvertible]{\mlbppg_1(\mlfppg_1(\dx,r),r)\eqsharedl r\dx}
This behavioral law is called a roundtrip law in their development, but that
name is a little misleading, as the update to the $y$ value and the updated
correspondence relation are discarded before applying the $\mlbppg$
function. (It is as if two separate people happened to take flights that
crossed paths in the middle, rather than a single person taking a round
trip.) We will instead call this law a \emph{triple-trip} law---for the two
trips evident in the law plus one trip hidden by the equivalence relation.

The line of research goes on to describe other theoretical
frameworks with interfaces closer to what an end-user programmer might want
to implement that can give rise to symmetric delta lenses. In particular,
they describe a framework they call \emph{consistency
maintainers}~\cite{Diskin-Delta11} which include explicit alignment and
consistency-restoration phases as well as explore conditions under which a
triple-graph grammar can be used to produce a law-abiding
lens~\cite{hermann2011correctness}. No concrete instantiations are given for
any of the three frameworks. We have found that undertaking this endeavor is
a valuable crucible in which to test prospective frameworks, as the design
of a lens language makes a mismatch between behavioral laws and actual
behavior much more clear. (Just as a good framework helps to spot
potential implementation bugs, an implementation helps point out potential
framework bugs.) In particular, sequential composition---in our experience,
a crucial tool for building practical lenses---is not considered, and the
ensuing need for a notion of lens equivalence is not addressed.

The proposed \rn{SDInvertible} and \rn{SDUndo} laws seem on the surface to
be quite natural restrictions. Our development does not have analogous laws,
and it seems that including them would necessitate a stronger equational
theory for many of the modules proposed above. Exploring the consequences of
these laws could be an interesting avenue for future work on edit lenses.

\section{Algebraic rephrasing}
\label{sec:algebraic}
% TODO: Do we need to mention somehow that this is a continuation of the
% (similarly-algebraically-motivated) exploration of state-based lenses in
% the 2007 Stevens paper that's cited elsewhere?
There is a line of work on algebraic foundations for delta lenses that
arrives at a model very similar to the edit lens framework described
above~\cite{stevens2008tat}. They consider, as we do, edit monoids together
with edit translation morphisms and (total) edit application actions.
One significant difference is that they consider generalizing asymmetric
rather than symmetric lenses, adopting correspondingly modified behavioral
laws. In particular, in their setting, a delta lens is a \emph{lens-like
split short exact sequence}. Below we discuss each of these restrictions in
right-to-left order. We begin with two standard definitions to establish
some notation.

\begin{definition}
    The \emph{image} of a function $f \in X \to Y$ is the set of elements
    $\im(f) \subset Y$ that $f$ can output:
    \[\im(f) = \{f(x) \mid x \in X\}\]
\end{definition}

\begin{definition}
    The \emph{kernel} of a monoid homomorphism $f$, denoted $\ker(f)$, is
    the preimage of $\ONE$:
    \[\ker(f) = \{x \mid f(x) = \ONE\}\]
\end{definition}

\begin{definition}
    An \emph{exact sequence} is a sequence $\blist f_1 \clist f_n \elist$ of
    monoid morphisms with compatible domains and codomains, that is,
    \begin{diagram}
        \path
            node                      (0)    {$X_0$}
            node[right=2.5em of 0]    (1)    {$X_1$}
            node[right=2.5em of 1]    (2)    {$X_2$}
            node[right=2.5em of 2]    (dots) {$\cdots$}
            node[right=2.5em of dots] (n2)   {$X_{n-2}$}
            node[right=2.5em of n2]   (n1)   {$X_{n-1}$}
            node[right=2.5em of n1]   (n0)   {$X_n$}
            (0)    edge[->] node[above] {$f_1$}     (1)
            (1)    edge[->] node[above] {$f_2$}     (2)
            (2)    edge[->] node[above] {$f_3$}     (dots)
            (dots) edge[->] node[above] {$f_{n-2}$} (n2)
            (n2)   edge[->] node[above] {$f_{n-2}$} (n1)
            (n1)   edge[->] node[above] {$f_n$}     (n0)
        ;
    \end{diagram}
    and such that $\im(f_i)=\ker(f_{i+1})$ for each $i$.
\end{definition}

\begin{definition}
    An exact sequence is \emph{short} if it has four morphisms and starts
    and ends at $\D\Unit$:
    \begin{diagram}
        \path
            node                   (1-1) {$\D\Unit$}
            node[right=4em of 1-1] (K)   {$K$}
            node[right=4em of K]   (X)   {$\DS$}
            node[right=4em of X]   (Y)   {$\DV$}
            node[right=4em of Y]   (1-2) {$\D\Unit$}
            (1-1) edge[->] node[above] {$i$} (K)
            (K)   edge[->] node[above] {$k$} (X)
            (X)   edge[->] node[above] {$f$} (Y)
            (Y)   edge[->] node[above] {$s$} (1-2)
            ;
    \end{diagram}
    We will say \emph{around} to mean the third element of a sequence, as
    in, ``$\blist i \mlist k \mlist f \mlist s \elist$ is a short exact
    sequence around $f$.''
\end{definition}

Before we define what split and lens-like mean, let us consider when an
edit translation homomorphism $f \in \DS \to \DV$ may be extended to a short
exact sequence. The homomorphism $s \in \DV \to \D\Unit$ must be the
constantly-$\ONE$ function (there are no other functions with that type), so
that its kernel is $\ker(s)=Y$. Hence the restriction $\im(f)=\ker(s)$ that
arises from extending the sequence to the right says that $f$ must be
surjective. On the other hand, the sequence may always be extended to the
left by choosing $K$ to be the submonoid $\ker(f)$ and $k$ to be the
inclusion function. (The homomorphism $i$ is completely determined by the
homomorphism laws once we have chosen a monoid $K$: it must map the sole
input element $\ONE_{\D\Unit}$ to $\ONE_K$.) Other choices for $K$ are
possible---for example, by adding a fresh generator to $K$ that $k$ maps to
any non-trivial element of $X$---but we will not be interested in this
ability below.

In lens terms, one should think of $f$ as being an edit-lens analog of the
asymmetric lens framework's \GET function. Giving a short exact sequence
amounts to identifying an edit translation function $f\in\DS\to\DV$ that is
compatible with the monoid structure on edits and such that each $V$-edit
has at least one analogous $S$-edit.

\begin{definition}
    A short exact sequence around $f\in\DS\to\DV$ is said to \emph{split} if
    there is a homomorphism $g\in\DV\to\DS$ such that $g;f = \id_{\DV}$.
\end{definition}

We are guaranteed that there is a \emph{function} $g$ by the fact that $f$
is surjective, but not guaranteed that any such function is a monoid
homomorphism. If we do have such a homomorphism $g$ that splits the
sequence, then in lens terms we should consider that $g$ to be an edit-lens
analog of the \PUT function. Then $g;f = \id_{\DV}$ says that all the
information available in $V$-edits are also available in $S$-edits, an
analogous restriction to the one on state-based lenses that says that all
the information available in the view repository is available in the source
repository.

The final condition placed on this variant of delta lenses is that they be
lens-like. Thus far, all the conditions have been purely in terms of edits;
this final pair of properties connect the world of edits and the world of
states. This is similar to the edit lens law that requires $\dputr$ and
$\dputl$ to respect a consistency relation on states.

\begin{definition}
    A monoid action $\odot \in \DX \times |X| \to |X|$ is \emph{transitive}
    if for all $x,x' \in |X|$ there is $\dx \in \DX$ such that $\dx\odot
    x=x'$. We will say a module is transitive when its action is.
\end{definition}

\begin{definition}
    A short exact sequence around $f\in\DS\to\DV$ split by $g$ is
    \emph{lens-like} if it comes equipped with transitive, total modules for
    $\DS$ and $\DV$ such that two conditions hold:
    \infrule[LL1]
        {\ds\;\init_S = \ds'\;\init_S}
        {f(\ds)\;\init_V = f(\ds')\;\init_V}
    \infrule[LL2]
        {\dv\;f(\ds)\;\init_V = f(\ds)\;\init_V}
        {g(\dv)\;\ds\;\init_S = \ds\;\init_S}
\end{definition}

Rule \rn{LL1} amounts to saying that $f$ is (part of) a module homomorphism
(not just a monoid homomorphism). Rule \rn{LL2} is a bit more subtle, but is
motivated by this rephrasing of the state-based asymmetric lens framework's
\rn{GetPut} law:
\infrule[GetPutAlt]
    {\aget(s)=v}
    {\aput(v,s)=s}
Rule \rn{GetPutAlt} says, roughly, ``if the view $v$ has not changed since
the last synchronization, then the source $s$ should not change, either.''
Similarly, \rn{LL2} says, roughly, ``if the edit we are about to translate
does not change the view $f(\ds)\;\init_V$, then the edit we output should
not change the source $\ds\;\init_S$.''

That work goes on to explore the properties of this kind of delta lens. One
can take a lens-like sequence around $f\in\DS\to\DV$ equipped with a diffing
operation $\dif\in|S|\times|V|\to\DV$ (satisfying the obvious sanity
condition) and produce an asymmetric, state-based lens. Additionally, there
is a close relationship between demanding the existence of inverse
edits---that is, working with edit groups rather than edit monoids---and the
\rn{PutPut} asymmetric lens law:
\infax[PutPut]{\aput(v,\aput(v',s))=\aput(v,s)}
They show that one can define suitably restricted submonoids $\DV \subset V
\to V$ and $\DS \subset S \to S$ and lift \rn{PutPut}-abiding asymmetric
lenses into a lens-like sequence on groups. Furthermore, the two
translations agree with each other: converting a lens to a lens-like
sequence and back is the identity transformation, regardless of the choice
of $\dif$ operation in the latter transformation.

The primary difference between their work and ours is that they consider
only asymmetric situations. However, they also consider many fundamentally
different restrictions than the current development does, even after
accounting for the different setting. For example, they propose a law
requiring that when $g$ splits a sequence around $f$ we additionally have
$g;f=\id$. Since $f$ is surjective, this is the same as demanding $f;g;f=f$,
akin to Diskin's proposed triple-trip law discussed above. As mentioned in
that discussion, it is not a law that we have considered carefully; but it
seems we may be able to achieve something similar in many of the lenses we
defined by introducing appropriate equalities to our edit monoids for
structured data. The paper also spends some time discussing the
ramifications of demanding an edit group rather than an edit monoid. We have
not explored this restriction deeply, but some cursory investigations
suggest that including enough information to undo each operation may be at
odds with the size benefits promised above. Another restriction they have
throughout their development is that their edit application actions are
invariably total. We believe that partiality of these actions is an
important real-world consideration. Treating it carefully allows us to
distinguish between error conditions and edits which successfully do
nothing, and to give a guarantee that our lenses do not spuriously turn a
succesful nothing into an error condition.

They also treat backwards-compatibility with asymmetric, state-based lenses
very seriously, which gives rise to their lens-like restrictions.  Their
rule \rn{LL1} stating that the \GET direction is a module homomorphism can
be seen as saying that edit translation is consistent with state
translation.  Our demand that the edit translations preserve a consistency
relation can be seen as a generalization of this. On the other hand, their
rule \rn{LL2}---necessary to ensure that their delta lenses behave like
state-based lenses regardless of $\dif$ operation---seems quite strong. The
goal appears to be to preserve the state-based behavior that changing
nothing on one side changes nothing on the other; however, it is our view
that demanding that the distinguished do-nothing edit from one module be
translated to the distinguished do-nothing edit from the other module
already captures this intuition. There are edits which appear to do nothing
to a given view but which nevertheless have semantic content, and should
therefore be allowed to be distinguished by a lens. Consider the example of
Figure~\ref{fig:school-salaries} again, reproduced here as
Figure~\ref{fig:school-salaries-delins}. An edit which deletes the last
element of the secretary's view, then inserts a fresh element with value
``Mary Jones'', apparently does nothing to the current view. Nevertheless,
it seems quite natural\footnote{Possibly even desirable---an obviously
incorrect value is often preferable to a plausible incorrect value.} for the
translation of this edit to reset the salary associated with ``Mary Jones''
to a default value; a rule like \rn{LL2} would prevent lenses from having
this kind of nuanced behavior.

\begin{figure}
    \begin{minipage}{0.5\linewidth}
        \centering
        \begin{tabular}{lr}
            Teacher name & Salary \\
            \hline
            Sam Rickard & 57,000 \\
            Jon Jacobs & 50,000 \\
            Mary Jones & 65,000 \\
        \end{tabular}
        \subcaption{HR's view}
        \label{fig:school-salaries-delins-hr}
    \end{minipage}%
    \begin{minipage}{0.5\linewidth}
        \centering
        \begin{tabular}{l}
            Teacher name \\
            \hline
            Sam Rickard \\
            Jon Jacobs \\
            Mary Jones \\
        \end{tabular}
        \subcaption{A secretary's view}
        \label{fig:school-salaries-delins-sec-pre}
    \end{minipage}%
    \caption{A school's staff list, as seen by HR and by the principal's secretary}
    \label{fig:school-salaries-delins}
\end{figure}

Finally, our development includes significantly more effort instantiating
the lens framework to particular lenses and lens combinators. We believe
that this is good evidence that our behavioral restrictions are relaxed
enough to accomodate important use cases; nevertheless, they were strict
enough to prevent many genuinely undesirable behaviors in early proposals
for these combinators (not documented here).

% TODO: notation correspondence
% our \D\Unit is their 1
% our \init is their \Omega
% we use f and g for a split sequence; they use \mu and \lambda
% we use \ds and \dv for edits, they use g
% we say \dif operation; they say oracle

\section{Matching lenses}
\label{sec:matching}
Dictionary lenses~\cite{Boomerang07} and their sequel, matching
lenses~\cite{Matching10}, are also motivated by the alignment problems
discussed above. We will consider a variation of our motivating example from
Chapter~\ref{chap:introduction} which showcases a particularly annoying
example of bad alignment---annoying both because it is a common scenario and
because it seems especially clear how to get the right answer.
Figure~\ref{fig:school-salaries-keys} shows again the bad behavior of
positional alignment. Gray annotations mark changes with respect to a
previous version of a given repository. The salary column of the updated
source repository is marked in red because it has been misaligned with the
updated view: the names have been shuffled, but the salaries have not.

\begin{figure}
    \begin{diagram}
        \draw
            node[tabular, hline] (S) {
                Teacher name & Salary & Room \\
                Sam Rickard & 57,000 & 314 \\
                Jon Jacobs & 50,000 & 108b \\
                Mary Jones & 65,000 & 109 \\
            }
            (S.north east) +(2, 0)
            node[matrix anchor=north west, tabular, hline] (V) {
                Teacher name & Room \\
                Sam Rickard & 314 \\
                Jon Jacobs & 108b \\
                Mary Jones & 109 \\
            }
            (V.south) +(0, -1)
            node[matrix anchor=north, tabular, hline] (V') {
                Teacher name & Room \\
                Jon Jacobs & 108b \\
                Mary Jones & |[fill=lightgray]| 111 \\
                Sam Rickard & 314 \\
            }
            (S |- V')
            node[tabular, hline] (S') {
                Teacher name & Salary & Room \\
                Jon Jacobs  & |[darkred]| 57,000 & 108b \\
                Mary Jones  & |[darkred]| 50,000 & |[fill=lightgray]| 111 \\
                Sam Rickard & |[darkred]| 65,000 & 314 \\
            }

            ($(V'-2-2.east |- V'-2-2.east) +(0.5em,0)$) edge[reorder, bend left=60] ($(V'-2-2.east |- V'-4-2.east) +(0.5em,0)$)
              (V'-2-2.east |- V'-3-2.east)              edge[reorder, bend right]     (V'-2-2.east |- V'-2-2.east)
              (V'-2-2.east |- V'-4-2.east)              edge[reorder, bend right]     (V'-2-2.east |- V'-3-2.east)

            ($(S'-2-1.west) +(-0.5em,0)$) edge[reorder, bend right=60] ($(S'-4-1.west) +(-0.5em,0)$)
              (S'-3-1.west)               edge[reorder, bend left]       (S'-2-1.west)
              (S'-4-1.west)               edge[reorder, bend left]       (S'-3-1.west)

            (S)  edge[->] node[above] {\GET}                    (V)
            (V)  edge[->] node[right] {\tiny user modification} (V')
            (V') edge[->] node[below] {\PUT}                    (S')
            (S.east) +(0, -1ex) edge[bend left=90] (S'.east)
            ;
    \end{diagram}
    \caption{An easily fixed misalignment}
    \label{fig:school-salaries-keys}
\end{figure}

The observation of dictionary lenses is that the teacher names in the view
repository act somewhat like a key: the reordering that the user did can be
recovered by comparing the order of names before and after the modification.
Experience with lens programming shows that the existence of a key is fairly
common, so merely giving the programmer the ability to specify which parts
of the data correspond to keys can improve the \PUT behavior in a wide range
of applications. However, there is an unfortunate behavioral regression:
with positional alignment, changing a key is handled gracefully, but with a
dictionary lens, a changed key results in a loss of any associated
information. Figure~\ref{fig:school-salaries-key-change} gives an example of
a dictionary lens resetting a salary that a plain lens would preserve. The
observation here is that simple key equality is too strict. Matching lenses
relax this restriction; they parameterize lenses by an alignment
strategy---which can do arbitrary computation---that computes how chunks of
the old and new copies of the repository correspond. Several heuristics that
satisfy the interface of an alignment strategy are given, for example, for
computing the least-cost alignment according to some function that computes
the cost of a single-chunk change.

\begin{figure}
    \begin{diagram}
        \draw
            node[tabular, hline] (S) {
                Teacher name & Salary & Room \\
                Sam Rickard & 57,000 & 314 \\
                Jon Jacobs & 50,000 & 108b \\
                Mary Jones & 65,000 & 109 \\
            }
            (S.north east) +(2, 0)
            node[matrix anchor=north west, tabular, hline] (V) {
                Teacher name & Room \\
                Sam Rickard & 314 \\
                Jon Jacobs & 108b \\
                Mary Jones & 109 \\
            }
            (V.south) +(0, -1)
            node[matrix anchor=north, tabular, hline] (V') {
                Teacher name & Room \\
                Sam Richards & 314 \\
                Jon Jacobs & 108b \\
                |[fill=lightgray]| Mary Smith & 109 \\
            }
            (S |- V')
            node[tabular, hline] (S') {
                Teacher name & Salary & Room \\
                Sam Richards & 57,000 & 314 \\
                Jon Jacobs & 50,000 & 108b \\
                |[fill=lightgray]| Mary Smith &
                \path
                    node[anchor=west] (phantom) {\phantom{65,000}} (phantom.east)
                    node[anchor=east, darkred, fill=lightgray] {0}
                    ;
                & 109 \\
            }

            (S)  edge[->] node[above] {\GET}                    (V)
            (V)  edge[->] node[right] {\tiny user modification} (V')
            (V') edge[->] node[below] {\PUT}                    (S')
            (S.east) +(0, -1ex) edge[bend left=90] (S'.east)
            ;
    \end{diagram}
    \caption{With dictionary lenses, changing a key causes information loss}
    \label{fig:school-salaries-key-change}
\end{figure}

Matching lenses give a concrete way to separate alignment discovery from
update propagation, and propose several promising discovery heuristics.
There is also an implementation available for a string-based data model.

The basic model discussed handles a sort of mix of our container mapping and
restructuring lenses: the structure of the source and view containers need
not be identical, but there must be an identical set of positions (and the
connection between the positions in the source and the positions in the view
must be the trivial one---that is, no reordering). They show how to extend
the basic model to allow the contained values to have different types, to
allow reordering, and to allow the contained values to themselves be
containers. The framework of the basic model of matching lenses is already
complicated; by the time it is extended in this way, the machinery is quite
baroque. By comparison, the basic formalism of edit lenses can be summarized
quite compactly, and is nevertheless flexible enough to accommodate all the
extensions proposed. Additionally, edit lenses support a more flexible array
of container operations, and in particular may be used to define lenses
between structures with differing numbers of holes.

\section{Annotation-based delta lenses}
\label{sec:annotations}
A weakness of our approach is that the lack of categorical products
indicates that we cannot duplicate information during our transformations.
For some applications, this is a critical feature; allowing this requires
different fundamentals. Work on annotation-based delta lenses addresses this
niche~\cite{Hu04,HuEditor08,MuAlgebraic2004}. Their foundations are
fundamentally symmetric; however, the way they propose using it is
essentially asymmetric. Besides that, there are two key differences between
their development and ours. First, their data model is ordered, node-labeled
trees, and rather than separating edits from the data, they merge them:
edits are represented by annotating the trees with insertion, deletion, and
modification markings. Reordering is not considered at all; furthermore,
annotated trees are always at least as big as the real tree they represent,
so size issues are not addressed. Additionally, their behavioral laws govern
how lenses treat annotated values. There is an erasure process to turn
annotated trees into plain ones (by performing the respective insertions,
deletions, and modifications), but no exploration of the interaction between
erasure and the lens' behavioral laws. The second key difference is that
allowing duplication requires them to significantly relax the behavioral
laws: for example, if only one copy of some duplicated information is
modified, one wishes a roundtrip of the transformations to modify the other
copy analogously. The weakened laws allow this, but also allow many other
apparently undesirable behaviors like ignoring all changes indiscriminately.

\section{Constraint maintainers}
\label{sec:constraint-maintainers}
Constraint maintainers are an early exploration of a symmetric framework for
bidirectional transformations~\cite{Meertens98}. The framework is a very
natural one, as mentioned in \S\ref{sec:intro-symmetry}: given a relation $R
\subset X \times Y$, a constraint maintainer is a pair of functions
$\triangleright \in X \times Y \to Y$ and $\triangleleft \in X \times Y \to
X$ for which $x\relR(x \triangleright y)$ and $(x \triangleleft y)\relR y$.
One may optionally also require that related values remain unchanged, that
is:

\noindent
\hfil$\infruleplain{x \relR y}{x \triangleright y = y}$
\hfil$\infruleplain{x \relR y}{x \triangleleft y = x}$
\hfil

\noindent Some discussion of generalizing these behavioral laws to a Principle of
Least Change is given; in any case, those maintainers which satisfy the
property above can be lifted to symmetric lenses as follows.
\lensdef
    {cmaint}
    {\infruleplain
        {\left<\triangleleft,\triangleright\right>
            \mbox{ a maintainer for }
            R \subset X \times Y \\
            x \relR y
        }
        {\mathit{cmaint}(R,\triangleleft,\triangleright,x,y) \in X \lens Y}
    }
    {
        C &=& R \\
        \missing &=& (x,y) \\
        \putr(x,(x',y)) &=& (x \triangleright y, (x, x \triangleright y)) \\
        \putl(y,(x,y')) &=& (x \triangleleft y, (x \triangleleft y, y))
    }
% TODO: could give the counterexample for composition and discuss why we can
% do it and maintainers can't
There is a significant body of maintainers discussed there, with a notable
exception being constraint maintainer composition. General maintainer
composition is shown to be uncomputable. A restricted composition in the
case where one of the two maintainers corresponds to an asymmetric lens is
given, and Meertens proposes the use of maintainer chains when this is
insufficient, but the properties of these chains are not considered. There
is some exploration of how to deal with alignment issues; the main idea they
propose is to lift relations on values to relations on the edit sequences
used to build values. One can then define constraint maintainers which
inspect such edit sequences. However, little consideration is given to
desirable behavioral laws with respect to these more fine-grained
structures; furthermore, the incremental capability we expose from our edit
lenses to allow for small updates is not explored.

\section{Fibrations}
\label{sec:fibrations}
% Johnson+Rosebrugh's work on sketch-based data modeling; see FogBugz for a
% list of resources to consult when it comes time to write this section
%
% still digesting, but it seems they have a notion of edit but that it
% doesn't help with alignment (?) and that they don't really propose much in
% the way of syntax -- they only give a way to check if a particular
% hand-constructed transformation is allowed

\section{Others}
\label{sec:other-related-work}
% In case of time crunch, may be able to drop this section!

\subsection{Graph transformations}
\label{sec:other-related-work:graph}
% BiG-lab's stuff -- check if they make any attempt at symmetry or edits

\subsection{Triple graph grammars}
\label{sec:other-related-work:triple}
% gives an attempt at parsing graphs; some of the tools are symmetric, and
% may be in use, but need to review a bit before knowing what to say here

\subsection{Incremental XML transformations}
\label{sec:other-related-work:xml}
% sort of tangentially related; lots of stuff is based on tree transducers;
% very interested in good models for edits and edit transformations so
% perhaps we have something to teach them there

% dump from our delta lenses paper {{{
%
%The most closely related attempt at developing a theory of update
%propagation is \cite{Diskin-Delta11} by Diskin et al. Their starting
%point is the observation (also discussed in \cite{Matching10}) that discovery of
%edits should be decoupled from their propagation. They thus propose a
%formalism, \emph{sd-lenses}, for the propagation of edits across
%synchronized data structures, bearing some similarities with our
%edit lenses. The replicas, which we model as modules, are there modeled
%as categories (presented as reflexive graphs)\iffull, as we discussed in 
%\S \ref{cats}\fi. Thus, for any two states $x,x'$ there is a set of
%edits $X(x,x')$. An sd-lens then comprises two reflexive graphs $X,Y$
%and for any $x\in X$ and $y\in Y$ a set $C(x,y)$ of
%``correspondences'' which roughly correspond to our
%complements. Forward and backward operations similar to our $\dputl$ and
%$\dputr$ then complete the picture. No concrete
%examples are given of sd-lenses, no composition, no notion of equivalence, and
%no combinators for constructing sd-lenses; the focus of the paper is
%rather on the discovery of suitable axioms, such as invertibility and
%undoability of edits, and a 
%generalization of {\em hippocraticness} in the sense of
%Stevens~\cite{Stevens07}. They also develop a comparison 
%with the state-based framework (cf.\ \S \ref{stateb} above). In
%our opinion, the separation of edits and correspondences according to
%the states that they apply to or relate has two important
%disadvantages.  First, in our examples, it is often the case that one
%and the same edit applies to more than one state and can be
%meaningfully propagated (and more compactly represented) as such. For example, while many of the
%container edits tend to only work for a particular shape, they are
%completely polymorphic in the contents of the container. Second, the
%fact that state sets are already categories suggests 
%that a category of sd-lenses would be
%2-categorical in flavor, entailing extra technical difficulties such as
%coherence conditions. 
%
% [dmwit comments after the fact: perhaps there is a middle ground! e.g. a
% category whose objects represent a set of similar states -- lists might
% have one object per length, for example. also I don't understand the
% complaint about 2-categorical flavor; seems it is the *objects* of the
% sd-lens category that have categorical structure, whereas the difficulties
% of 2-categories arise from arrows having categorical structure.]
%
%%% \finish{Here's a quick start from a brief scan of their most recent
%%%   paper~\cite{Diskin-Delta11} by BCP...
%%%   \begin{itemize}
%%%   \item Their motivations and goals are exactly the same.
%%%   \item The technicalities of their approach are pretty dense.  I haven't
%%%   internalized them yet.  In particular, I don't have a good intuition for
%%%   their ``sameness'' relations---what they say makes sense for ``flat''
%%%   structures like lists or simple graphs, but not for more structured data
%%%   (where you'd want to know about correspondences at various levels of
%%%   structure). 
%%%   \item They don't say anything about the size of their deltas, and at
%%%   least a naive representation would be big.  We're much more careful about
%%%   this. 
%%%   \item They propose two new laws (weak invertability and undoability).  I'm
%%%   not sure what to say about these, but I guess it's an important point of
%%%   comparison, since it's one of the main points of their paper.
%%%   \item They don't handle $\missing$ (a small point)
%%%   \item They don't define any combinators, just the semantic space itself (a
%%%   larger point, and related) 
%%%   \item Their Definition 19 and Theorem 5 relate their delta-lenses to our
%%%   symmetric lenses.  I'm not completely sure how to interpret it (does our
%%%   ``trivial module'' correspond to their ``simple graph''?), but in any case
%%%   our result is stronger because it goes both directions.  (Their
%%%   characterization of our symmetric lenses is a little bit wrong---it puts
%%%   $C$ in the wrong place---but I'm not sure this matters.)
%%%   \end{itemize}
%%% }
%
%Meertens's seminal paper on {\em constraint maintainers}~\cite{Meertens98}
%discusses a form of containers for lists equipped with a notion of edits
%similar to our edit language for lists, but does not develop a general
%theory of edit-transforming constraint maintainers.
%
%A long series of papers from the group at the University of Tokyo
%\cite[etc.]{Hu04, Mu2004, MuAlgebraic2004, HuModels07,
%  Hidaka10}\iffull\discuss{double-check these, and add more, and add to abstract
%  too}\fi{} deal with the alignment issue using an approach that might be
%characterized as a hybrid of state-based and edit-based.  Lenses work with
%whole states, but these states are internally annotated with tags showing
%where edits have been applied---e.g., marking inserted or deleted elements
%of lists.
%%
%Barbosa et al.'s {\em matching lenses}~\cite{Matching10} offer another 
%approach to dealing with issues of alignment in the framework of pure
%state-based lenses.  
%
%
%%% \noindent
%%% Other things we definitely need to compare to:
%%% \begin{itemize}
%%% \item Diskin's ``tile algebras'' \cite{DBLP:conf/gttse/Diskin09}
%%% \item The other delta-lens papers that Diskin refers to in the intro
%%% of~\cite{Diskin-Delta11} 
%%% \item Other papers addressing the alignment problem in different ways (e.g.,
%%% our Matching Lenses~\cite{Matching10}, Tokyo group papers such
%%% as~\cite{Mu2004} and maybe the ICFP10 paper on bidirectional graph
%%% transformations)
%%% \item Maybe some papers on edits in the context of version management (see
%%% last year's grant proposal for some citations)
%%% \item other lens-like things that have used some kind of deltas~\cite{HuModels07} 
%%% \begin{itemize}
%%% \item \finish{Meertens \cite{Meertens98} introduces edit operations in section 5.3
%%% (p. 68ff) to talk about edits to lists.  I have not grokked yet exactly how
%%% all this works, or how it fits into his general framework of constraint
%%% maintainers.  Some possible text:}
%
%%% \item 
%%% \end{itemize}
%%% \end{itemize}
%
%%% \iflater
%%% \finish{
%%% Other things to think about:
%%% \begin{itemize}
%%%     \item other research on edit lenses
%%%     \item practical tools that use notions of an edit
%%%     \item Is there any correspondence with other tools like SVN, Unison,
%%%     ...? 
%%% \item operation transform papers?
%%% \end{itemize}
%%% }
%%% \fi
%
% }}}

% dump from our complement lenses paper {{{
%
%There is a large literature on lenses and related approaches to
%propagating updates between connected structures.  We discuss only the most
%closely related work here; good general surveys of the area can be found
%in~\cite{FosterThesis,DBLP:conf/icmt/CzarneckiFHLST09}.  Connections to the
%literature on {\em view update} in databases are surveyed
%in~\cite{Focal2005-shortcite}. \iffull A short version of this paper is available
%in~\cite{HofmannPierceWagner10}.\fi
%
%The first symmetric approach to update propagation was proposed by
%Meer\-tens~\cite{Meertens98} and followed up \iffull in the context of
%model-driven design \fi by Stevens~\cite{Stevens07},
%Diskin~\cite{DBLP:conf/models/Diskin08}, and Xiong, et
%al~\cite{xiong2009supporting}.
%%
%Meertens suggests modeling synchronization between two sets
%$X$ and $Y$ by a {\em consistency relation} $R\subseteq
%X\times Y$ and two {\em consistency maintainers}
%$\triangleleft: X\times Y\rightarrow X$ and $\triangleright: X\times Y
%\rightarrow Y$ such that $(x\triangleleft y) \relR y$ and
%$x \relR (x\triangleright y)$ always hold, and such that $x \relR y$ implies
%$x \triangleleft y = x$ and $x \triangleright y = y$.
%
%The main advantage of symmetric lenses over consistency maintainers is
%their closure under composition. Indeed, all of the aforementioned
%authors note that, in general, consistency maintainers do not compose
%and view this as a drawback.
%%
%Suppose that we have relations $R\subseteq X\times Y$ and
%$R'\subseteq Y\times Z$ maintained by $\triangleright,\triangleleft$
%and $\triangleright', \triangleleft'$, resp. If we want to construct a
%maintainer for the composition $R;R'$, we face the problem that, given
%$x\in X$ and $z\in Z$, there is no canonical way of coming up with a
%$y\in Y$ that will allow us to use either of the existing maintainer
%functions. Concretely, Meertens gives the following counterexample.
%Let $X$ be the set of nonempty context free grammars over some alphabet, and let
%$Y$ be the set of words over that same alphabet. Let $R\subseteq
%X\times Y$ be given by $G \relR x\iff x\in L(G)$. It is easy to define
%computable maintainer functions making this relation a constraint
%maintainer. Composing this relation with its opposite yields an 
%undecidable relation (namely, whether the intersection of two context-free
%grammars is nonempty), so there cannot be computable maintainer functions.
%
%We can transform any constraint maintainer into a  symmetric lens as
%follows: take the relation $R$ itself (viewed as a set of pairs) as
%the complement, and define $\putl(x',(x,y))=(x'\triangleright
%y,(x',x'\triangleright y))$ and similarly 
%for $\putr$. If we compose such a symmetric lens with its opposite
%we obtain $R\times R\op$ as the complement and, for example,
%$\putr(x',((x_1,y_1),(y_2,x_2))) = 
%(x_2\triangleleft(x'\triangleright y_1), ((x',x'\triangleright
%y_1),(x'\triangleright y_1,x_2\triangleleft(x'\triangleright y_1))))$. 
%%
%For Meertens' counterexample, we would have complements of the form
%$((G_1,w_1),(w_2,G_2))$, with $w_1\in L(G_1)$
%and $w_2\in L(G_2)$; ``$\putr$''-ing a new grammar
%$G_1'$ through the composed lens yields the complement
%$((G_1',w_1'),(w_1',G_2'))$, where $w_1'$ is $w_1$ if $w_1\in L(G_1)$ and
%some default otherwise, and where $G_2'=G_2$ if $w_1'\in L(G_2)$ and
%$S{\rightarrow}w_1'$ (where $S$ is the start state) otherwise. We observe
%that there is a property of lenses analogous to Meertens' requirement that
%$x \relR y$ implies $x \triangleleft y = x$. This property is not
%necessarily preserved by composition, and in particular the lens described
%above for synchronizing languages does not have it.
%%
%Meertens recommends using a {\em chain} of consistency maintainers in such a
%situation to achieve a similar effect; however, the properties of such
%chains have not been explored.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%For asymmetric lenses, a number of alternative \iffull choices of behavioral
%\fi
%laws 
%have been explored.  Some of these are \iffull strictly \fi weaker than ours; for
%example, a number of papers from a community of researchers based in Tokyo
%replace the \rn{PutGet} law with a somewhat looser \rn{PutGetPut} law,
%permitting a broader range of useful behaviors for lenses that duplicate
%information.  It would be interesting to see what kind of categorical
%structures arise from these choices.  The proposal by Matsuda et
%al.~\cite{matsuda2007btb} is particularly interesting because it also employs
%the idea of complements.  Conversely, stronger laws can be imagined, such as
%the \rn{PutPut} law discussed by Foster et
%al.~\cite{Focal2005-shortcite}\iffull{} and the more refined variants
%in~\cite{updatable-security-views}\fi\iflater\finish{Say something more
%  about this?}\fi.
%
%A different foundation for defining lenses by recursion was explored by
%Foster et al.~\cite{Focal2005-shortcite}, using standard tools from domain
%theory to define monotonicity and continuity for lens combinators
%parametrized on other lenses.  The main drawback of this approach is that
%the required (manual) proofs that such recursive lenses are total tend to be
%somewhat intricate.  By contrast, we expect that our initial-algebra
%approach can be equipped with automatic proofs of totality (that is, choices
%of the weight function $w$) in many cases of interest.
%
%\ifdelta
%\finish{
%Updates: (note that the point in our paper is not update as such but rather
%how to marry it with lenses)  \finish{BCP will look for a good canonical
%  reference for updates}
%\begin{itemize}
%\item lens-like things that have used deltas~\cite{Hu04,Meertens98,MuAlgebraic2004,HuModels07}
%\item old update transformation
%\item old view update stuff
%\item new Waterloo stuff 
%\begin{itemize}
%\item flexibility, not efficiency
%\item no proposal for syntax---composition is the only operator they study
%at all
%\end{itemize}
%\end{itemize}
%}
%\fi
%
% }}}
