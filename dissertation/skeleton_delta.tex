\newif \ifanon  \anonfalse

\documentclass{sigplanconf}
\usepackage{paper}

\begin{document}
\conferenceinfo{POPL'12,} {January 25--27, 2012, Philadelphia, PA, USA.}
\CopyrightYear{2012}
\copyrightdata{978-1-4503-1083-3/12/01}

\title{Edit Lenses}
% \subtitle{Operation-Based Bidirectional Programming}
\ifanon
\authorinfo
    {}
    {}
    {}
\else
\authorinfo
    {Martin Hofmann}
    {Ludwig-Maximilians-Universit\"at}
    {}
\authorinfo
    {Benjamin Pierce}
    {University of Pennsylvania}
    {}
\authorinfo
    {Daniel Wagner}
    {University of Pennsylvania}
    {}
\fi

\maketitle
\begin{abstract}
A {\em lens} is a bidirectional transformation between a pair of connected
data structures, capable of translating an edit on one structure into an
appropriate edit on the other.
%
Many varieties of lenses have been studied, but none, to date, has offered a
satisfactory treatment of how edits are {\em represented}.  Many
foundational accounts~\cite{Focal2005-shortcite,HofmannPierceWagner10} only consider
edits of the form ``overwrite the whole structure,'' leading to poor
behavior in many situations by failing to track the
associations between corresponding parts of the structures when elements are
inserted and deleted in ordered lists, for example.  Other theories of
lenses do maintain these associations, either by annotating the structures
themselves with change information~\cite{HuModels07,
  Hidaka10}\iflater\discuss{I think some of Hu's earlier papers use the same
  idea; double-check}\fi{} or using auxiliary data
structures~\cite{Matching10, Diskin-Delta11}, but every extant theory assumes
that the entire original source structure is part of the information passed
to the lens.

We offer a general theory of {\em edit lenses}, which work with
descriptions of changes to structures, rather than with the structures
themselves.  We identify a simple notion of ``editable structure''---a set
of states plus a monoid of edits with a partial monoid action on the states---and
construct a semantic space of lenses between such structures, with natural
laws governing their behavior.  We show how a range of constructions from
earlier papers on ``state-based'' lenses can be carried out in this space,
including composition, products, sums, list operations, etc.  Further, we show
how to construct edit lenses for arbitrary {\em containers} in the sense of
Abbott, Altenkirch, and Ghani~\cite{1195941}. Finally, we show that edit
lenses refine a well-known formulation of state-based
lenses~\cite{HofmannPierceWagner10}, in the sense that every state-based
lens gives rise to an edit lens over structures with a simple overwrite-only
edit language, and conversely every edit lens on such structures gives rise
to a state-based lens.
\end{abstract}

\category{D.3.2}
    {Programming Languages}
    {Language Classifications}
    [Specialized application languages]
\terms Design, Languages, Theory
\keywords algebra, bidirectional programming, edit, lens, symmetric

\sect{Introduction}

Recent years have seen growing interest in {\em bidirectional
  programming languages}---domain-specific languages where a
program describes how to maintain a connection between data structures
of two different shapes, translating updates to one structure into
appropriate updates to the other.  The core concepts of bidirectional
programming have roots in early work on the database view update
problem (see~\cite{Focal2005-shortcite} for a survey); more recently, they have
been explored in diverse areas including model-driven software
development~\cite{Stevens07}, data synchronization~\cite{Focal2005-shortcite},
user interfaces~\cite{Meertens98}, and Unix system configuration
management~\cite{Augeas}.\iflater\finish{could also mention
  parsing/unparsing, ...}\fi
  
The meaning of a bidirectional program connecting a set $X$ to a set
$Y$---often called a {\em lens} from $X$ to $Y$---is intuitively a
pair of transformations, one mapping $X$ updates to $Y$ updates and
the other mapping $Y$ updates to $X$ updates, subject to some
behavioral laws specifying how the two transformations fit together.
Technically, this intuition can be realized in numerous ways.  A naive
definition is to say that a lens from $X$ to $Y$ is just
a pair of functions, $f \in X \to Y$ (telling how to map an updated
$X$ state to an appropriate $Y$ state) and $g \in Y \to X$.  But this
is too simple: if the lens laws impose the reasonable requirement that
$f$ and $g$ should ``round trip,'' then our bidirectional programs
will only denote bijections---an important but limited special case.
%
To allow for situations where each structure can contain a mixture of
information that is shared with the other and information that is not,
something more than just the updated structure must be given as input
to the transformations.

Different variants of lenses differ as to what this ``something more''
should be.  We might, for example, give the transformation from $X$ to
$Y$ both a new $X$ and an old $Y$---i.e., $f \in X \times Y \to
Y$---with the intention that $f$ should weave together the ``shared''
information from the new $X$ with the ``local'' information from the
old $Y$ to produce a new $Y$.  Or instead of a whole
$Y$, we might pass $f$ some smaller structure (a {\em complement})
representing just 
the information that is needed to build an updated $Y$ out of an
updated $X$.  Or perhaps one of these plus some additional information
about the {\em alignment} of the updated information (e.g., ``a new
element was inserted at the beginning of this list, so the second
element in the new $X$ corresponds to the first element in the old
$Y$''), either in the form of an auxiliary data structure or
perhaps somehow embedded as annotations in the updated $X$ itself.
 
What all these variants have in common is that the inputs to a lens
always include the {\em whole} updated state.  This leaves an
unfortunate gap between the theory and practical realizations, which
generally represent updates in some simpler, more compact form that
only describes what has changed in a possibly large structure.

In this paper, we offer the first foundational treatment
of {\em edit lenses}---lenses that operate directly on edits, rather
than on whole structures.
%
Our theory of edit lenses is built from simple and familiar algebraic
structures (\S \ref{sec:semantics}).
%
It supports a wide range of fundamental syntactic
constructions---composition, products, sums, list operations,
etc.---allowing us to construct lenses for complex data structures
together with appropriate representations for edits in a
compositional fashion (\S \ref{sec:combinators}).
%
Indeed, the theory includes a general account of how to construct
``mapping'' lenses for a wide class of {\em container} data
structures~\cite{1195941} such as lists and trees (\S
\ref{sec:containers}).  This rich set of syntax constructors should
form a suitable basis for the design of new bidirectional languages,
for example in the style of Boomerang~\cite{Matching10}.
%
Our theory can support a wide variety of {\em edit languages}.  We mostly
concentrate on the simplest form, where compound edits are freely
generated from some set of atomic edits; \S \ref{sec:monoid-laws}
considers the extension to richer languages with additional algebraic laws.
%
Finally, our theory generalizes and refines the
state-based {\em symmetric lenses} of Hofmann, Pierce, and
Wagner~\cite{HofmannPierceWagner10} in a precise sense (\S
\ref{stateb}).  \iffull

\fi
The paper ends with \iffull a brief exploration of the relation between our
semantic space of edit lenses and previous formulations of lenses in which
edits are viewed in the more structured setting of arrows in a category
rather than simply elements of a monoid (\S \ref{cats}), \fi a discussion of
related work (\S \ref{sec:related})\iffull,\fi{} and some remarks on future
directions (\S \ref{sec:concl}).

\iflater \finish{Our development relies on some standard constructions
  from abstract algebra, which we review these as we come to them, for
  the sake of self-containedness.  Familiarity with previous work on
  lenses is not assumed.}  \fi

\iflater
\finish{Make sure we hit these points:
\item Why was this hard?  What aspects of {\edit}-lenses were challenging to
figure out?
\item Why is our solution canonical?  Does it settle issues that others have
struggled with?
}
\fi

\input{delta}

\sect{Related Work}\label{sec:related}

The most closely related attempt at developing a theory of update
propagation is \cite{Diskin-Delta11} by Diskin et al. Their starting
point is the observation (also discussed in \cite{Matching10}) that discovery of
edits should be decoupled from their propagation. They thus propose a
formalism, \emph{sd-lenses}, for the propagation of edits across
synchronized data structures, bearing some similarities with our
edit lenses. The replicas, which we model as modules, are there modeled
as categories (presented as reflexive graphs)\iffull, as we discussed in 
\S \ref{cats}\fi. Thus, for any two states $x,x'$ there is a set of
edits $X(x,x')$. An sd-lens then comprises two reflexive graphs $X,Y$
and for any $x\in X$ and $y\in Y$ a set $C(x,y)$ of
``correspondences'' which roughly correspond to our
complements. Forward and backward operations similar to our $\dputl$ and
$\dputr$ then complete the picture. No concrete
examples are given of sd-lenses, no composition, no notion of equivalence, and
no combinators for constructing sd-lenses; the focus of the paper is
rather on the discovery of suitable axioms, such as invertibility and
undoability of edits, and a 
generalization of {\em hippocraticness} in the sense of
Stevens~\cite{Stevens07}. They also develop a comparison 
with the state-based framework (cf.\ \S \ref{stateb} above). In
our opinion, the separation of edits and correspondences according to
the states that they apply to or relate has two important
disadvantages.  First, in our examples, it is often the case that one
and the same edit applies to more than one state and can be
meaningfully propagated (and more compactly represented) as such. For example, while many of the
container edits tend to only work for a particular shape, they are
completely polymorphic in the contents of the container. Second, the
fact that state sets are already categories suggests 
that a category of sd-lenses would be
2-categorical in flavor, entailing extra technical difficulties such as
coherence conditions. 

%% \finish{Here's a quick start from a brief scan of their most recent
%%   paper~\cite{Diskin-Delta11} by BCP...
%%   \begin{itemize}
%%   \item Their motivations and goals are exactly the same.
%%   \item The technicalities of their approach are pretty dense.  I haven't
%%   internalized them yet.  In particular, I don't have a good intuition for
%%   their ``sameness'' relations---what they say makes sense for ``flat''
%%   structures like lists or simple graphs, but not for more structured data
%%   (where you'd want to know about correspondences at various levels of
%%   structure). 
%%   \item They don't say anything about the size of their deltas, and at
%%   least a naive representation would be big.  We're much more careful about
%%   this. 
%%   \item They propose two new laws (weak invertability and undoability).  I'm
%%   not sure what to say about these, but I guess it's an important point of
%%   comparison, since it's one of the main points of their paper.
%%   \item They don't handle $\missing$ (a small point)
%%   \item They don't define any combinators, just the semantic space itself (a
%%   larger point, and related) 
%%   \item Their Definition 19 and Theorem 5 relate their delta-lenses to our
%%   symmetric lenses.  I'm not completely sure how to interpret it (does our
%%   ``trivial module'' correspond to their ``simple graph''?), but in any case
%%   our result is stronger because it goes both directions.  (Their
%%   characterization of our symmetric lenses is a little bit wrong---it puts
%%   $C$ in the wrong place---but I'm not sure this matters.)
%%   \end{itemize}
%% }

Meertens's seminal paper on {\em constraint maintainers}~\cite{Meertens98}
discusses a form of containers for lists equipped with a notion of edits
similar to our edit language for lists, but does not develop a general
theory of edit-transforming constraint maintainers.

A long series of papers from the group at the University of Tokyo
\cite[etc.]{Hu04, Mu2004, MuAlgebraic2004, HuModels07,
  Hidaka10}\iffull\discuss{double-check these, and add more, and add to abstract
  too}\fi{} deal with the alignment issue using an approach that might be
characterized as a hybrid of state-based and edit-based.  Lenses work with
whole states, but these states are internally annotated with tags showing
where edits have been applied---e.g., marking inserted or deleted elements
of lists.
%
Barbosa et al.'s {\em matching lenses}~\cite{Matching10} offer another 
approach to dealing with issues of alignment in the framework of pure
state-based lenses.  


%% \noindent
%% Other things we definitely need to compare to:
%% \begin{itemize}
%% \item Diskin's ``tile algebras'' \cite{DBLP:conf/gttse/Diskin09}
%% \item The other delta-lens papers that Diskin refers to in the intro
%% of~\cite{Diskin-Delta11} 
%% \item Other papers addressing the alignment problem in different ways (e.g.,
%% our Matching Lenses~\cite{Matching10}, Tokyo group papers such
%% as~\cite{Mu2004} and maybe the ICFP10 paper on bidirectional graph
%% transformations)
%% \item Maybe some papers on edits in the context of version management (see
%% last year's grant proposal for some citations)
%% \item other lens-like things that have used some kind of deltas~\cite{HuModels07} 
%% \begin{itemize}
%% \item \finish{Meertens \cite{Meertens98} introduces edit operations in section 5.3
%% (p. 68ff) to talk about edits to lists.  I have not grokked yet exactly how
%% all this works, or how it fits into his general framework of constraint
%% maintainers.  Some possible text:}

%% \item 
%% \end{itemize}
%% \end{itemize}

%% \iflater
%% \finish{
%% Other things to think about:
%% \begin{itemize}
%%     \item other research on edit lenses
%%     \item practical tools that use notions of an edit
%%     \item Is there any correspondence with other tools like SVN, Unison,
%%     ...? 
%% \item operation transform papers?
%% \end{itemize}
%% }
%% \fi

\sect{Conclusion}\label{sec:concl}

A prototype Haskell implementation of edit lenses is underway, as well as a
demo showing how to construct GUIs connected by lenses. 
The main required extension to the theory presented here are extending the
above constructions from algebraic data structures to strings, following
Boomerang~\cite{Boomerang07}, and identifying good heuristics for
converting unstructured string edits into structured edits of the form
expected by the lenses above---a form of parsing and unparsing.

Containers offer a convenient abstraction on which to build generic lens
combinators, as discussed in \S \ref{sec:containers}. To use these
combinators in practice, we need to show how to instantiate the module of
\emph{shapes} for the kind of container we are interested in, as we did for
lists. In the future, we would like to explore several other sorts of
shapes; in particular, edit languages for graphs may be useful in
model-driven development, while edits for relations are relevant to database
applications.

\ifanon \else \paragraph*{Acknowledgments}
We are grateful to
Nate Foster and Perdita Stevens for productive discussions of many points,
to the members of the Penn PL Club for comments on an early draft, to
the organizers and participants in the January 2011 Dagstuhl seminar on
Bidirectional Transformations for creating a stimulating environment for work
in this area, and to the POPL reviewers for their thoughtful suggestions.  Our work has been supported by the National Science 
Foundation under grants 0534592, \emph{Linguistic Foundations for XML View
  Update}, and 1017212, \emph{Algebraic Foundations for Collaborative Data
  Sharing}.  \fi

\let\section\OLDsection

\iffull\else\vfill\eject\fi
\bibliographystyle{plainnat}
\bibliography{bcp,harmony,complement,delta}

\end{document}

\iffull
\clearpage\ \clearpage
\section{Old material from here on -- needs reintegrated or deleted}

\discuss{Which bits of this are we keeping?  I guess none of them...}

\begin{defn}
    Given functions
    \begin{align*}
        f &\in X \times C \to Y \times C \\
        g &\in Y \times C \to X \times C
    \end{align*}
    and values $(x,c,y) \in X \times C \times Y$, we will say $(x,c,y)$ is:
    \begin{itemize}
        \item \emph{stable} in $f$, written $x \stable[f]c y$, when
            $f(x,c)=(y,c)$, and
        \item \emph{consistent} with $f$ and $g$, written $x \bistablex gfc
            y$, when $x \stable[f]c y$ and $y \stable[g]c x$.
    \end{itemize}
\end{defn}
Whenever either $f$ or $g$ are clear from context, we will omit them.

\begin{defn}
    Given monoids $M$ and $N$, a \emph{stateful monoid homomorphism} over
    state set $C$ is a function $h \in M \times C \to N \times C$ that
    satisfies two laws:
    \infax{\ONE \stable[h]{c} 0}
    \infrule{h(m,c) = (n,c') \\ h(m',c') = (n',c'')}
            {h(m \cdot_M m',c) = (n \cdot_N n',c'')}
\end{defn}

Stateful monoid homomorphisms model the functions that translate edits to
one kind of structure into edits to another kind of structure. The second
law is the more complicated of the two; it says that if an edit can be
broken down into smaller component edits, then translating those smaller
components in turn gives the same result as translating the whole big edit
all at once.

\dmwit{fold this into the definition of edit lenses + give a discussion
motivating these laws; for example, how do these laws specialize when the
monoid is the boring one that has only eliminators?}

\mxh{For any set $C$ and monoid $M$ we can define a new monoid structure on 
                 $C\rightarrow C \times M$ where $f.g(c) = 
\text{let}\  c_1,m_1=g(c)\text{ in let }c2,m2=f(c1)\text{ in } 
                             (c2,m2.m1)$. 

       In that sense a stateful morphism is subsumed under ordinary morphism.}

\begin{defn}
    Given modules $M$ for $X$ and $N$ for $Y$, a \emph{stateful module
    transformer}\footnote{The definition of a stateful module transformer is
    almost, but not quite, what you might expect to see in the definition of
    a stateful module homomorphism. We will see why in
    \S \finish{??}.} is a pair
    $(h,f)$ of a stateful monoid 
    homomorphism $h$ and a function $f \in X \times C \to Y \times C$ for
    which:
    \infrule{x \stable[f]{c} y \\ h(m,c) = (n,c')}
            {m \odot_X x \stable[f]{c'} n \odot_Y y}
\end{defn}



\begin{defn}
\bcp{What is this a definition of??}
 a stateful module transformer
    $(\dputr,\putr)$ from $M$ to $N$, and a stateful module transformer
    $(\dputl,\putl)$ from $N$ to $M$, satisfying the round-trip laws
    \infrule{\putr(x,c) = (y,c')}{x \bistable{c'} y}
    \infrule{\putl(y,c) = (x,c')}{y \bistable{c'} x}
\end{defn}

We will write $\ell \in M \lens N$ when $\ell$ is a symmetric edit lens
between $M$ and $N$, and use record projection notation like $\ell.\missing$
and $\ell.\dputr$ to refer to its components.  Taking some ideas from
bisimulation arguments, we can model lens equivalence by comparing
observations.

\begin{defn}
    Functions $f \in X \times C_f \to Y \times C_f$ and $g \in X \times C_g
    \to Y \times C_g$ are said to be \emph{$R$-similar}, written $f \sim_R
    g$, when
    \infrule{c_f \relR c_g \\ f(x,c_f) = (y_f,c_f') \\ g(x,c_g) = (y_g,c_g')}
            {y_f = y_g \land c_f' \relR c_g'}
\end{defn}

\begin{defn}
    We will write $k \equiv \ell$ when there is a relation $R \in k.C \times
    \ell.C$ that connects each of the five components of $k$ and $\ell$:
    \begin{enumerate}
        \item $k.\missing \relR \ell.\missing$
        \item $k.\putr \sim_R \ell.\putr$
        \item $k.\putl \sim_R \ell.\putl$
        \item $k.\dputr \sim_R \ell.\dputr$
        \item $k.\dputl \sim_R \ell.\dputl$
    \end{enumerate}
\end{defn}

\begin{defn}
    An \emph{edit-only} lens $\ell$ between modules $M$ and $N$ for $X$ and
    $Y$, written $\ell \in M \dlens N$, is a tuple
    $\left<C,\creater,\createl,\dputr,\dputl\right>$, where $\creater \in X
    \to Y \times C$, $\createl \in Y \to X \times C$, and $\dputr$ and
    $\dputl$ are stateful monoid homomorphisms from $M$ to $N$ and $N$ to
    $M$, respectively.
\end{defn}

\begin{defn}
    An edit-only lens $\ell \in X \dlens Y$ is \emph{well formed} when there
    is a full edit lens $\ell' \in X \lens Y$ and a relation $R \in \ell.C
    \times \ell'.C$ such that
    \infrule{\ell.\creater(x) = (y, c) \\ \ell'.\putr(x,\ell'.\missing) =
    (y', c')}{y = y' \land c \relR c'}
    \infrule{c_i \relR c_i' \\ \ell.\dputr(m,c_i) = (n,c_o) \\
    \ell'.\dputr(m,c_i') = (n',c_o')}{n = n' \land c_o \relR c_o'}
    and similarly for $\ell.\createl$ and $\ell.\dputl$.
\end{defn}

The advantage of edit-only lenses is that they may store much less
information in their complements; indeed, many practical lenses have a
corresponding edit-only lens with a $\Unit$ complement. However, the
$\createl$ and $\creater$ have much weaker behavioral guarantees than
$\putr$ and $\putl$. If the lens is expected to be able to occasionally do a
``best-effort reboot'' with a new state (and not an edit), a full edit lens
may do much better than an edit-only lens.

\section{Another old section --- Edit Lenses}

Shortcomings of ordinary (state-based) symmetric lenses:
\begin{itemize}
\item inefficient
\item no alignment
\end{itemize}

Write something about ``generic edits'' vs. ``specific edits.''  We are
considering specific edits.

Discuss monoids of edits vs. sets of edits.  Mostly you want just the free
monoid, so then sets of fundamental edits is enough.  But there are some
important cases where the monoid structure is revealing:
\begin{itemize}
\item having a neutral element simplifies the definitions (e.g., the
product: you can just say a product edit is a pair of an edit on the left
instead and an edit on the right, rather than ``an edit on the left OR an
edit on the right OR both...'')
\item the product, for example, does have interesting laws: edits on the
left and on the right don't affect each other
\end{itemize}

Discuss the law making dput compatible with composition.  There is no loss
of power in doing so: we can always ``disable'' the law in particular cases
if desired by taking the free monoid over some other monoid.  

Note that there is a fundamental tension between rich lens languages vs.
rich edit languages.  Here we're exploring the former and keeping the latter
rather basic---just ``rigid edits'' for most of the type constructors plus
insert/delete edits for lists.  Much richer edit languages can be imagined
(even for lists: we might well want to be able to swap the first and second
elements of a list while maintaining their connection to the hidden
information in the other view), but we're not there yet.  Moreover, we don't
know how to generalize the construction of iterators so as to obtain
something more interesting than the completely rigid edit language (without
insert/delete) for lists.

Also discuss monoids of edits vs edits=certain functions. An edit
induces a functions vs an edit is a function. Issue: a delete followed
by an insert edit *is* the identity function, but may be translated to
a non-identity edit in a richer view. Edits as monoid elements allows
for such intensional information to be kept.
\paragraph*{Notation}
We write $G^*$ for the set of sequences of elements of $G$; that is, if
$g_1,\ldots,g_n \in G$, then $\left<g_1,\ldots,g_n\right> \in G^*$. When
convenient, we will omit the braces and commas, writing simply $g_1 \cdots
g_n$.  For equivalence relation $\equiv$, we write $S/\equiv$ for the set of
equivalence classes of $S$, and for each $s \in S$, we write $[s]_\equiv \in
S/\equiv$ for the equivalence class of $s$. When context makes the
equivalence relation clear, we simply write $[s]$.

\paragraph*{Definitions}

A \emph{monoid} is a triple $\left<S,1,\cdot\right>$ consisting of a set
$S$, a distinguished element $1 \in S$, and an associative binary operation
$\cdot \in S \times S \to S$ for which $1$ is an identity. When no confusion
can arise, we will abbreviate $s \cdot t$ as simply $st$.

One way of specifying a monoid is to give its \emph{monoid presentation},
which consists of a set of generators $G$ and a binary relation $R \subset
G^* \times G^*$ that can be understood as giving equalities over words
composed from alphabet $G$. Formally, we close $R$ over reflexivity,
symmetry, transitivity, and congruence, defining a new equivalence
relation $\equiv_R$:
\infrule{s \relR t}{s \equiv_R t}
\infax{s \equiv_R s}
\infrule{s \equiv_R t}{t \equiv_R s}
\infrule{s \equiv_R t \andalso t \equiv_R u}{s \equiv_R u}
\infrule{s \equiv_R t}{usv \equiv_R utv}
The induced monoid then has the quotient $G^*/\equiv_R$ as its set, the
equivalence class of the empty sequence $[\left<\right>]$ as its unit $1$,
and sequence concatenation $[s]\cdot[t] = [st]$ as its associative binary
operation. (It is easy to show that this last operation is well defined
because $\equiv_R$ is congruence-closed.)

A \emph{monoid action} is a function $\cdot \in M \times X \to
X$, where $M$ is a monoid and $X$ is a set, that satisfies two laws:
\begin{eqnarray*}
            1 \cdot x &=& x \\
            (mn)\cdot x &=& m\cdot(n\cdot x)
\end{eqnarray*}
%
A \emph{module} is a triple $\left<M,X,\cdot\right>$ where $M$ is a monoid,
$X$ is a set, and $\cdot$ is a monoid action; when there is no ambiguity, we
will use $M$ to refer to both the module and the monoid in that module, and
we will use juxtaposition to indicate both the monoid multiplication and the
monoid action.
%        
A \emph{module homomorphism} between $\left<M,X,\cdot\right>$ and
$\left<N,Y,\tr\right>$ is a pair $(h,f)$ of a monoid homomorphism $h \in M
\to N$ and a function $f \in X \to Y$ that preserves the edits, that is, for 
which 
\[f(mx) = h(m)f(x).\]

When $M$ is a monoid presented via $G$ and $R$, we may also define a module
presentation. Abusing notation slightly, we may lift a function $f \in G
\times X \to X$ to a function $f^* \in G^* \times X \to X$ in the natural
way:
\begin{align*}
    f^*(\left<\right>,x) &= x \\
    f^*(g_1 \cdots g_n,x) &= f(g_1,f^*(g_2 \cdots g_n,x))
\end{align*}
If it also turns out that $f^*$ is consistent with respect to $R$:
\[g \relR g' \implies f^*(g,x) = f^*(g',x),\]
then $f^*$ may be lifted a second time to a monoid action
$f^R([g],x)=f^*(g,x)$. We can show that $f^R$ is well defined
because of the consistency of $f^*$, and that it is a monoid action by
definition.

\begin{defn}[Edit asymmetric lenses]
A $\Delta$-asymmetric-lens $\ell$ mapping from module
$\left<M,X,\cdot\right>$ to module $\left<N,Y,\tr\right>$, written $\ell \in
\left<M,X,\cdot\right> \alens \left<N,Y,\tr\right>$, comprises five
functions:
\begin{align*}
    \aget    &\in X \to Y \\
    \aput    &\in Y \times X \to X \\
    \acreate &\in Y \to X \\
    \adget   &\in M \times X \to N \\
    \adput   &\in N \times Y \to M
\end{align*}

These functions must obey several laws. The round-trip laws must hold:
\infax[CreateGet]{\aget(\acreate(y))=y}
\infax[PutGet]{\aget(\aput(y,x))=y}
\infax[GetPut]{\aput(\aget(x),x)=x}
We also require that $\adget$ be a monoid homomorphism, and that $\adput$
have a similar property:
\infax[DPut1]{\adput(1,x)=1}
\infrule[DPut$\cdot$]
    {\adput(n,x)=m \\ \adput(n',mx)=m'}
    {\adput(nn',x)=mm'}
\dmwit{Do we require that $\adget(\adput(n,x))=n$? If so, \rn{PutDPut}
below is redundant.}
Finally, we require that the non-delta and delta versions of the functions
behave consistently:
\infrule[GetDGet]{\aget(x)=y \\ \adget(m)=n}{\aget(mx)=ny}
\infrule[PutDPut]{\aget(x)=y \\ \adput(n,x)=m}{\aget(mx)=ny}
\end{defn}

\begin{defn}[Edit symmetric lenses]
A $\Delta$-symmetric-lens $\ell$ (or simply $\Delta$-lens) mapping from
module $\left<M,X,\cdot\right>$ to module $\left<N,Y,\tr\right>$, written
$\ell \in \left<M,X,\cdot\right> \lens \left<N,Y,\tr\right>$ comprises
complement set $C$, an element $\missing \in C$, and four functions
\begin{eqnarray*}
    \putr  &\in& X \times C \to Y \times C \\
    \putl  &\in& Y \times C \to X \times C \\
    \dputr &\in& M \times C \to N \times C \\
    \dputl &\in& N \times C \to M \times C
\end{eqnarray*}
obeying several laws.
%
First, we have the same round-trip laws as before for the plain $\PUT$s:
%
\infrule[PutRL]{\putr(x,c) = (y,c')}{\putl(y,c') = (x,c')}
\infrule[PutLR]{\putl(y,c) = (x,c')}{\putr(x,c') = (y,c')}
%
Second, $\dputr$ and $\dputl$ must be compatible with the monoid structure:
%
\infax[dputr1]{\dputr(1,c) = (1,c)}
\infax[dputl1]{\dputl(1,c) = (1,c)}
\infrule[dputr$\cdot$]
    {\dputr(m,c) = (n,c') \\ \dputr(m',c') = (n',c'')}
    {\dputr(mm',c) = (nn',c'')}
\infrule[dputl$\cdot$]
    {\dputl(n,c) = (m,c') \\ \dputl(n',c') = (m',c'')}
    {\dputl(nn',c) = (mm',c'')}
%
And third, $\PUT$s and $\DPUT$s must behave consistently:
        \infrule[putr-dputr]{
            \putr(x,c) = (y, c) \\
            \dputr(m,c) = (n,c')
        }
        {\putr(mx,c') = (ny,c')}
        \infrule[putl-dputl]{
            \putl(y,c) = (x, c) \\
            \dputl(n,c) = (m,c')
        }
        {\putl(ny,c') = (mx,c')}
    \finish{we should add a note about coercing arbitrary edit languages to
    be monoids via the free monoids, and the compatibility of these laws
    with that construction}
\end{defn}

\paragraph*{Presented lenses}
When the monoid included in a module is defined via a presentation, it is
often convenient to define the $\dputr$ or $\dputl$ function by giving its
behavior on the generators of the monoid. Formally, suppose we have a monoid
presentation given by generators $G$ and equalities $R$, another monoid
$\left<M,1,\cdot\right>$, and function $f \in G \times C \to M \times C$.
Giving yet another meaning to $(-)^*$ and $(-)^R$, we define:
\begin{align*}
    f^* \in{}& G^* \times C \to M \times C \\
    f^*(\left<\right>,c) ={}& (1,c) \\
    f^*(g_1 \cdots g_n,c) ={}& \mllet (m,c') = f(g_n,c) \mline \\
    & \mllet (m',c'') = f^*(g_1 \cdots g_{n-1},c') \mline \\
    & (m \cdot m',c'') \\
    f^R \in{}& G^*/\equiv_R \times C \to M \times C \\
    f^R([g]) ={}& f^*(g)
\end{align*}
Suppose we can show the following thing:
\[g \relR g' \implies f^*(g,c) = f^*(g',c)\]
Then the following things are true:
\begin{enumerate}
    \item $f^R$ is well defined -- that is, $f^*$ respects equivalence
        classes of $\equiv_R$
    \item $f^R$ respects the monoid structure -- e.g. would satisfy both
        \rn{dputr1} and \rn{dputr$\cdot$} or both \rn{duptl1} and
        \rn{dputl$\cdot$}
\end{enumerate}
Similarly, suppose we can show that $f$ respects $\ell.\putr$:
\infrule{\ell.\putr(x,c) = (y,c) \andalso f(g,c) = (m,c')}{\ell.\putr([\left<g\right>]x,c') = (my,c')}
Then $f^R$ would satisfy the \rn{putr-dputr} law (and a similar condition
can establish the \rn{putl-dputl} law).
\PENDING{are these three things really true?}

Some discussion here:
\begin{itemize}
    \item gives a nice compact condition to check to verify the dput laws
    \item gives a nice compact way to specify the dputr and dputl functions
        in the first place
    \item edit monoids and lens design must go in lockstep!
        \begin{itemize}
            \item one choice: use only free monoids (e.g. presented monoids
                with empty equation relations $R$)
            \item positive: need not prove anything at all -- any generated
                lens will satisfy all the laws
            \item downside: doesn't accommodate ``optimization'' such as you
                might do when actually implementing this
            \item example: when doing several edits deep in a list, you want
                to transmit the depth once, then all the edits
            \item but, as you add equations to one monoid, the lenses you
                have made that muck with that monoid induce equations on the
                monoid on their other side! (e.g. if $\ell \in M \to N$,
                adding equations to $M$ means you must add the analogous
                equations in $N$, where ``analogous'' means exactly the
                $\ell$-translation of those equations)
            \item in particular, if monoids $M$ and $N$ are generated by $G$
                but have different equations, you can't write an identity
                lens between them that does nothing to the generators!
            \item other choices: have as many equations as possible, have
                only ``congruence'' equations (e.g. head $m$; head $m'$ =
                head $m;m'$)
            \item should explore both options in this paper in some way (Martin: what exactly are the two options here?)
        \end{itemize}
    \item some kind of equation-polymorphism possible?
\end{itemize}

\paragraph*{Equivalence} The definition of equivalence is a straightforward
generalization of the one for plain symmetric lenses.

\begin{defn}
We say $k \equiv \ell$ if there is a relation $R$ such that
        \begin{enumerate}
            \item $(k.\missing,\ell.\missing) \in R$
            \item $k.\putr \sim_R \ell.\putr$
            \item $k.\putl \sim_R \ell.\putr$
            \item $k.\dputr \sim_R \ell.\dputr$
            \item $k.\dputl \sim_R \ell.\dputl$
        \end{enumerate}
\end{defn}

\PENDING{is it an equivalence relation? seems pretty likely}
\finish{we can skip observational equivalence, I think (BCP)}

We use $\ell \in X \Lens Y$ for equivalence classes.

\paragraph*{Definitions}

\iflater
\section{Recursive Edit Lenses}

\formartin{Zippers?  Paths?  (relevant paper by McBride --- The Derivative of
  a Regular Type is its Type of One-Hole Contexts)}

%% A_X = {e} union P_X . A_X
%% A_A = P_A union P_x . A_A

%% P_X and P_A are parameters
%% A_X and A_A are defined by these
\fi



\iflater
\section{Edit String Lenses}

\finish{We're probably also suppressing this material.}


\begin{itemize}
    \item as before, use $\mathit{copy}_R = \id_R$ and $\mathit{clobber}_{Rx} =
        \const_{Rx}$ from normal $\Delta$-lenses (and composition, too)
    \item for concat, we continue to use the $k.\ell = \bij_f;(k \otimes
        \ell); \bij_g\op$ definition for $\dputr$ and $\dputl$
    \item also still use $\ell^* = \bij_f;\ell\LIST;\bij_g\op$

    \PENDING{haven't defined the delta-lens $\ell\LIST$}
    \item Given modules $\M=\left<M,X,\cdot\right>$ and
        $\N=\left<N,Y,\tr\right>$, define the set
        $E_{\M\N}$ as follows
        \infrule{m \in M}{\mlstay_l m \in E_{\M\N}}
        \infrule{n \in N}{\mlstay_r n \in E_{\M\N}}
        \infrule{x \in X \qquad x \notin Y}{\mlswitch_l x \in E_{\M\N}}
        \infrule{y \notin X \qquad y \in Y}{\mlswitch_r x \in E_{\M\N}}
        Define the $\dot\tr \in E_{\M\N} \to X \cup Y \to X \cup Y$
        operation by
        \[\begin{array}{rclr}
            \mlstay_l m \dtrrel x &=& mx & x \in X \\
            \mlstay_l m \dtrrel y &=& y  & y \notin X \\
            \mlstay_r n \dtrrel x &=& x  & x \notin Y \\
            \mlstay_r n \dtrrel y &=& ny & y \in Y \\
            \mlswitch_l x \dtrrel x &=& x \\
            \mlswitch_r y \dtrrel x &=& y
        \end{array}\]
        Finally, define $M|N$ to be the free monoid generated by
        $E_{\M\N}$, lift $\dot\tr$ to be a monoid action
        $\dot\tr\LIST$ in the obvious way, and define the module
        $\M|\N = \left<M|N,X \cup Y,\dot\tr\LIST\right>$.

        \PENDING{go on\dots}
\end{itemize}
\fi

\paragraph*{Lists}

construct edit monoid using ideas from above -- but not quite using
generators and equalities in exactly the same way because we want the
generators to be defined ``inductively''

so we build the monoid $L_M$ of edits to lists of elements from the module
$M$ by hand:

\infax[Empty]{\left<\right> \in L_M}
\infax[Swap]{\left<\mlswap\right> \in L_M}
\infax[Del]{\left<\mldelete\right> \in L_M}
\infrule[Ins]{x \in X}{\left<\mlinsert x\right> \in L_M}
\infrule[Head]{m \in M}{\left<\mlhead m\right> \in L_M}
\infrule[Tail]{m \in L_M}{\left<\mltail m\right> \in L_M}
\infrule[Append]{\left<m_1,\ldots,m_n\right> \in L_M \andalso
\left<m_{n+1},\ldots,m_{n'}\right> \in L_M}{\left<m_1,\ldots,m_{n'}\right>
\in L_M}

the only thing that makes this different from a monoid presentation is that
the $\mltail -$ generators take sequences of other generators, not elements
from the underlying monoid $M$

as with monoid presentations, we can quotient by some equalities, build up
module presentations and lens presentations, etc.

good choices for equalities include (where here ``good choices'' means only
that the application function respects them, and not that any particular
lenses respect them -- we leave that discussion for each lens, since it
varies):

(without swap for now)

\infrule{m=m'}{\mltail m=\mltail{m'}}
\begin{align*}
    \mlhead1 &= \left<\right> \\
    \mltail{\left<\right>} &= \left<\right> \\
    \mlinsert v\ \mldelete &= \left<\right> \\
    \mlhead m\ \mldelete &= \left<\right> \\
    \mltail m\ \mldelete &= \mldelete\ m \\
    \mlinsert v\ \mlhead m &= \mlinsert{mv} \\
    \mlinsert v\ \mltail m &= m\ \mlinsert v \\
    \mlhead m\ \mlhead{m'} &= \mlhead{mm'} \\
    \mlhead m\ \mltail{m'} &= \mltail{m'}\ \mlhead m \\
    \mltail m\ \mltail{m'} &= \mltail{mm'}
\end{align*}

(now rules that include swap)

\begin{align*}
    \mlswap\ \mldelete &= \mltail\mldelete \\
    \mlinsert v\ \mlswap &= \mltail{\mlinsert v} \\
    \mlhead m\ \mlswap &= \mlswap\ \mltail{\mlhead m} \\
    \mlswap\ \mlhead m &= \mltail{\mlhead m}\ \mlswap \\
    \mlswap\ \mlswap &= \left<\right> \\
    \mlswap\ \mltail\mldelete &= \mldelete \\
    \mlswap\ \mltail{\mlinsert v} &= \mlinsert v\ \mltail\mlswap\ \mlswap \\
    \mlswap\ \mltail\mlswap &= \mltail\mlswap\ \mlswap\ \mltail\mlswap\ \mlswap \\
    \mlswap\ \mltail{\mltail m} &= \mltail{\mltail m}\mlswap \\
    \mlinsert v\ \mlswap &= \mltail{\mlinsert v} \\
    \mltail{\mlinsert v}\ \mlswap &= \mlinsert v \\
    \mltail\mlswap\ \mlswap &= \mlswap\ \mltail\mlswap\ \mlswap\ \mltail\mlswap
\end{align*}

Not all of these rules are independent.

for map:

\begin{align*}
    f(\mlswap,c_1c_2\bar c) &= (\mlswap,c_2c_1\bar c) \\
    f(\mldelete,c_1\bar c) &= (\mldelete,\bar c) \\
    f(\mlinsert x,\bar c) &= \mathrm{munge}(\ell.\putr(x,\ell.\missing),\bar c) \\
    f(\mlhead m,c_1\bar c) &= \mathrm{munge}(\ell.\dputr(m,c_1),\bar c) \\
    f(\mltail m,c_1\bar c) &= \mathrm{munge}(f^*(m,\bar c),c_1) \\
\end{align*}

any equations (that respect the application function) are fine, so long as
the same equations are available on both sides

for partition's $\dputr$:

\begin{align*}
    f(\mlswap,\true\ \false\ \bar c) &= (\left<\right>,\false\ \true\ \bar c) \\
    f(\mlswap,\false\ \true\ \bar c) &= (\left<\right>,\true\ \false\ \bar c) \\
    f(\mlswap,\false\ \false\ \bar c) &= (\mlonl\mlswap,\false\ \false\ \bar c) \\
    f(\mlswap,\true\ \true\ \bar c) &= (\mlonr\mlswap,\true\ \true\ \bar c) \\
    f(\mldelete,\false\ \bar c) &= (\mlonl\mldelete,\bar c) \\
    f(\mldelete,\true\ \bar c) &= (\mlonr\mldelete,\bar c) \\
    f(\mlinsert{\mlinl x},\bar c) &= (\mlonl{\mlinsert x},\false\ \bar c) \\
    f(\mlinsert{\mlinr y},\bar c) &= (\mlonr{\mlinsert y},\true\ \bar c) \\
    f(\mlhead{\mlstayl m},\false\ \bar c) &= (\mlonl{\mlhead m},\false\ \bar c) \\
    f(\mlhead{\mlstayr n},\false\ \bar c) &= (\left<\right>,\false\ \bar c) \\
    f(\mlhead{\mlswitchl x},\false\ \bar c)
        &= (\mlonl{\mlinsert x}\mlonl\mldelete,\false\ \bar c) \\
    f(\mlhead{\mlswitchr y},\false\ \bar c)
        &= (\mlonr{\mlinsert y}\mlonl\mldelete,\true\ \bar c) \\
    f(\mlhead{\mlstayl m},\true\ \bar c) &= (\left<\right>,\true\ \bar c) \\
    f(\mlhead{\mlstayr n},\true\ \bar c) &= (\mlonr{\mlhead n},\true\ \bar c) \\
    f(\mlhead{\mlswitchl x},\true\ \bar c)
        &= (\mlonl{\mlinsert x}\mlonr\mldelete,\false\ \bar c) \\
    f(\mlhead{\mlswitchr y},\true\ \bar c)
        &= (\mlonr{\mlinsert y}\mlonr\mldelete,\true\ \bar c) \\
        f(\mltail m,c_1\bar c) &= \mathrm{munge}(f^*(m,\bar c),c_1)
\end{align*}

for partition's $\dputl$:

\begin{align*}
    f(\mlonl m,\true\ \bar c) &= \mathrm{munge}(f^*(m,\bar c),\true) \\
    f(\mlonr m,\false\ \bar c) &= \mathrm{munge}(f^*(m,\bar c),\false) \\
    % TODO
\end{align*}

\PENDING{Show the definition of list mapping and filtering with the rich
  edit language with inserts and deletes.  Work out a real example showing
  how an edit would look for a document with nested sections and
  subsections.} 

\paragraph*{Other edits}

\finish{What about swaps and such?  Other kinds of edits?  (To be considered
later, if time allows.)}

\finish{Martin: 
\begin{itemize}\item discuss fibrations, 
\item implementation issues (efficiency)
\item containers. 
\end{itemize}
}
\fi  %\iffull

